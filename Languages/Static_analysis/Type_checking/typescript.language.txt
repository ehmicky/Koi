
              
   TYPESCRIPT  
              



See:
  - https://github.com/Microsoft/TypeScript/wiki/FAQ

VERSION ==>                       #3.5.1

CONF ==>                          #Can be:
                                  #  -

tsc FILE...                       #Check and remove TypeScript types.
                                  #Output files with different extension ('.ts' -> '.js')
                                  #Transpile ES6 syntax like default values???

--outDir DIR                      #Where to output file (def: '.')
--outFile FILE2                   #Concatenate into single output FILE2

--watch|w                         #Watch mode


STRUCTURAL TYPING ==>             #Not nominative, i.e. TYPE is the structure not the name.

TYPE                              #Among the ones below
'TYPE'                            #Stringified TYPE

type TYPE = TYPE2                 #Alias
interface OBJ_TYPE                #Same as type OBJ_TYPE = { ... } except:
 [extends OBJ_TYPE2] { ... }      #  - can inherit from OBJ_TYPE2

any                               #Union of all possible TYPEs
never                             #No possible value.
                                  #I.e. value that should not exist runtime. E.g.:
                                  #  - return value of function that never returns (e.g. throws)
                                  #  - type guards that can't be true
                                  #Transtype never -> TYPE always possible.

undefined                         #
null                              #
void                              #undefined|null
--strictNullChecks                #Unless set, transtype undefined|null -> TYPE always possible

boolean                           #BOOL
number                            #NUM
string                            #STR

enum ENUM {NAME [= VAL],...}      #ENUM
                                  #Def VAL is incrementing NUM, starting at 0.
ENUM.NAME                         #ENUM item's VAL
ENUM[VAL]                         #ENUM item's 'TYPE'

object                            #OBJ
                                  #Includes any child: FUNC, ARR, new String(STR), REGEXP, etc.
                                  #Includes Object.create(null)
                                  #Excludes null
{ VAR[?]: TYPE,... }              #OBJ with specific properties
                                  #Delimiters:
                                  #  - can be , ; or newline
                                  #  - can use trailing delimiters
                                  #No missing properties:
                                  #  - unless either '?' or using default '= VAL'
                                  #  - regardless of its TYPE
                                  #     - even undefined|null, i.e. {VAR: undefined} works but not {}
                                  #No additional properties:
                                  #  - unless both:
                                  #     - assigned an OBJ VAR (instead of an OBJ literal)
                                  #     - not all properties are additional
                                  #  - should not rely on those exceptions
{ [VAR: TYPE2]: TYPE, ... }       #Applies to all properties, additional or not.
                                  #Additional properties are then allowed.
                                  #TYPE2 is the key type, either:
                                  #  - NUM
                                  #  - STR: actually NUM|STR

[new] ([...]VAR[?]: TYPE,...)     #FUNC
 => TYPE2                         #TYPE2 is return value.
                                  #No missing arguments: like OBJ missing properties.
                                  #No additional arguments:
                                  #  - unless defined variadic ...VAR (always optional)
                                  #VAR names are not significant.
                                  #new:
                                  #  - requiring using new FUNC()
                                  #  - e.g. a CLASS constructor
{ FUNC(...): TYPE2 }              #OBJ.FUNC: shortcut for { FUNC: (...) => TYPE2 }
{ [new] (...): TYPE2 }            #FUNC with OBJ properties

TYPE[]
Array<TYPE>                       #ARR of same types
[TYPE,...]                        #ARR of different types (TUPLE).
                                  #Each TYPE is only for that index. If outside range, use a union of all possible TYPEs.

Readonly<TYPE>
readonly TYPE[]
readonly [TYPE,...]
{ readonly ...: TYPE,... }        #Shallow immutable
ReadonlyArray<TYPE>               #Same as Readonly<Array<TYPE>>


TYPE | TYPE2                      #Union ("or")
TYPE & TYPE2                      #Intersection ("and")


DEFAULT ==>                       #Def TYPE is always ANY

QUAL VAR: TYPE [= VAL]            #

function [FUNC]
 (VAR[?]: TYPE,...): TYPE2 {...}
(VAR[?]: TYPE,...): TYPE2 => ...  #

class ... {
  ... VAR: TYPE ...
  FUNC(VAR[?]: TYPE,...): TYPE2 {}
}                                 #

class ... implements OBJ_TYPE {}  #Does not apply to private #VAR

<TYPE>VAL                         #Declaring TYPE of VAL ("type assertion")
VAL as TYPE                       #Has stronger operator precedence than everything except () .VAR [INDEX] new (...ARGS) ++ --

IMPLICIT TRANSTYPING ==>          #For TYPE -> TYPE2:
                                  #  - TYPE2 must be contravariant to TYPE
                                  #  - for FUNCS: bivariant input, contravariant output
                                  #Child|subtype:
                                  #  - CHILD -> PARENT must be possible
                                  #  - PARENT contravariant to CHILD
                                  #  - i.e. contravariant preconditions|input, covariant postconditions|output

VARIANCE ==>                      #  - covariant: equal|stricter, e.g. string|number -> string
                                  #  - contravariant: equal|weaker, e.g. string -> string|number
                                  #  - bivariant:
                                  #     - either covariant or contravariant
                                  #     - but must have intersection, not be completely different
                                  #     - e.g. string|number -> string, string -> string|number, but not string -> boolean
                                  #  - invariant: equal, e.g. string -> string
