
              
   TYPESCRIPT  
              



See:
  - https://www.typescriptlang.org/docs/handbook/enums.html#ambient-enums
  - https://github.com/Microsoft/TypeScript/wiki
  - go through recent changelogs
  - https://github.com/microsoft/TypeScript/blob/master/doc/spec.md

VERSION ==>                       #3.5.1

CONF ==>                          #Can be:
                                  #  -

tsc FILE...                       #Check and remove TypeScript types.
                                  #Output files with different extension ('.ts' -> '.js')
                                  #Transpile ES6 syntax like default values???

--outDir DIR                      #Where to output file (def: '.')
--outFile FILE2                   #Concatenate into single output FILE2

--watch|w                         #Watch mode


STRUCTURAL TYPING ==>             #Not nominative, i.e. TYPE is the structure not the name.
                                  #Exception: CLASS private|protected fields.

TYPE                              #Among the ones below
'TYPE'                            #Stringified TYPE

type TYPE = TYPE2                 #Alias
                                  #TYPE2 name will be used (not TYPE) in error messages and IDE tools.

typeof VAL                        #Returns its TYPE
                                  #If VAL is CLASS, returns its constructor() FUNC_TYPE

keyof TYPE                        #TYPE2 of TYPE properties keys (including methods)
                                  #Union of all keys STR|NUM|SYM_TYPE
                                  #No keys -> never
                                  #Non-OBJ_TYPE use prototype properties
                                  #  - null|undefined have none
TYPE[TYPE2]                       #TYPE3 of TYPE properties values (including methods)
                                  #TYPE2 must intersect with keyof TYPE
                                  #If several properties, TYPE3 is union.
{ [T in TYPE2|...]: VAL }         #Expanded to OBJ_TYPE where:
                                  #  - keys are each TYPE2 in union TYPE2|...
                                  #     - must be STR|NUM|SYM_TYPE2
                                  #  - VAL can refer to T (current TYPE2)
                                  #Cannot define other properties directly:
                                  #  - but can do it through ... & OBJ_TYPE2
                                  #Often used to map a TYPE using { [P in keyof TYPE]: TYPE[P] }
                                  #Can use ? and readonly on key like other OBJ_TYPEs

any                               #Union of all possible TYPEs
                                  #Default TYPE
                                  #Values can use any operators of any TYPE.
                                  #Transtype TYPE <-- any always possible (except never)
                                  #Transtype any <-- TYPE always possible
                                  #any | TYPE -> any
                                  #any & TYPE -> TYPE
unknown                           #Like any:
                                  #  - transtype TYPE <-- unknown always possible (except never)
                                  #  - unknown | TYPE -> unknown
                                  #  - unknown & TYPE -> TYPE
                                  #But:
                                  #  - values can only operators common to any TYPE, i.e. === !== =
                                  #  - can only transtype any <-- unknown
                                  #  - unknown | any -> any, unknown & any -> any
never                             #No possible value.
                                  #I.e. value that should not exist runtime. E.g.:
                                  #  - return value of function that never returns (e.g. throws)
                                  #  - type guards that can't be true
                                  #Transtype TYPE <-- never always possible.
                                  #Transtype never <-- TYPE never possible (except never itself)
                                  #never | TYPE -> TYPE
                                  #never & TYPE -> never
                                  #Union with no members -> never
                                  #Intersection with nothing in common -> never

undefined                         #
null                              #
void                              #undefined|null
--strictNullChecks                #Unless set, transtype TYPE <-- undefined|null always possible
VAL!                              #Transtype to same TYPE minus undefined|null

boolean                           #BOOL
number                            #NUM
string                            #STR
bigint                            #BIGINT
BOOL|NUM|STR|BIGINT               #Only that value. Must be literal value.

symbol                            #Any SYM
unique symbol                     #Specific SYM. Child of 'symbol'.
                                  #Well-known SYM have type 'symbol' but Symbol[.for]() have type 'unique symbol'

const enum ENUM                   #Def STR|NUM is previous NUM + 1, or 0 if first one.
 { NAME [=STR|NUM],... }          #STR|NUM can be an EXPR using () + - ~ * / % << >> >>> & | ^
ENUM.NAME                         #Item's VAL:
                                  #  - inlined to STR|NUM
                                  #  - must be used instead of STR|NUM directly
                                  #Can also be used as TYPE providing:
                                  #  - no STR|NUM is an EXPR
                                  #  - ENUM is the original variable (not an alias)

enum ENUM {...}                   #Same but ENUM is inlined as an OBJ:
                                  #  - i.e. can be used both as a TYPE and an OBJ
                                  #  - ENUM.NAME is inlined as OBJ.NAME instead of NUM|STR
                                  #Can use ENUM[NUM] -> 'TYPE'
                                  #NUM EXPR can also use other operators providing:
                                  #  - next NAME is initialized

object                            #OBJ
                                  #Includes any child: FUNC, ARR, new String(STR), REGEXP, etc.
                                  #Includes Object.create(null)
                                  #Excludes null
{ VAR[?]: TYPE,... }              #OBJ with specific properties
                                  #Delimiters:
                                  #  - can be , ; or newline
                                  #  - can use trailing delimiters
                                  #No missing properties unless '?':
                                  #  - regardless of its TYPE
                                  #     - even undefined|null, i.e. {VAR: undefined} works but not {}
                                  #No additional properties:
                                  #  - unless both:
                                  #     - assigned an OBJ VAR (instead of an OBJ literal)
                                  #     - not all properties are additional
                                  #  - should not rely on those exceptions
{ [VAR: TYPE2]: TYPE, ... }       #TYPE of OBJ[NUM|STR]
                                  #Applies to all properties, additional or not.
                                  #Additional properties are then allowed.
                                  #TYPE2 is the key type, either:
                                  #  - NUM
                                  #  - STR: actually NUM|STR
Partial<OBJ_TYPE>                 #Add ? to all properties

class CLASS                       #CLASS can be used as OBJ_TYPE (of instances):
                                  #  - including methods, except constructor()
                                  #  - excluding static properties|methods
                                  #  - including non-initialized properties|methods
                                  #  - including protected|private properties|methods
                                  #     - i.e. can only match CLASS instances
                                  #  - {...} can use the same syntax (e.g. { VAR[?]: TYPE })
                                  #As opposed to INTERFACE, it is both a runtime value and an OBJ_TYPE
  [extends CLASS2]                #Same as JavaScript, i.e. inherit|mixin members (types+values) from CLASS2
  [implements OBJ_TYPE,...]       #Must redefined members from OBJ_TYPE,...
{
  [public|protected|private] VAR  #Fields visibility is different than JavaScript:
                                  #  - VAR -> [public] VAR
                                  #  - #VAR -> private VAR
                                  #  - not possible -> protected VAR
                                  #     - like private VAR but child CLASS can access it too
  constructor                     #When QUAL specified, shortcut to set this.VAR = VAL.
    (QUAL VAR[?]: TYPE,...)       #QUAL is public|protected|private|readonly and used the same as { QUAL VAR }
                                  #Constructor return type is always CLASS, i.e. must not be specified.
}

abstract CLASS ... {              #CLASS that cannot be instantiated (but children can)
  abstract FUNC(...): TYPE        #FUNC with no body, that must be reimplemented by children
}

interface INTERFACE               #Like type INTERFACE = { ... } but preferred because:
 [extends OBJ_TYPE,...] { ... }   #  - can 'extends': inherit|mixin members (types) from OBJ_TYPE
                                  #  - INTERFACE name is used (instead of literal OBJ) in error messages and IDE tools

ConstructorType                   #Any OBJ children can be used as TYPE, just like CLASS.
                                  #This includes Error, RegExp, Date, etc.
Promise[<T>]                      #PROMISE resolving T or (if T includes 'never') rejecting anything.

[new] ([...]VAR[?]: TYPE,...)     #FUNC
 => TYPE2                         #TYPE2 is return value.
                                  #No missing arguments: like OBJ missing properties
                                  #No additional arguments:
                                  #  - unless defined variadic ...VAR (always optional)
                                  #VAR names are not significant.
                                  #new:
                                  #  - requiring using new FUNC()
                                  #  - e.g. a CLASS constructor
                                  #Argument TYPEs is not checked inside body for transtyping that happens after declaration.
{ FUNC(...): TYPE2 }              #OBJ.FUNC: shortcut for { FUNC: (...) => TYPE2 }
{ [new] (...): TYPE2 }            #FUNC with OBJ properties

this                              #Can be:
                                  #  - VAR (argument): must be first parameter
                                  #  - TYPE2 (return value)

TYPE[]
Array<TYPE>                       #ARR of same types
[TYPE,...]                        #ARR of different types (TUPLE).
                                  #Each TYPE is only for that index. If outside range, use a union of all possible TYPEs.

{ readonly ...: TYPE,... }        #Shallow immutability (like `const`) of OBJ properties.
Readonly<OBJ_TYPE>                #`readonly` to all OBJ properties.
readonly OBJ_TYPE[]               #Does not apply to the OBJ itself.
readonly [OBJ_TYPE,...]           #Does not work on INTERFACE.
ReadonlyArray<TYPE>               #Same as Readonly<Array<TYPE>>
class ...
  { readonly ...: TYPE,... }      #Like OBJ, but mutable in constructor()


TYPE | TYPE2                      #Union ("or")
TYPE & TYPE2                      #Intersection ("and")


type TYPE<T...> = ...             #Declaring a generic TYPE, i.e. must specify another TYPE2 during usage.
class CLASS<T...> {}              #<T...> is <T [extends TYPE3,...][= TYPE4],...>
interface INTERFACE<T,...> {}     #Type of T is:
[new] <T...>(...) => ...          #  - when not instantiated: TYPE3 & ... (def: unknown)
{ FUNC<T...>(...): ... }          #  - when instantiated: the specified TYPE2 (def: TYPE4, required otherwise)
{ [new] <T...>(...): ... }        #There can be several <T,...>
                                  #  - each can refer to each other
                                  #Can also transtype towards TYPE|CLASS|INTERFACE|FUNC that is generic itself.
                                  #  - i.e. values transtyped towards generic TYPE must already have been declared using <T,...>

TYPE<TYPE2,...>                   #Using a generic TYPE


QUAL VAR: TYPE [= VAL]            #

function [FUNC][<T,...>]
 (VAR[?]: TYPE,...): TYPE2 {...}
[<T,...>]
 (VAR[?]: TYPE,...): TYPE2 => ...
[class ...] {
  FUNC[<T,...>]
   (VAR[?]: TYPE,...): TYPE2 {}
}                                 #

[new] CLASS|FUNC<TYPE2,...>(...)  #

function FUNC(...): TYPE2         #Function overloading.
...                               #The first FUNCs are the overloads, the last one is the implementation. Must follow each other.
function FUNC(...): TYPE3 {...}   #Each overload is tried in order until one matches.

<TYPE>VAL                         #Declaring TYPE of VAL ("type assertion")
VAL as TYPE                       #Has stronger operator precedence than everything except () .VAR [INDEX] new (...ARGS) ++ --
                                  #Bypasses transtyping rules


TRANSTYPING RULES ==>             #For TYPE2 <-- TYPE, TYPE2 must be contravariant to TYPE.
                                  #For FUNCs:
                                  #  - bivariant arguments
                                  #     - although should theoritically be covariant
                                  #        - reason is common callback pattern in JavaScript:
                                  #           - TYPE2 is callback parameter, which must be generic
                                  #           - TYPE is callback argument, which is more specific
                                  #           - should theoritically use TYPE2 as argument instead, and do a <TYPE> assertion
                                  #             instead, but it's more verbose
                                  #     - including for argument optionality, for the same reasons
                                  #     - but covariant for arity: FUNC2.length must >= FUNC.length
                                  #  - contravariant return value
                                  #     - including type guards
                                  #For CLASS:
                                  #  - PARENT <-- CHILD must be possible
                                  #  - i.e. PARENT must be contravariant to CHILD
                                  #See polymorphism docs for more info.

TYPE INFERENCE ==>                #Only needed for untyped values:
                                  #  - i.e. not needed for JavaScript operators (including =) since their types is known
                                  #Untyped FUNC parameters:
                                  #  - use caller's argument literal value as TYPE
                                  #  - if "= VAL" (default value), use '?'
                                  #Untyped FUNC return value:
                                  #  - use return literal value as TYPE
                                  #  - if several return statements, use union
                                  #Literal values:
                                  #  - use literal value as TYPE
                                  #  - OBJ: do it recursively
                                  #  - ARR:
                                  #     - do it recursively, as a union
                                  #     - if empty -> never[]
                                  #Possible issues:
                                  #  - too generic TYPEs in entry points
                                  #     - e.g. default "any"
                                  #  - too generic|specific TYPEs in literal values
                                  #     - e.g. [] but meant readonlyArray<T>
                                  #     - e.g. TypeError but meant Error
                                  #  - FUNC arguments -> return value relation is not specified
                                  #     - e.g. output is number|boolean if input.type is "number|boolean"

TYPE GUARDS ==>                   #When:
                                  #  - using: if|else, switch, ternary (? :), chaining (&& ||)
                                  #  - with: typeof VAL, instanceof VAL, === !== == != VAL
                                  #  - and only: ! && ||
                                  #Then inside the blocks:
                                  #  - ARG will be transtyped to the right TYPE
                                  #  - including return value TYPE if has `return` statement
TAGGED UNION ==>                  #When type guarding with OBJ.VAR === !== == != VAL, it type guards OBJ as well.
                                  #For example:
                                  #  type A = { kind: 'A' }
                                  #  type B = { kind: 'B' }
                                  #  (obj: A|B) => obj.kind === 'A' && ... // `obj` will be of type A
VAR is TYPE                       #When used as FUNC return value's TYPE2, means FUNC() can be used as a type guard.
                                  #FUNC must return BOOL determining whether argument VAR belongs to TYPE.

--noImplicitThis                  #Error when using `this` with type ANY.
                                  #I.e. caller did FUNC() instead of OBJ.FUNC() or FUNC.call|bind(OBJ)
