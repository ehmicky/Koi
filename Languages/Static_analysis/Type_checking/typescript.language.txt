
              
   TYPESCRIPT  
              



See:
  - https://github.com/Microsoft/TypeScript/wiki
  - go through recent changelogs
  - https://github.com/microsoft/TypeScript/blob/master/doc/spec.md
  - source like https://github.com/microsoft/TypeScript/blob/master/src/lib/es5.d.ts

VERSION ==>                       #3.5.1

DIFFERENCE FROM JAVASCRIPT ==>    #  - TYPE declaration
                                  #  - TYPE transtyping
                                  #  - declare
                                  #  - namespace
                                  #  - [const] enum -> inlined as VAL|OBJ
                                  #  - different CLASS syntax|features: implements, public|protected|private, parameter properties, abstract
                                  #  - module resolution (no '.EXT', *.ts|tsx|d.ts, PACKAGE.types[Version])
                                  #  - module loading (CommonJS default export, <reference/>, declare module|global, export as namespace)

CONF ==>                          #Can be:
                                  #  -
CCONF                             #CONF.compilerOptions

tsc FILE...                       #Check and remove TypeScript types.
                                  #Output files with different extension ('.ts' -> '.js')
                                  #Transpile ES6 syntax like default values???

--outDir DIR                      #Where to output file (def: '.')
--outFile FILE2                   #Concatenate into single output FILE2
                                  #Cannot be used with --module es*|umd

--watch|w                         #Watch mode


STRUCTURAL TYPING ==>             #Not nominative, i.e. TYPE is the structure not the name.
                                  #Exception: CLASS private|protected fields.

TYPE                              #Among the ones below
UTYPE                             #Union of several TYPE
                                  #never if no members.

type TYPE = TYPE2                 #Alias
                                  #TYPE2 name will be used (not TYPE) in error messages and IDE tools.

typeof VAL                        #Returns its TYPE
                                  #If VAL is CLASS, returns its constructor() FUNC_TYPE (instead of instance OBJ_TYPE)

TYPE extends TYPE2                #If TYPE is covariant (child|equal) to TYPE2, resolves to TYPE3, otherwise TYPE4
 ? TYPE3 : TYPE4                  #If TYPE is generic:
                                  #  - results in union of all possible TYPE3|TYPE4
                                  #  - transtyped to TYPE & TYPE2 if used inside TYPE3
                                  #TYPE2 can contain "infer T":
                                  #  - generic type that can be used inside TYPE3
                                  #  - guessed by trying to transtype TYPE to TYPE2
                                  #  - sometimes need () for operators precedence
                                  #Common ones:
                                  #  - boolean as generic TYPE and BOOL as TYPE2
                                  #  - STR_UTYPE as generic TYPE and STR as TYPE2

KTYPE                             #TYPE of an OBJ key, i.e. STR|NUM|SYM_TYPE
                                  #Either:
                                  #  - { VAR: ... }: literal value TYPE
                                  #  - { [VAR: TYPE]: ... }: any TYPE
KUTYPE                            #UTYPE of KTYPE
keyof TYPE                        #KUTYPE of TYPE properties keys (including methods)
                                  #Non-OBJ_TYPE use prototype properties
                                  #  - null|undefined have none
                                  #Common ones:
                                  #  - keyof any: any KTYPE
TYPE[TYPE2]                       #UTYPE of TYPE properties values (including methods)
                                  #TYPE2 must intersect with keyof TYPE
                                  #Common ones:
                                  #  - ARR_TYPE[number]: TYPE of any ARR element
                                  #  - OBJ_TYPE[keyof OBJ_TYPE]: TYPE of any property
{ [T in KUTYPE]: VAL }            #Expanded to OBJ_TYPE where:
                                  #  - keys are each KTYPE in KUTYPE
                                  #  - VAL can refer to T (current KTYPE)
                                  #Cannot define other properties directly:
                                  #  - but can do it through ... & OBJ_TYPE2
                                  #Often used to map a TYPE using { [P in keyof TYPE]: TYPE[P] }
                                  #Can use ? and readonly on key like other OBJ_TYPEs
                                  #  - can be prefixed with -|+ to mean "remove|add"

any                               #Union of all possible TYPEs
                                  #Default TYPE
                                  #Values can use any operators of any TYPE.
                                  #Transtype TYPE <-- any always possible (except never)
                                  #Transtype any <-- TYPE always possible
                                  #any | TYPE -> any
                                  #any & TYPE -> TYPE
unknown                           #Like any:
                                  #  - transtype unknown <-- TYPE always possible
                                  #  - unknown | TYPE -> unknown
                                  #  - unknown & TYPE -> TYPE
                                  #But:
                                  #  - values can only operators common to any TYPE, i.e. === !== =
                                  #  - can only transtype any|unknown <-- unknown
                                  #  - unknown | any -> any, unknown & any -> any
never                             #No possible TYPE.
                                  #Transtype TYPE <-- never always possible.
                                  #Transtype never <-- TYPE never possible (except never itself)
                                  #never | TYPE -> TYPE
                                  #never & TYPE -> never
                                  #Examples:
                                  #  - union with no members
                                  #  - intersection with nothing in common
                                  #  - return statement that can't be reached (e.g. exception, or type guard that can't be true)

undefined                         #
null                              #
void                              #undefined|null
--strictNullChecks                #Unless set, transtype TYPE <-- undefined|null always possible
NonNullable<TYPE>                 #Same TYPE minus undefined|null

boolean                           #BOOL
number                            #NUM
string                            #STR
bigint                            #BIGINT
BOOL|NUM|STR|BIGINT               #TYPE for only that value. Must be literal value.

symbol                            #Any SYM
unique symbol                     #Specific SYM. Child of 'symbol'.
                                  #Well-known SYM have type 'symbol' but Symbol[.for]() have type 'unique symbol'

const enum ENUM                   #Def STR|NUM is previous NUM + 1, or 0 if first one.
 { NAME [= STR|NUM],... }         #STR|NUM can be an EXPR using () + - ~ * / % << >> >>> & | ^
ENUM.NAME                         #Item's VAL:
                                  #  - inlined to STR|NUM
                                  #  - must be used instead of STR|NUM directly
                                  #Can also be used as TYPE providing:
                                  #  - no STR|NUM is an EXPR
                                  #  - ENUM is the original variable (not an alias)

enum ENUM {...}                   #Same but ENUM is inlined as an OBJ:
                                  #  - i.e. can be used both as a TYPE and an OBJ
                                  #  - ENUM.NAME is inlined as OBJ.NAME instead of NUM|STR
                                  #Can use ENUM[NUM] -> 'TYPE'
                                  #NUM EXPR can also use other operators providing:
                                  #  - next NAME is initialized

object                            #OBJ
                                  #Includes any child: FUNC, ARR, new String(STR), REGEXP, etc.
                                  #Includes Object.create(null)
                                  #Excludes null
{ VAR[?]: TYPE,... }              #OBJ with specific properties
                                  #Delimiters:
                                  #  - can be , ; or newline
                                  #  - can use trailing delimiters
                                  #No missing properties unless '?':
                                  #  - even undefined|null, i.e. {VAR: undefined} works but not {}
                                  #No additional properties:
                                  #  - unless both:
                                  #     - using an OBJ VAR (instead of an OBJ literal)
                                  #     - not all properties are additional
                                  #  - should not rely on those exceptions
{ [VAR: TYPE2]: TYPE, ... }       #TYPE of OBJ[NUM|STR]
                                  #Applies to all properties, additional or not.
                                  #Additional properties are then allowed.
                                  #TYPE2 is the key type, either:
                                  #  - NUM
                                  #  - STR: works for OBJ[NUM] too
Partial<OBJ_TYPE>                 #Adds ? on all properties
Required<OBJ_TYPE>                #Removes ? on all properties
Pick<OBJ_TYPE, KUTYPE>            #Only keep KUTYPE properties
Omit<OBJ_TYPE, KUTYPE>            #Inverse
Record<KUTYPE, TYPE>              #OBJ_TYPE with:
                                  #  - key for each KTYPE
                                  #  - value always TYPE

class CLASS                       #CLASS can be used as OBJ_TYPE (of instances):
                                  #  - including:
                                  #     - methods
                                  #     - non-initialized properties|methods
                                  #     - protected|private properties|methods
                                  #        - if any, can only match CLASS instances
                                  #  - excluding:
                                  #     - constructor()
                                  #     - static properties|methods
                                  #{...} can use the same syntax (e.g. { VAR[?]: TYPE })
                                  #As opposed to INTERFACE, it is both a runtime value and an OBJ_TYPE
  [extends CLASS2]                #Same as JavaScript, i.e. inherit|mixin members (types+values) from CLASS2
  [implements OBJ_TYPE,...]       #Must implement members of OBJ_TYPE,...
{
  constructor(...)                #Constructor return type is always CLASS, i.e. must not be specified.
  constructor                     #When QUAL specified, shortcut to set this.VAR = VAL. "Parameter properties"
   (QUAL VAR[?]: TYPE,...)        #QUAL is public|protected|private|readonly and used like { QUAL VAR }
  [public|protected|private] VAR  #Fields visibility is different than JavaScript:
                                  #  - VAR -> [public] VAR
                                  #  - #VAR -> private VAR
                                  #  - not possible -> protected VAR
                                  #     - like private VAR but child CLASS can access it too
}

abstract CLASS ... {              #CLASS that cannot be instantiated (but children can)
  abstract FUNC(...): TYPE        #FUNC with no body, that must be reimplemented by children
}

interface INTERFACE               #Like type INTERFACE = { ... } but preferred because:
 [extends OBJ_TYPE,...] { ... }   #  - can 'extends': inherit|mixin members (types) from OBJ_TYPE
                                  #  - INTERFACE name is used (instead of literal OBJ) in error messages and IDE tools
INTERFACE MERGING ==>             #If INTERFACE declared several times, merge them.
                                  #Properties can have same name but:
                                  #  - non-FUNCs must have same TYPE (i.e. unchanged)
                                  #  - FUNCs will be overloaded, in that order:
                                  #     - if single STR literal argument, always first
                                  #     - last declared before first declared

CONSTRUCTOR_FUNC                  #Any constructor FUNC can be used as OBJ instance TYPE, just like CLASS.
                                  #This includes:
                                  #  - Error, RegExp, Date, etc.
                                  #  - Object|Number|String|Boolean but should use object|number|string|boolean instead
Promise[<T>]                      #PROMISE either:
                                  #  - resolving T
                                  #     - if 'never', means cannot resolve
                                  #  - rejecting anything

Function                          #Any FUNC
                                  #Should prefer the specific FUNC_TYPEs below

[new] ([...]VAR[?]: TYPE,...)     #Specific FUNC (child of Function)
 => TYPE2                         #TYPE2 is return value.
                                  #No missing arguments: like OBJ missing properties
                                  #No additional arguments:
                                  #  - unless defined variadic ...VAR (always optional)
                                  #VAR names are not significant.
                                  #Argument TYPEs are only checked inside body during declaration statement
                                  #  - not when FUNC is transtyped after declaration
{ FUNC(...): TYPE2 }              #OBJ.FUNC: shortcut for { FUNC: (...) => TYPE2 }
{ (...): TYPE2, ... }             #FUNC with OBJ properties
new (...) => TYPE2                #Require using new FUNC()
{ new (...): TYPE2 }              #  - e.g. a CLASS constructor
                                  #Prefer using a CLASS definition

this                              #Can be:
                                  #  - VAR (argument): must be first parameter
                                  #  - TYPE2 (return value)
--noImplicitThis                  #Error when using `this` with type ANY.
                                  #I.e. caller did FUNC() instead of OBJ.FUNC() or FUNC.call|bind(OBJ)

Parameters<FUNC_TYPE>             #Parameters [TYPE,...] (tuple)
ReturnType<FUNC_TYPE>             #Return value TYPE2
ConstructorParameters<FUNC_TYPE>  #Same as Parameters<> but for 'new FUNC'
InstanceType<FUNC_TYPE>           #Same as ReturnType<> but for 'new FUNC'

TYPE[]
Array<TYPE>                       #ARR of same types
[TYPE,...]                        #ARR of different types (TUPLE).
                                  #Each TYPE is only for that index. If outside range, use a union of all possible TYPEs.

{ readonly ...: TYPE,... }        #Shallow immutability (like `const`) of OBJ properties.
                                  #Should be specified whenever possible.
Readonly<OBJ_TYPE>                #`readonly` to all OBJ properties.
                                  #Does not apply to the OBJ itself.
                                  #Does not work on INTERFACE.
readonly TYPE[]
readonly [TYPE,...]
ReadonlyArray<TYPE>               #Same for all ARR members.
class ...
  { readonly ...: TYPE,... }      #Like OBJ. Exception: field is mutable in constructor()


TYPE | TYPE2                      #Union ("or")
TYPE & TYPE2
Extract<TYPE, TYPE2>              #Intersection ("and")
Excludes<TYPE, TYPE2>             #Difference (in TYPE but not in TYPE2)


type TYPE<T...> = ...             #Declaring a generic TYPE, i.e. must specify another TYPE2 during usage.
class CLASS<T...> {}              #<T...> is <T [extends TYPE3,...][= TYPE4],...>
interface INTERFACE<T,...> {}     #Type of T is:
[new] <T...>(...) => ...          #  - when not instantiated: TYPE3 & ... (def: unknown)
{ FUNC<T...>(...): ... }          #  - when instantiated: the specified TYPE2 (def: TYPE4, required otherwise)
{ [new] <T...>(...): ... }        #There can be several <T,...>
                                  #  - each can refer to each other
                                  #Can also transtype towards TYPE|CLASS|INTERFACE|FUNC that is generic itself.
                                  #  - i.e. values transtyped towards generic TYPE must already have been declared using <T,...>

TYPE<TYPE2,...>                   #Using a generic TYPE


<TYPE>VAL                         #Type assertion of a VAL
VAL as TYPE                       #Has stronger operator precedence than everything except () .VAR [INDEX] new (...ARGS) ++ --
                                  #Bypasses transtyping rules

VAL!                              #Transtype to same TYPE minus undefined|null

QUAL VAR: TYPE [= VAL]            #Type assertion during VAR declaration

function [FUNC][<T,...>]
 (VAR[?]: TYPE,...): TYPE2 {...}
[<T,...>]
 (VAR[?]: TYPE,...): TYPE2 => ...
[class ...] {
  FUNC[<T,...>]
   (VAR[?]: TYPE,...): TYPE2 {}
}                                 #Type assertion during FUNC declaration

[new] CLASS|FUNC<TYPE2,...>(...)  #Type assertion during FUNC call

function FUNC(...): TYPE2         #Function overloading.
...                               #The first FUNCs are the overloads, the last one is the implementation. Must follow each other.
function FUNC(...): TYPE3 {...}   #Each overload is tried in order until one matches, i.e. most specific should be first.


TRANSTYPING RULES ==>             #For TYPE2 <-- TYPE, TYPE2 must be contravariant to TYPE.
                                  #For FUNCs:
                                  #  - bivariant arguments
                                  #     - although should theoritically be covariant
                                  #        - reason is common callback pattern in JavaScript:
                                  #           - TYPE2 is callback parameter, which must be generic
                                  #           - TYPE is callback argument, which is more specific
                                  #           - should theoritically use TYPE2 as argument instead, and do a <TYPE> assertion
                                  #             instead, but it's more verbose
                                  #     - including for argument optionality, for the same reasons
                                  #     - but covariant for arity: FUNC2.length must >= FUNC.length
                                  #  - contravariant return value
                                  #     - including type guards
                                  #For CLASS:
                                  #  - PARENT <-- CHILD must be possible
                                  #  - i.e. PARENT must be contravariant to CHILD
                                  #See polymorphism docs for more info.

TYPE INFERENCE ==>                #Only needed for untyped values:
                                  #  - i.e. not needed for JavaScript operators (including =) since their types is known
                                  #Untyped FUNC parameters:
                                  #  - use caller's argument literal value as TYPE
                                  #  - if "= VAL" (default value), use '?'
                                  #Untyped FUNC return value:
                                  #  - use return literal value as TYPE
                                  #  - if several return statements, use union
                                  #Literal values:
                                  #  - use literal value as TYPE
                                  #  - OBJ: do it recursively
                                  #  - ARR:
                                  #     - do it recursively, as a union
                                  #     - if empty -> never[]
                                  #Possible issues:
                                  #  - too generic TYPEs in entry points
                                  #     - e.g. default "any"
                                  #  - too generic|specific TYPEs in literal values
                                  #     - e.g. [] but meant ReadonlyArray<T>
                                  #     - e.g. TypeError but meant Error
                                  #  - FUNC arguments -> return value relation is not specified
                                  #     - e.g. output is number|boolean if input.type is "number|boolean"

TYPE GUARDS ==>                   #When:
                                  #  - using: if|else, switch, ternary (? :), chaining (&& ||)
                                  #  - with: typeof VAL, instanceof VAL, === !== == != VAL
                                  #  - and only: ! && ||
                                  #Then inside the blocks:
                                  #  - ARG will be transtyped to the right TYPE
                                  #  - including return value TYPE if has `return` statement
VAR is TYPE                       #When used as FUNC return value's TYPE2, means FUNC() can be used as a type guard.
                                  #FUNC must return BOOL determining whether argument VAR belongs to TYPE.
TAGGED UNION ==>                  #When type guarding with OBJ.VAR === !== == != VAL, it type guards OBJ as well.
                                  #For example:
                                  #  type A = { kind: 'A' }
                                  #  type B = { kind: 'B' }
                                  #  (obj: A|B) => obj.kind === 'A' && ... // `obj` will be of type A

namespace NAMESPACE { ... }       #Scope { ... } under NAMESPACE (which is transpiled to an anonymous function).
                                  #NAMESPACE can be used as an OBJ value.
                                  #Meant for pre-ESM modules (global object, AMD, UMD, etc.)
export ...                        #Assign to NAMESPACE.VAR, i.e. allow using outside of NAMESPACE
                                  #Same syntax as `declare ...`
                                  #Not same as ESM `export` keyword.

import VAR2 = NAMESPACE.VAR       #Like const VAR2 = NAMESPACE.VAR except also works if NAMESPACE.VAR is a TYPE
                                  #Not same as ESM `import` keyword.

NAMESPACE MERGING ==>             #If NAMESPACE declared several times, merge exported VARs.
                                  #Non-exported VARs are not merged.
                                  #Exported VARs must not have same names.
NAMESPACE MERGING OTHERS ==>      #If a CLASS|FUNC|ENUM with same name declared before a NAMESPACE,
                                  #do Object.assign(CLASS|FUNC|ENUM, NAMESPACE)

declare QUAL VAR ...              #Declaration|TYPEs only, not implementation:
declare function ...              #  - VAR: cannot be initialized
declare ... enum ...              #     - except with literal STR|NUM|BIGNUM|ENUM (treated as TYPE)
declare ... class ...             #  - FUNC: no body
declare namespace ...             #  - enum|class|namespace: only TYPE not value
declare type ...                  #  - type|interface: noop
declare interface ...             #Useful when TYPE declaration is in TypeScript and implementation in JavaScript.

export declare ...                #ESM `export` must be before `declare`

AMBIENT FILE ==>                  #File where every statement is declare|export
                                  #Often named *.d.ts. Should be sibling to each build file for easy resolution|discovery.
                                  #Should be treated as a production dependency, not dev dependency.
-d|--declaration                  #Generate *.d.ts ambient files:
                                  #  - type inference on import|export statements
                                  #  - only use top-level files (which is guessed from dependency tree)
                                  #  - non assigned import statements are kept
--declarationDir DIR              #Def: same directory as file

--moduleResolution STR            #"MODULE|PATH" resolution:
                                  #  - 'node' (def if --module commonjs):
                                  #     - like Node: node_modules, PACKAGE.main, index.js
                                  #     - *.json only if --resolveJsonModules
                                  #     - PACKAGE.types|typings: same as PACKAGE.main but higher priority and TypeScript-specific
                                  #     - PACKAGE.typesVersions.SEMVER OBJ:
                                  #        - same but only if TypeScript version matches SEMVER
                                  #        - OBJ has same syntax as CCONF.paths
                                  #  - 'classic' (def otherwise):
                                  #     - "PATH": as is
                                  #     - "MODULE": search ".[/../...]/MODULE"
--traceResolution                 #Verbose|debug for --moduleResolution
--baseUrl URL|PATH                #Base URL|PATH for any "MODULE"
CCONF.paths.MODULE                #"URL|PATH"_ARR for this "MODULE"
                                  #If several, tried in order.
                                  #If MODULE is "*":
                                  #  - for any "MODULE"
                                  #  - can add "*" in "URL|PATH", which will be replaced by each "MODULE"
CCONF.rootDirs                    #"DIR"_ARR. When importing inside one of the "DIR"s, other "DIR"s are tried as well.
                                  #Goals:
                                  #  - when merging several source "DIR" into single "DIR2" during build
                                  #  - when "DIR" are dynamically generated and might not exist

FILE EXTENSIONS ==>               #import 'PATH' must not include .EXT
                                  #import 'PATH|MODULE' tries several times using (in order) .ts, .tsx, .d.ts, .js
                                  #  - including PACKAGE.main, i.e. 'FILE.js' will search for 'FILE.ts|tsx|d.ts'

*.JS TYPING ==>                   #*.js can be imported but are untyped (any) by default.
--allowJs                         #Use type inference of *.js exported values
--checkJs                         #Also do type checking inside *.js
// @ts-ignore                     #Ignore --checkJs on next line
// @ts-nocheck                    #Ignore --checkJs on whole file (blacklisting, default)
// @ts-check                      #Only use --checkJs for files with this comment (whitelisting)
JSDOC COMMENTS ==>                #Can be used for typecasting in *.js

--module STR                      #Module system for output:
                                  #  - esnext: ES modules
                                  #  - es2015|es6: same but without import() and import.meta
                                  #  - commonjs (def)
                                  #  - amd
                                  #  - umd
                                  #  - system: SystemJS
                                  #  - none:
                                  #     - global variables
                                  #     - cannot use import|export

ES MODULES ==>                    #Must be used for sources:
                                  #  - imported 'PATH' must use ESM
                                  #  - imported 'MODULE' can use any module system, but non-ESM will be untyped (any)
                                  #     - i.e. 'MODULE' should use ambient files if not packaged as TypeScript
                                  #Can also import|export TYPEs and type|enum|interface|namespace
                                  #Can use dynamic import()
                                  #import.meta is empty OBJ

export = VAL|TYPE                 #exporting|importing default `module.exports` of CommonJS|AMD|UMD
import VAL = require(STR)         #  - as opposed to `module.exports.default` / `export default`
                                  #Require --module commonjs|amd|umd
--esModuleInterop                 #Check __esModule (like Babel) when using both:
                                  #  - ESM default import or import *
                                  #  - --module commonjs|amd|umd
                                  #ESM exports always set __esModule true regardless, except when using --module es*

require(STR)                      #CommonJS import
                                  #As opposed to import VAL = require(STR):
                                  #  - not only default import
                                  #  - can be dynamic
                                  #But return value is untyped (any), i.e. must transtype.

export as namespace NAME          #Declare NAME of global variable used in UMD declaration.
                                  #I.e. any exported variable VAR is also available as global NAME.VAR
                                  #Only for UMD consumers, i.e. importing file must:
                                  #  - use <reference/>
                                  #  - not use ESM, i.e. no other import|export statements
                                  #The current file must:
                                  #  - be named *.d.ts
                                  #  - use ESM, i.e. use another import|export statement

/// <amd-module name="NAME"/>     #With --module amd, NAME of current file (instead of anonymous)

declare module "MODULE" {...}     #Declare the TYPEs (inside {...}) exported by `import "MODULE"`
                                  #Should not be needed: prefer directly using ESM `export` in ambient file.
                                  #Meant to be used with <reference/> but can be imported with ESM `import` too.
                                  #import|export:
                                  #  - can be used in current file, but only inside {...}
                                  #  - can only import from "MODULE" not "PATH"
                                  #  - `export` inside {...} is implied (but can still be used)
                                  #"MODULE" can use globbing *
                                  #  - e.g. "*!text" or "text!*" for loaders that allow such notation
declare module "MODULE";          #Make any `import "MODULE"` work, but untyped (any).
--skipLibCheck                    #Skip type checking of ambient files themselves (not the files that use them)
                                  #Meant to speed up compile speed. Not recommended.

MODULE AUGMENTATION ==>           #When declaring MODULE again, merge with MODULE already declared.
                                  #Merges the same way as INTERFACEs.
                                  #import|export "MODULE|PATH" outside {...} can be used
                                  #  - it must be used in order to distinguish from normal module declaration
                                  #Cannot use globbing *
declare global { ... }            #Module augmentation for global scope.

/// <.../>                        #Transpiler pragma directives
                                  #Must be at top of file (except other comments or blank lines)

/// <reference path="PATH" />     #Deprecated alternative to ESM `import`
                                  #  - meant to import PATH that does not use ESM `export`
                                  #Declare that:
                                  #  - PATH content is included there
                                  #  - current file and PATH share same scope
                                  #     - can reference declarations from each other
                                  #     - i.e. should use NAMESPACEs or 'declare module'
                                  #The inclusion itself is done separately either:
                                  #  - compile-time when using --outFile
                                  #  - by loading both files with <script> from a parent file
--noResolve                       #Ignore all /// <reference .../>

@types/MODULE                     #Ambient files maintained by DefinitelyTyped
                                  #  - central repository (must send PRs)
                                  #  - search at https://microsoft.github.io/TypeSearch/
                                  #Prefer keeping TYPEs in same repository as code instead.
@types/node                       #Same for all core Node.js "MODULE"
/// <reference types="MODULE"/>   #Same as <reference path> but for "@types/MODULE"
--types "MODULE" ...              #'MODULE'_ARR of @types/MODULE to automatically try during "MODULE" resolution (regardless of --moduleResolution)
                                  #Def: any
--typeRoots "DIR" ...             #Resolve "@types/*' to "DIR"_ARR instead.

--lib 'LIB' ...                   #Same as <reference path> but for 'typescript/lib/lib.LIB.d.ts', i.e. core JavaScript types among:
/// <reference lib="LIB"/>        #  - es3|5|6|2015-2019|next
                                  #     - es2015-2019|next.FEATURE: specific feature (automatically included)
                                  #  - dom
                                  #     - dom.iterable: DOM objects being ITERABLE
                                  #     - webworker: WORKER
                                  #     - webworker.importscripts: WORKERGLOBAL.importScripts()
                                  #Def: dom + es* depending on --target
--noLib
/// <reference
 no-default-lib="true"/>          #Do not include any 'LIB'

tslib                            ##Similar to core-js but fewer features:
                                 ##  - `STR`
                                 ##  - ...ARR, ...OBJ, Object.assign()
                                 ##  - async|await
                                 ##  - ITERATOR
                                 ##  - __esModule logic
                                 ##  - @DECORATOR
                                 ##Version 1.10.0
--importHelpers                  ##Use import 'tslib' statements (i.e. must install it) instead of inlining those functions.
--target STR                      #Pick helpers from tslib based on ES version, among es3 (def) or es5|6|2015-2020|next
                                  #I.e. --lib is for sources, --target is for build
--isolatedModules                 #Remove some features that rely on analyzing files together (instead of one at a time):
                                  #  - NAMESPACE
                                  #  - declare const enum
                                  #  - re-exporting a TYPE
                                  #  - without --importHelpers, inline helpers in each file instead of shared
                                  #Must be enabled when using Babel TypeScript plugins
