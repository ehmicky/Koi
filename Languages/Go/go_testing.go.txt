
              
   GO_TESTING  
              



VERSION ==>                       #See Go language


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GO TEST            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go test [IMPORT_PATHS] [ARG...]   #Runs:
                                  #  - go vet
                                  #  - go build, but including also *_test.go
                                  #  - executes resulting TEST_BINARY
                                  #  - prints test summary
                                  #     - to stdout (redirects any stderr to stdout instead)
                                  #ARG... are passed to TEST_BINARY
                                  #  - any go test flag can be set after IMPORT_PATHS too, so should not be any conflicts
                                  #     - to distinguish, can prepend -args to ARG...
                                  #TEST_BINARY includes the source BINARY
                                  #If IMPORT_PATHS is omitted:
                                  #  - current PACKAGE
                                  #  - no caching
                                  #  - imply -v
                                  #Executing TEST_BINARY is cached
                                  #  - if files or CLI flags changed, not cached
                                  #  - convention to disable caching: using -count=1
-vet=RULE,...                     #Which go vet RULEs are run.
                                  #Can be "off"
                                  #Def: only bools|nilfunc|atomic|printf|buildtag
-c                                #Do not execute TEST_BINARY
-o PATH                           #TEST_BINARY's location.
                                  #Def: BINARY.test
-json                             #Prints test results as JSON
-ANY_GO_RUN_FLAG                  #Note: -i implied -c

-list REGEXP                      #Prints all exported functions whose name partially match REGEXP

-v                                #Verbose. Force printing logs from all tests
T.Verbose()->BOOL                 #

-cpu NUM                          #Set GOMAXPROCS


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          TEST FILES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TEST FILES ==>                    #Must export Test*|Example*|Benchmark*()
                                  #Each FUNC is run in its own goroutine

import "testing"                  #

testdata/**                       #Always ignored, i.e. good for fixtures


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        TEST FUNCTIONS         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go test
-run REGEXP                       #Only run tests whose "TestNAME" partially matches REGEXP
                                  #"" means ".*"
-failfast                         #Stops on first test failure
-timeout DURATION                 #Def: "10m"

TestNAME(*testing.T)              #Test function
                                  #If any test assertion fails, exit code 1

testing.T                         #Test function utilities
T.Fail()                          #Mark test as failed. Keep current FUNC|goroutine going.
T.Failed()->BOOL                  #
T.FailNow()                       #Run T.Fail(), then exit current FUNC|goroutine (not others)

T.SkipNow()                       #Mark test as skipped, then exit current FUNC|goroutine (not others)
T.Skipped()->BOOL                 #

go test -short                    #
testing.Short()->BOOL             #Returns whether -short CLI flag is set
                                  #To use in long tests, to T.Skip() them when that flag is set

T.Log[f](...)                     #Similar to fmt.Println|Printf(...) except more test-friendly:
                                  #  - only printed on test failure or if -v CLI flag
T.Error[f](...)                   #Run T.Log[f](...) then t.Fail()
T.Fatal[f](...)                   #Run T.Log[f](...) then t.FailNow()
T.Skip[f](...)                    #Run T.Log[f](...) then t.SkipNow()

T.Name()->"TestNAME"              #

T.Helper()                        #Make function as test helper, i.e. file|line information not printed


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      TEST ORCHESTRATION       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go test -parallel NUM             #Maximum of parallel tests at once (def: GOMAXPROCS)
T.Parallel()                      #Mark as parallel test, i.e. run in parallel with other parallel tests
                                  #Noop unless -parallel CLI flag

T.Cleanup(FUNC())                 #Run FUNC() when test exits.
                                  #Last added is called first.

TestMain(*testing.M)              #When defined:
                                  #  - must explicitly call M.Run() to run other Test*(), i.e. allow beforeAll logic
                                  #  - must explicitly call os.Exit(EXIT_CODE_INT), i.e. allow afterAll logic
M.Run()->EXIT_CODE_INT            #

T.Run("NAME2", FUNC(*T))->BOOL    #Runs a sub-test, for nesting|grouping tests.
                                  #Done in a goroutine.
                                  #Blocks until complete (unless parallel)
                                  #BOOL is whether failed
                                  #  - if parallel, until T.Parallel() was called
                                  #With -run|bench, sub-test name is PARENT_NAME/NAME2
                                  #  - running only a specific sub-test also runs its parent once


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           EXAMPLES            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Example[VARR][_SUFFIX]()          #Example function
                                  #Can become a test function (instead of documenting) by adding a comment asserting stdout equals a specific STR
                                  #Documented by godoc:
                                  #  - VARR should be exported variable name, _-separated
                                  #     - empty if whole package
                                  #  - appears next to VARR documentation
                                  #  - can append any SUFFIX
                                  #  - if only one Example function, and there are some package scope declaration, the whole
                                  #    file is shown, not only function
                                  #     - i.e. full file example
                                  #     - by convention, called FILE_example.go
// Output: [...]                  #... is expected stdout
                                  #Can be multiline, omitting "Output:"
// Unordered output: [...]        #Same but line order is not significant


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           BENCHMARK           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go test
-bench REGEXP                     #Only run benchmarks whose "BenchmarkNAME" partially matches REGEXP
                                  #"" means ".*"
                                  #Unless set, no benchmarks is run
-benchtime DURATION               #How long to run benchmark (def: "1s")
-count NUM                        #How many times to repeat benchmarks (def: 1)

BenchmarkNAME(*testing.B)         #Benchmark function
                                  #Prints GOOS, GOARCH, MODULE_PATH, NAME
                                  #Runs for one minute then prints:
                                  #  - number of iterations
                                  #  - average iteration speed
                                  #  - number of goroutines
                                  #Can also use test assertions, and behave like a test function

testing.B                         #Benchmark utilities

B.*                               #All T.* are available
                                  #  - exception: logs are always printed
testing.TB                        #INTERFACE with methods common to T and B

B.N                               #Max iteration INT to run in loops
                                  #For example: for i := 0; i < b.N; i++ {...}

B.ResetTimer()                    #To do after setup code, so the setup does not add to the benchmark
B.StopTimer()                     #Pause timer
B.StartTimer()                    #Re-start timer

B.ReportAllocs()                  #Like -test.benchmem, but only for this function

B.SetBytes(INT64)                 #Report that the current test read or write INT64 bytes by current iteration, to benchmark I/O
                                  #This will be printed as MB/s in the test output.
B.ReportMetric(FLOAT64, "UNIT")   #Report "FLOAT64 UNIT" in test output
                                  #Must be called only once per FUNC
                                  #Goal is to do own measuring and report it
                                  #If "UNIT" is already reported by go test, override it

B.SetParallelism(INT)             #Increase the number of max goroutines to INT * GOMAXPROCS
B.RunParallel(FUNC(*PB))          #Creates GOMAXPROCS goroutines and run all goroutines in parallel.
                                  #I.e. benchmarks in parallel instead of serially
                                  #Blocks until complete
PB.Next()->BOOL                   #Mark start of a new iteration
                                  #Returns false if last iteration.
                                  #To use in: for PB.Next() {...}

testing.Benchmark
 (FUNC(*testing.B))
 ->BENCHMARK_RESULT               #Run a benchmark manually without go test
testing.Init()                    #To call inside manual Benchmark FUNC() if want to allow using test CLI flags, or retrieve their value
                                  #without using go test
BENCHMARK_RESULT.N                #Like B.N
BENCHMARK_RESULT.T                #Time.DURATION taken
BENCHMARK_RESULT.NsPerOp()->INT64 #Ns per iteration
BENCHMARK_RESULT.Bytes            #INT64. Average bytes per iteration, set by B.SetBytes()
BENCHMARK_RESULT.Extra            #MAP[STR]FLOAT64 of metrics through B.ReportMetric()
BENCHMARK_RESULT.String()->STR    #"{N} [NUM ns/op] [NUM MB/s] [METRIC UNIT]..."


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           COVERAGE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go test
-cover                            #Enables test coverage
                                  #Instrument source code to add counting statements to do it.
                                  #Only instruments in-between lines, i.e. does not separate single-line statements like FUNC() && FUNC2()
                                  #Show summary test coverage percentage in output.
-coverpkg IMPORT_PATHS            #Limit test coverage to those PACKAGEs (def: all)
-covermode STR                    #How lines are counted in test coverage:
                                  #  - "set" (def): only keeps track on wheter line was hit
                                  #  - "count": also keeps track of how many times line was hit
                                  #  - "atomic" (def if -race): like "count" but works in parallel tests. Slower
                                  #Implies -cover
-coverprofile PATH.out            #Write test coverage file

testing.CoverMode()->STR          #Returns "" if -cover not set
testing.Coverage()->FLOAT64       #Current coverage percentage. 0 if -cover not set

PATH.out                          #First line is:
                                  #  mode: set|count|atomic
                                  #Then each line describes a block|FUNC branch:
                                  #  MODULE_PATH/FILENAME.go:START_LINE.START_COL,END_LINE.END_COL NUM NUM2
                                  #    NUM is number of statements
                                  #    NUM2 is number of hits (max 1 if mode "set")

go tool cover                     #Report detailed test coverage from PATH.out
-func PATH.out                    #Report as text
-html PATH.out                    #Report as HTML
-o PATH                           #Def: stdout with -func, opening browser with -html

go tool cover -mode=STR FILE.go   #Instruments source code
                                  #Used by go test -cover, i.e. useful for debugging
                                  #STR is -covermode
-var VAR                          #Instrumentation variable name (def: "GoCover")


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       MEMORY PROFILING        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


runtime.ReadMemStats(*MEM_STATS)  #Returns memory usage statistics since beginning of process

MEM_STATS.Sys UINT64              #Total memory available
                                  #Sum of HeapSys + StackSys + MSpanSys + MCacheSys + BuckHashSys + GCSys + OtherSys

MEM_STATS.HeapSys UINT64          #Heap memory max available
MEM_STATS.HeapInuse UINT64        #Heap memory used.
                                  #Heap memory is divided in pre-allocated spans, which are bigger than the objects they allocate.
                                  #This measures memory spans, not only heap objects, i.e. >= HeapAlloc
MEM_STATS.HeapIdle UINT64         #HeapSys - HeapInUse
MEM_STATS.HeapReleased UINT64     #Like HeapIdle, but also removes heap memory that is not used,
                                  #but reserved to speed up future memory allocations.
MEM_STATS.[Heap]Alloc UINT64      #Heap memory used by heap objects.
                                  #Includes reachable variables + unreacheable variables not GC'd yet
MEM_STATS.TotalAlloc UINT64       #Like HeapAlloc, but does not decrease when memory freed, i.e. cumulative

MEM_STATS.HeapObjects UINT64      #Number of objects allocated on the heap
MEM_STATS.Mallocs UINT64          #Like HeapObjects, but cumulative, i.e. HeapObjects + Frees
MEM_STATS.Frees UINT64            #Number of objects previously allocated on the heap, but now freed

MEM_STATS.BySize []STRUCT         #List of memory spans.
                                  #STRUCT:
                                  #  - Size UINT32: in bytes
                                  #  - Mallocs UINT64: number of memory spans of that Size, cumulative (allocated or freed)
                                  #  - Frees UINT64: number of memory spans of that Size that got freed
                                  #Each STRUCT has its own Size, which increases exponentially.
                                  #   - i.e. uses different memory spans size to prevent fragmentation
                                  #Sum of each STRUCT Size * (Mallocs - Frees) == HeapInUse

MEM_STATS.StackSys|Inuse UINT64   #Stack memory max available | used
MEM_STATS.MSpanSys|Inuse UINT64   #MSpan memory max available | used
MEM_STATS.MCacheSys|Inuse UINT64  #MCache memory max available | used
MEM_STATS.BuckHashSys UINT64      #Memory reserved by memory profiling
MEM_STATS.GCSys UINT64            #Memory reserved by GC
MEM_STATS.OtherSys UINT64         #Memory reserved for other things

MEM_STATS.Lookups UINT64          #Number of time a POINTER was deferenced

testing.AllocsPerRun(INT, FUNC()) #Runs FUNC() INT times, and returns + prints the average number of objects allocated on the heap per call.
 ->FLOAT64                        #Do it by using runtime.ReadMemStats() MEM_STATS.Mallocs

go test -benchmem                 #Prints B/op and allocs/op (like BENCHMARK_RESULT.MemString()) in benchmarks output

BENCHMARK_RESULT.MemBytes         #INT64. Memory used, like MEM_STATS.TotalAlloc, but also includes stack, etc.
BENCHMARK_RESULT.
 AllocedBytesPerOp()->INT64       #MemBytes / N
BENCHMARK_RESULT.MemAllocs        #UINT64. Total number of objects allocated on the heap, like MEM_STATS.Mallocs
BENCHMARK_RESULT.AllocsPerOp()
 ->UINT64                         #MemAllocs / N
BENCHMARK_RESULT.MemString()->STR #"{AllocedBytesPerOp()} B/op {AllocsPerOp()} allocs/op"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       GARBAGE COLLECTOR       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GC ==>                            #Mark-and-sweep.
                                  #Sweeping happens both incrementally and during stop-the-world events (STW)
                                  #STW are triggered when HeapInUse reaches a changing specific heap size threshold
                                  #STW are broken down into several "pauses".

runtime.GC()                      #Force running a GC stop-the-world

MEM_STATS.NextGC UINT64           #Next GC threshold to trigger STW
MEM_STATS.NumGC UINT32            #Number of GC STWs
MEM_STATS.NumForcedGC UINT32      #Number of runtime.GC() calls
MEM_STATS.PauseTotalNs UINT64     #Number of ns spent in all GC STWs
MEM_STATS.PauseNs [256]UINT_64    #Time spent in each of the last 256 GC pauses. If none, 0.
MEM_STATS.GCCPUFraction FLOAT64   #How much % of CPU time was spent in GC
MEM_STATS.LastGC UINT64           #Last GC's Unix timestamp (in ns). If none, 0.
MEM_STATS.PauseEnd [256]UINT_64   #Unix timestamp (in ns) of the last 256 GC pauses. If none, 0.

MEM_STATS.EnableGC BOOL           #Whether GC is enabled (def: true)
MEM_STATS.DebugGC BOOL            #Always false


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CPU PROFILING         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


gofmt|go test -cpuprofile FILE    #Does CPU profiling and outputs it in FILE
                                  #CPU profiling shows duration spent in each function, as a call tree
                                  #Do it by using random samples, recording at regular interval which source line was hit
                                  #  - including parents
                                  #     - whole function stack is a "node", composed of several "frames"
                                  #  - instrument each source line to know this

import "runtime/pprof"            #
pprof.StartCPUProfile(WRITER)
 ->ERROR|nil                      #Starts CPU profiling
pprof.StopCPUProfile()            #Stops CPU profiling, and write output to WRITER

go tool pprof [FORMAT] [BIN] FILE #Inspect a CPU profiling FILE
                                  #BIN is the binary that produced the profiling FILE, to find out source code
                                  #  - automatically guessed
                                  #Def FORMAT: interactive mode

-http=HOST:PORT                   #Visualize all information, in browser
-kcachegrind                      #Visualize all information, in kcachegrind program

-web                              #Visualize graph through web browser
-evince                           #Visualize graph through evince program
-eog                              #Visualize graph through eog program
-gv                               #Visualize graph through gv program

-output=FILE                      #Where to output file
-svg                              #Output graph as SVG
-png                              #Output graph as PNG
-pdf                              #Output graph as PDF
-ps                               #Output graph as PostScript
-gif                              #Output graph as GIF
-dot                              #Output as DOT graph
-callgrind                        #Outputs in callgrind format
-proto                            #Output as protobuf

-list=REGEXP                      #Prints source code of functions whose name match REGEXP, with duration of each line in left margin
-weblist                          #Same but visualized in browser

-tree                             #Print all functions with:
                                  #  - both CPU duration, and number of samples|calls
                                  #  - both absolute and percentage
                                  #  - both including|excluding children ("cum|flat")
-peek=REGEXP                      #Same as -tree but only functions whose name match REGEXP
-text|-top                        #Like -tree but for the top entries
-topproto                         #Like -top but as protobuf

-traces                           #Prints list of samples:
                                  #  - time duration
                                  #  - which line of code was hit
-raw                              #Prints list of samples:
                                  #  - number of same samples
                                  #  - time interval
                                  #  - which line of code was hit

-comments                         #Print profile comments
-tags                             #Print profile tags

-nodecount=NUM                    #Only show top NUM nodes

-show|hide=REGEXP                 #Show|hide frames matching regexp
                                  #Parent|children frames are still shown (unless those are all hidden)
-focus|ignore=REGEXP              #Same but for nodes, i.e. also show|hide frames
-show_from|prune_from=REGEXP      #Like -hide but for all frames above|below functions matching REGEXP
-noinlines                        #Like -hide but for functions inlined by compiler

-unit=UNIT                        #CPU duration unit among: year|month|day|second|millisecond|microsecond|nanosecond
                                  #Def: millisecond
-divide_by=NUM                    #Divide all CPU durations by NUM

  Options:
    -trim            Honor nodefraction/edgefraction/nodecount defaults
    -edgefraction    Hide edges below <f>*total
    -nodefraction    Hide nodes below <f>*total

    -call_tree       Create a context-sensitive call tree
    -compact_labels  Show minimal headers
    -drop_negative   Ignore negative differences
    -mean            Average sample value over first value (count)
    -normalize       Scales profile based on the base profile.
    -relative_percentages Show percentages relative to focused subgraph
    -sample_index    Sample value to report (0-based index or name)
    -source_path     Search path for source files
    -tagfocus        Restricts to samples with tags in range or matched by regexp
    -taghide         Skip tags matching this regexp
    -tagignore       Discard samples with tags in range or matched by regexp
    -tagshow         Only consider tags matching this regexp
    -trim_path       Path to trim from source paths before search

  Option groups (only set one per group):
    cumulative
      -cum             Sort entries based on cumulative weight
      -flat            Sort entries based on own weight
    granularity
      -addresses       Aggregate at the address level.
      -filefunctions   Aggregate at the function level.
      -files           Aggregate at the file level.
      -functions       Aggregate at the function level.
      -lines           Aggregate at the source code line level.

  Source options:
    -seconds              Duration for time-based profile collection
    -timeout              Timeout in seconds for profile collection
    -buildid              Override build id for main binary
    -add_comment          Free-form annotation to add to the profile
                          Displayed on some reports or with pprof -comments
    -diff_base source     Source of base profile for comparison
    -base source          Source of base profile for profile subtraction
    profile.pb.gz         Profile in compressed protobuf format
    legacy_profile        Profile in legacy pprof format
    http://host/profile   URL for profile handler to retrieve
    -symbolize=           Controls source of symbol information
      none                  Do not attempt symbolization
      local                 Examine only local binaries
      fastlocal             Only get function names from local binaries
      remote                Do not examine local binaries
      force                 Force re-symbolization
    Binary                  Local path or build id of binary for symbolization
    -tls_cert             TLS client certificate file for fetching profile and symbols
    -tls_key              TLS private key file for fetching profile and symbols
    -tls_ca               TLS CA certs file for fetching profile and symbols

  Misc options:
   -http              Provide web interface at host:port.
                      Host is optional and 'localhost' by default.
                      Port is optional and a randomly available port by default.
   -no_browser        Skip opening a browser for the interactive web UI.
   -tools             Search path for object tools

  Legacy convenience options:
   -inuse_space           Same as -sample_index=inuse_space
   -inuse_objects         Same as -sample_index=inuse_objects
   -alloc_space           Same as -sample_index=alloc_space
   -alloc_objects         Same as -sample_index=alloc_objects
   -total_delay           Same as -sample_index=delay
   -contentions           Same as -sample_index=contentions
   -mean_delay            Same as -mean -sample_index=delay

  Environment Variables:
   PPROF_TMPDIR       Location for saved profiles (default $HOME/pprof)
   PPROF_TOOLS        Search path for object-level tools
   PPROF_BINARY_PATH  Search path for local binary files
                      default: $HOME/pprof/binaries
                      searches $name, $path, $buildid/$name, $path/$buildid
   * On Windows, %USERPROFILE% is used instead of $HOME
