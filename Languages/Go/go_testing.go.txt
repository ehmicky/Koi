
              
   GO_TESTING  
              



VERSION ==>                       #See Go language

DOCUMENTED ELSEWHERE ==>          #In go debugging:
                                  #  - go test profiling|tracing CLI flags
                                  #  - testing.AllocsPerRun()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GO TEST            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go test [IMPORT_PATHS] [ARG...]   #Runs:
                                  #  - go vet
                                  #  - go build, but including also *_test.go
                                  #  - executes resulting TEST_BINARY
                                  #  - prints test summary
                                  #     - to stdout (redirects any stderr to stdout instead)
                                  #ARG... are passed to TEST_BINARY
                                  #  - any go test flag can be set after IMPORT_PATHS too, so should not be any conflicts
                                  #     - to distinguish, can prepend -args to ARG...
                                  #TEST_BINARY includes the source BINARY
                                  #If IMPORT_PATHS is omitted:
                                  #  - current PACKAGE
                                  #  - no caching
                                  #  - imply -v
                                  #Executing TEST_BINARY is cached
                                  #  - if files or CLI flags changed, not cached
                                  #  - convention to disable caching: using -count=1
-test.FLAG                        #Under the hood, CLI flags are passed to TEST_BINARY as --test.*
                                  #They can be specified to go test either as -* or as -test.*
-vet=RULE,...                     #Which go vet RULEs are run.
                                  #Can be "off"
                                  #Def: only bools|stringintconv|nilfunc|ifaceassert|atomic|printf|buildtag
-c                                #Do not execute TEST_BINARY
-o PATH                           #TEST_BINARY's location.
                                  #Def: BINARY.test
-json                             #Prints test results as JSON
-ANY_GO_RUN_FLAG                  #Note: -i implied -c

-list REGEXP                      #Prints all exported functions whose name partially match REGEXP

-v                                #Verbose. Force printing logs from all tests
T.Verbose()->BOOL                 #

-cpu NUM                          #Set GOMAXPROCS


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           TEST2JSON           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go test -OPT... |                 #Make go test output JSON stream instead.
 go tool test2json                #Includes verbose information:
                                  #  - test start|pass|fail
                                  #  - test pause|continue
                                  #  - test skip
                                  #  - test output|benchmark
go tool test2json TEST_BINARY
 -test.OPT...                     #Same
-t                                #Adds OBJ.Time 'TIMESTAMP' to each OBJ
-p PACKAGE                        #Adds OBJ.Package 'PACKAGE' to each OBJ


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          TEST FILES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TEST FILES ==>                    #Must export Test*|Example*|Benchmark*()
                                  #Each FUNC is run in its own goroutine

import "testing"                  #

testdata/**                       #Always ignored, i.e. good for fixtures


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        TEST FUNCTIONS         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go test
-run REGEXP                       #Only run tests whose "TestNAME" partially matches REGEXP
                                  #"" means ".*"
-failfast                         #Stops on first test failure
-timeout DURATION                 #Def: "10m"

TestNAME(*testing.T)              #Test function
                                  #If any test assertion fails, exit code 1

testing.T                         #Test function utilities
T.Fail()                          #Mark test as failed. Keep current FUNC|goroutine going.
T.Failed()->BOOL                  #
T.FailNow()                       #Run T.Fail(), then exit current FUNC|goroutine (not others)

T.SkipNow()                       #Mark test as skipped, then exit current FUNC|goroutine (not others)
T.Skipped()->BOOL                 #

go test -short                    #
testing.Short()->BOOL             #Returns whether -short CLI flag is set
                                  #To use in long tests, to T.Skip() them when that flag is set

T.Log[f](...)                     #Similar to fmt.Println|Printf(...) except more test-friendly:
                                  #  - only printed on test failure or if -v CLI flag
T.Error[f](...)                   #Run T.Log[f](...) then t.Fail()
T.Fatal[f](...)                   #Run T.Log[f](...) then t.FailNow()
T.Skip[f](...)                    #Run T.Log[f](...) then t.SkipNow()

T.Name()->"TestNAME"              #

T.Helper()                        #Make function as test helper, i.e. file|line information not printed


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         TESTING QUICK         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


import "testing/quick"            #Data-driven testing with random inputs

quick.Check
 (FUNC(VAL...)->BOOL, *CONFIG)    #Runs FUNC(VAL...) with random inputs many times.
 ->ERROR|nil                      #Returns ERROR if any BOOL was false
quick.CheckError                  #quick.Check()'s ERROR type
CHECK_ERROR.Count                 #NUM of arguments that passed before failing
CHECK_ERROR.In                    #[]VAL arguments that failed

quick.CheckEqual
 (FUNC(VAL...)->VAL2,
 FUNC2(VAL3...)->VAL4, *CONFIG)
 ->ERROR|nil                      #Same but calling two functions and checking that their return values are equal
quick.CheckEqualError             #
CHECK_EQUAL_ERROR.Out1|Out2       #[]VAL arguments that failed in FUNC|FUNC2

quick.SetupError                  #ERROR type when quick.Check[Equal]() are called with wrong arguments

quick.Config                      #Options
CONFIG.Rand                       #*rand.RAND. Randomness source (def: rand.NewSource() using current time-ns as seed)

go test -quickchecks FLOAT64      #Number of iterations (def: 100)
CONFIG.MaxCount                   #INT. Set number of iterations to a specific number.
CONFIG.MaxCountScale              #FLOAT64. Multiply number of iterations by FLOAT64

quick.Value
 (reflect.TYPE, *rand.RAND)
 ->reflect.VALUE,OK               #Low-level API used by quick.Check[Equal] to retrieve a random value from a specific type
quick.Generator                   #INTERFACE to apply on any reflect.TYPE in order to customize quick.Value()
GENERATOR.Generate
 (*rand.RAND, INT)->reflect.VALUE #INT is size hint (always 50)
CONFIG.Values
 ([]reflect.VALUE, *rand.RAND)    #Customize how random values are generated


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      TEST ORCHESTRATION       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go test -parallel NUM             #Maximum of parallel tests at once (def: GOMAXPROCS)
T.Parallel()                      #Mark as parallel test, i.e. run in parallel with other parallel tests
                                  #Noop unless -parallel CLI flag

T.Cleanup(FUNC())                 #Run FUNC() when test exits.
                                  #Last added is called first.

TestMain(*testing.M)              #When defined:
                                  #  - must explicitly call M.Run() to run other Test*(), i.e. allow beforeAll logic
                                  #  - must explicitly call os.Exit(EXIT_CODE_INT), i.e. allow afterAll logic
M.Run()->EXIT_CODE_INT            #

T.Run("NAME2", FUNC(*T))->BOOL    #Runs a sub-test, for nesting|grouping tests.
                                  #Done in a goroutine.
                                  #Blocks until complete (unless parallel)
                                  #BOOL is whether failed
                                  #  - if parallel, until T.Parallel() was called
                                  #With -run|bench, sub-test name is PARENT_NAME/NAME2
                                  #  - running only a specific sub-test also runs its parent once


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           EXAMPLES            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Example[VARR][_SUFFIX]()          #Example function
                                  #Can become a test function (instead of documenting) by adding a comment asserting stdout equals a specific STR
                                  #Documented by godoc:
                                  #  - VARR should be exported variable name, _-separated
                                  #     - empty if whole package
                                  #  - appears next to VARR documentation
                                  #  - can append any SUFFIX
                                  #  - if only one Example function, and there are some package scope declaration, the whole
                                  #    file is shown, not only function
                                  #     - i.e. full file example
                                  #     - by convention, called FILE_example.go
// Output: [...]                  #... is expected stdout
                                  #Can be multiline, omitting "Output:"
// Unordered output: [...]        #Same but line order is not significant


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           BENCHMARK           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go test
-bench REGEXP                     #Only run benchmarks whose "BenchmarkNAME" partially matches REGEXP
                                  #"" means ".*"
                                  #Unless set, no benchmarks is run
-benchtime DURATION               #How long to run benchmark (def: "1s")
-count NUM                        #How many times to repeat benchmarks (def: 1)

BenchmarkNAME(*testing.B)         #Benchmark function
                                  #Prints GOOS, GOARCH, MODULE_PATH, NAME
                                  #Runs for one minute then prints:
                                  #  - number of iterations
                                  #  - average iteration speed
                                  #  - number of goroutines
                                  #Can also use test assertions, and behave like a test function

testing.B                         #Benchmark utilities

B.*                               #All T.* are available
                                  #  - exception: logs are always printed
testing.TB                        #INTERFACE with methods common to T and B

B.N                               #Max iteration INT to run in loops
                                  #For example: for i := 0; i < b.N; i++ {...}

B.ResetTimer()                    #To do after setup code, so the setup does not add to the benchmark
B.StopTimer()                     #Pause timer
B.StartTimer()                    #Re-start timer

B.ReportAllocs()                  #Like -test.benchmem, but only for this function

B.SetBytes(INT64)                 #Report that the current test read or write INT64 bytes by current iteration, to benchmark I/O
                                  #This will be printed as MB/s in the test output.
B.ReportMetric(FLOAT64, "UNIT")   #Report "FLOAT64 UNIT" in test output
                                  #Must be called only once per FUNC
                                  #Goal is to do own measuring and report it
                                  #If "UNIT" is already reported by go test, override it

B.SetParallelism(INT)             #Increase the number of max goroutines to INT * GOMAXPROCS
B.RunParallel(FUNC(*PB))          #Creates GOMAXPROCS goroutines and run all goroutines in parallel.
                                  #I.e. benchmarks in parallel instead of serially
                                  #Blocks until complete
PB.Next()->BOOL                   #Mark start of a new iteration
                                  #Returns false if last iteration.
                                  #To use in: for PB.Next() {...}

testing.Benchmark
 (FUNC(*testing.B))
 ->BENCHMARK_RESULT               #Run a benchmark manually without go test
testing.Init()                    #To call inside manual Benchmark FUNC() if want to allow using test CLI flags, or retrieve their value
                                  #without using go test
BENCHMARK_RESULT.N                #Like B.N
BENCHMARK_RESULT.T                #Time.DURATION taken
BENCHMARK_RESULT.NsPerOp()->INT64 #Ns per iteration
BENCHMARK_RESULT.Bytes            #INT64. Average bytes per iteration, set by B.SetBytes()
BENCHMARK_RESULT.Extra            #MAP[STR]FLOAT64 of metrics through B.ReportMetric()
BENCHMARK_RESULT.String()->STR    #"{N} [NUM ns/op] [NUM MB/s] [METRIC UNIT]..."


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           COVERAGE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go test
-cover                            #Enables test coverage
                                  #Instrument source code to add counting statements to do it.
                                  #Only instruments in-between lines, i.e. does not separate single-line statements like FUNC() && FUNC2()
                                  #Show summary test coverage percentage in output.
-coverpkg IMPORT_PATHS            #Limit test coverage to those PACKAGEs (def: all)
-covermode STR                    #How lines are counted in test coverage:
                                  #  - "set" (def): only keeps track on wheter line was hit
                                  #  - "count": also keeps track of how many times line was hit
                                  #  - "atomic" (def if -race): like "count" but works in parallel tests. Slower
                                  #Implies -cover
-coverprofile PATH.out            #Write test coverage file

testing.CoverMode()->STR          #Returns "" if -cover not set
testing.Coverage()->FLOAT64       #Current coverage percentage. 0 if -cover not set

PATH.out                          #First line is:
                                  #  mode: set|count|atomic
                                  #Then each line describes a block|FUNC branch:
                                  #  MODULE_PATH/FILENAME.go:START_LINE.START_COL,END_LINE.END_COL NUM NUM2
                                  #    NUM is number of statements
                                  #    NUM2 is number of hits (max 1 if mode "set")

go tool cover                     #Report detailed test coverage from PATH.out
-func PATH.out                    #Report as text
-html PATH.out                    #Report as HTML
-o PATH                           #Def: stdout with -func, opening browser with -html

go tool cover -mode=STR FILE.go   #Instruments source code
                                  #Used by go test -cover, i.e. useful for debugging
                                  #STR is -covermode
-var VAR                          #Instrumentation variable name (def: "GoCover")
