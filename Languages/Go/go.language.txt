
      
   GO  
      



TODO:
  - https://golang.org/ref/spec#Declarations_and_scope
  - go back to https://golang.org/doc/effective_go.html#control-structures
  - https://golang.org/ref/mem
  - https://golang.org/doc/faq
  - https://golang.org/doc/diagnostics.html
  - https://blog.golang.org
  - https://github.com/golang/go/wiki
  - https://golang.org/doc/cmd
     - all go CMD
     - all go* executable
  - https://golang.org/pkg/
  - https://github.com/golang?type=source
  - go through to_learn.txt

VERSION ==>                       #1.14.4


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             BUILD             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ENVVAR GOROOT                     #Global go directory.
                                  #Contains go|gofmt executable
                                  #Def: /usr/local/go

go build FILE.go                  #Compile FILE.go to executable FILE
go build [DIR]                    #Compile DIR/*.go to executable DIRNAME
                                  #Must all be from same PACKAGE
                                  #Def DIR: .


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              ENV              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go env                            #Prints all GO*|CGO* ENVVARs, and also GCC-related ENVVARs
                                  #After default value resolution
go env "ENVVAR",...               #Print value
go env -w ENVVAR=VAL,...          #Sets value
go env -u ENVVAR                  #Unsets value

-json                             #Prints as JSON

ENVVAR GOENV                      #Where go env -w|-u ... is stored
                                  #Def: ~/.config/go/env


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            MODULE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


MODULE ==>                        #Group of PACKAGEs

"[NAMESPACE/]MODULE"              #"MODULE_PATH", identifier of the MODULE
                                  #NAMESPACE is location among:
                                  #  - standard library STR or ""
                                  #  - PATH, relative to:
                                  #     - $PWD[/...]
                                  #     - $GOROOT/src
                                  #     - $GOPATH/src
                                  #  - URI

go.mod                            #File containing line-wise directives (below)
                                  #Location determines the module's root directory:
                                  #  - any subdirectory's PACKAGE is included
                                  #  - subdirectory with another go.mod are excluded
//COMMENT                         #
module MODULE_PATH                #Declares MODULE_PATH
go VERSION                        #Declares Go version

go mod init "MODULE_PATH"         #Creates ./go.mod

go install ["MODULE_PATH"|DIR]    #Downloads MODULE and installs as binary in GOBIN
                                  #If DIR (def: '.'), searches in DIR
GOBIN                             #By priority:
                                  #  - ENVVAR GOBIN
                                  #  - FIRST_GO_PATH/bin, where FIRST_GO_PATH is ENVVAR GOPATH's first path
                                  #  - HOME/go/bin/MODULE
                                  #     - HOME is $HOME on Unix, %USERPROFILE% on Windows


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PACKAGE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


package PACKAGE                   #Declare which PACKAGE it belongs
                                  #Must be first statement
                                  #All *.go within same DIR must have same PACKAGE
                                  #Recommended lowercase

package main                      #CLI entry point (as opposed to programmatic)
                                  #Must have a main FUNC

"MODULE_PATH[/PATH]"              #"IMPORT_PATH", identifier of a PACKAGE

EXPORT ==>                        #Any top-level variable whose variable name starts with uppercase is exported
                                  #Recommended not to namespace their variable name, since PACKAGE already namespaces them

import "IMPORT_PATH"              #Import PACKAGE as a top-level variable named PACKAGE
                                  #Must be available in GOBIN
import (
  "..."
  ...
)                                 #Same as several import "..."


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GENERIC            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SOURCE CODE ENCODING ==>          #UTF-8, non-canonicalized

TOKEN TYPES ==>                   #  - identifier: VAR|TYPE, pre-defined FUNC, true|false|iota|nil
                                  #  - keyword: return|if|package|const|...
                                  #  - operator|punctuation: + & ; . <<= () [] {} ...
                                  #  - literals: INT|FLOAT|COMPLEX '...' "..."

WHITESPACES ==>                   #\t \r \n or space. Separate tokens. Ignored otherwise

EXPR[;]                           #; can be a newline instead (recommended) when line ends with:
                                  #  - VAR
                                  #  - NUM|STR|RUNE
                                  #  - ) ] } ++ --
                                  #  - return|break|continue|fallthrough
                                  #I.e. most of the time

(VAL)                             #Parenthesis can be used to override operator precedence

// COMMENT
/* COMMENT */                     #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             LOOPS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/



if [EXPR;] BOOL_EXPR { ... }
 [else if [EXPR;] BOOL_EXPR {...}]
 ...
 [else { ... }]                   #

switch [EXPR;] [EXPR2] {
  [case EXPR3:
    ...]...                       #Execute first case where EXPR2 == EXPR3
  [default:                       #EXPR2 defaults to true
    ...]                          #Cases are indentation-based
}                                 #No break needed, each case does not follow through next one

for [EXPR]; [BOOL_EXPR]; [EXPR2]  #For loop
 { ... }                          #BOOL_EXPR defaults to true

for [BOOL_EXPR] { ... }           #Same as for ; [BOOL_EXPR]; { ... }
                                  #I.e. while loop

for KEY_VAR[, VAL_VAR2]           #Iterates
  := range ARR|SLICE { ... }      #VAL is copy|reference depending on TYPE (like in any FUNC() return value)
for ... = range ...               #Same but with already declared KEY_VAR, VAL_VAR



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             TYPE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NESTING ==>                       #All non-simple types can be nested: **TYPE, [][]TYPE, map[TYPE]map[TYPE2]TYPE3, etc.,
                                  #including mixed

INLINE INFERING ==>               #When inlining nested TYPE, nested TYPE2 can be omitted.
                                  #For example [][]TYPE{[]TYPE{}, []TYPE{}} -> [][]TYPE{{}, {}}

VALUE-LIKE VS POINTER-LIKE ==>    #Types are either:
                                  #  - value-like: BOOL|INT|FLOAT|COMPLEX|STRUCT|ARR
                                  #     - zero-value: type-specific actual value
                                  #        - for composite types (STRUCT|ARR): empty, and recursive zero-value
                                  #     - passed|returned to|from FUNC by deep copy
                                  #        - including range return value
                                  #  - pointer-like: *TYPE|FUNC|INTERFACE|MAP|SLICE|CHAN
                                  #     - zero-value: nil
                                  #     - passed|returned to|from FUNC by reference
                                  #        - actually by copy, but since they copy the underlying pointer, behaves like reference

SIMPLE VS COMPOSITE ==>           #Simple types: BOOL, INT|FLOAT|COMPLEX, RUNE|STR
                                  #Composite types: *TYPE, FUNC, INTERFACE|STRUCT|MAP|ARRAY|SLICE, CHAN

type TYPE = TYPE2
type (TYPE = TYPE2;...)           #Type alias
type TYPE TYPE2
type (TYPE TYPE2;...)             #Type definition

UNDERLYING TYPE ==>               #TYPE after type resolution.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           TRANSTYPE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TYPE IDENTITY ==>                 #Identical TYPEs do not require transtyping.
                                  #Identical if:
                                  #  - deeply equal TYPE, either simple|composite
                                  #  - type alias
                                  #Not identical if:
                                  #  - type definition
                                  #Must be exact same:
                                  #  - including:
                                  #     - FUNC number|type of arguments|return values
                                  #     - STRUCT number|name|types|tags of properties
                                  #     - STRUCT order of properties
                                  #     - ARR size
                                  #  - excluding:
                                  #     - FUNC parameter|return VAR names
                                  #     - FUNC receiver
                                  #     - INTERFACE order of properties

IMPLICIT TRANSTYPE ==>            #Always allowed for identical TYPEs.
                                  #For type definition (type TYPE TYPE2):
                                  #  - TYPE inherits transtypes from TYPE2
                                  #  - If TYPE2:
                                  #     - type name: cannot transtype TYPE <-> TYPE2
                                  #        - but if builtin simple type name: can transtype to untyped constant, with underlying TYPE2
                                  #     - literal|composite: can transtype TYPE <-> TYPE2
                                  #Example:
                                  #  type A int   // A </>     int   A <=>     5
                                  #  type B   A   // B </>   A|int   B <=>   int
                                  #  type C []A   // C </>   []int   C <=>   []A
                                  #  type D   C   // D </> C|[]int   D <=>   []A

TYPE(VAL)                         #Explicit transtype.
                                  #The only ones allowed are the following.
TYPE -> TYPE2                     #When used type definition (using type names)
                                  #  - exception: TYPE cannot be builtin composite types
NUM -> other NUM                  #Only if can perfectly convert, i.e. not if:
                                  #  - negative NUM -> UINT
                                  #  - too high NUM -> smaller NUM
                                  #  - FLOAT with decimal -> [U]INT
                                  #  - COMPLEX with imaginary part -> [U]INT|FLOAT
UINT32 -> STR                     #Using Unicode codepoint
CHAN -> other CHAN                #Only if does not lose receiver|sender direction.
                                  #E.g. CHAN to CHAN<-, CHAN to <-CHAN, but not inverse.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             BOOL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


bool                              #TYPE
                                  #Zero value is false

true|false                        #BOOL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            INTEGER            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[u]int8|16|32|64                  #TYPE with 8|16|32|64 bits
                                  #Zero value is 0 (same for others)
[u]int                            #TYPE with 32|64 bits depending on OS
byte                              #Alias for uint8, meant for binary data

N...                              #[U]INT
0bN...
0BN...
0oN...
0ON...
0xN...
0XN...                            #2|8|16 bases



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             FLOAT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


float32|64                        #TYPE with 32|64 bits
                                  #Zero value is 0

[N...][.N...][e|E+|-N...]         #FLOAT
0x[N...][.N...][p|P+|-N...]
0X[N...][.N...][p|P+|-N...]       #Base 16


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            COMPLEX            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


complex64|128                     #TYPE for complex numbers, with 64|128 bits
                                  #Zero value is 0

INT|FLOATi
INT|FLOAT2 [+|- INT|FLOATi]       #COMPLEX


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            NUMBER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NUM                               #[U]INT|FLOAT|COMPLEX|RUNE|UINTPTR

-NUM                              #Negative

UNDERSCORES ==>                   #Can appear to separate digits. Non-significant.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             RUNE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


rune                              #TYPE. Single Unicode codepoint.
                                  #Alias for int32, i.e. manipulated like integer codepoint.
                                  #Cannot represent above \u10ffff, or \ud800-\udfff
                                  #Zero-value is '\000'

'...'                             #RUNE
                                  #Can contain Unicode characters as is, except unescaped '
                                  #Single-line (no newline)
                                  #Can also contain escape sequences:
                                  #  - \a \b \f \n \r \t
                                  #  - \XXX (base 8)
                                  #  - \xXX (base 16)
                                  #  - \uXXXX \UXXXXXXXX (Unicode codepoint)
                                  #  - \\ \'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STRING             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


string                            #TYPE
                                  #Zero-value is ""
                                  #Immutable: STR operations create a new STR2

"..."                             #STR
                                  #Can contain Unicode characters, except unescaped "
                                  #Single-line (no newline)
                                  #Contain same escape sequences as RUNE
`...`                             #STR
                                  #Can contain Unicode characters, except `
                                  #Multi-line (can include newline)
                                  #  - raw \r are discarded
                                  #Cannot contain escape sequences (\ has no special meaning)

STR[UINT]                         #Get RUNE
                                  #Cannot set

len(STR)->UINT                    #Size, in byte (not character)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            POINTER            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


*TYPE                             #TYPE2. Pointer of a TYPE.
                                  #Used to pass a STRUCT|ARR by reference instead of value
                                  #Lower operator priority than [UINT] or .VAR

nil                               #Zero-value of any *TYPE

&VAR                              #Generate a pointer (TYPE -> *TYPE)
*VAR                              #Dereference a pointer (*TYPE -> TYPE)

STRUCT.VAR                        #Same as (*STRUCT).VAR
INTERFACE|STRUCT_POINTER.FUNC(...)#Same as (*INTERFACE|STRUCT_POINTER).FUNC(...) when using a non-POINTER_TYPE receiver
INTERFACE|STRCUT.FUNC(...)        #Same as (&INTERFACE|STRUCT).FUNC(...) when using a POINTER_TYPE receiver
ARR_POINTER[...]                  #Same as (*ARR_POINTER)[...]
ARR_POINTER[...:...]              #Same as (*ARR_POINTER)[...:...]

new(TYPE)                         #Same as:
                                  #  var VAR TYPE (assigning zero-value)
                                  #  return &VAR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            UINTPTR            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


uintptr                           #TYPE
                                  #Behaves like uint, including size and zero-value.
                                  #Unlike *TYPE, represents a pointer towards unknown type.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ASSIGNMENT           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SCOPE ==>                         #Block-scoped:
                                  #  - "universe": pre-defined language VAR|TYPE: builtin TYPE|FUNC, true|false|iota|nil
                                  #  - package: top-level scope, shared by all files of same package
                                  #  - file: top-level scope
                                  #  - function or statement blocks, including if|for|case
                                  #     - if|for|switch first EXPR is scoped within following block
                                  #Inherit parent scope, but not children
                                  #  - including in anomymous FUNC ("closure")

VARIABLE NAME ==>                 #Must not be a language keyword or a "universe block" identifier
                                  #Must contain only letters, _ or (except first char) digit
                                  #  - can use non-ASCII letter|digit
                                  #Recommended camelCase over snake_case
                                  #Same rules for type TYPE

_                                 #Special VAR name ("blank identifier").
                                  #Can only be declared. Value cannot be used.
                                  #VAR name is not checked for uniqueness, i.e. can be declared several times without conflict.
                                  #Not checked in STRUCT == STRUCT2
                                  #Not allowed in INTERFACE

ZERO-VALUE VS INITIALIZED VALUE   #Zero-value is default value when no assigned value (including nil)
 ==>                              #Initialized value is first assigned value (including empty).

VAL,...                           #Multiple values (MVAL)
                                  #Similar to array, except must be stored in one variable each

var VAR,... TYPE
var (VAR,... TYPE;...)            #Declare + assign zero-value

VAR = VAL
VAR,... = MVAL                    #Assign

var VAR [TYPE] = VAL              #Declare + assign
var (VAR [TYPE] = VAL;...)        #Infers TYPE from value:
var VAR,... [TYPE] = MVAL         #  - for NUM:
var (VAR,... [TYPE] = MVAL;...)   #     - complex128 if imaginary part
                                  #     - float64 if decimal part
                                  #     - int otherwise
VAR := VAL                        #Shortcut syntax for var VAR = VAL
VAR,... := MVAL                   #Cannot be top-level scope

CONST_VAL                         #Value evaluated at compile-time
                                  #Restrictions:
                                  #  - only simple types, not composite.
                                  #     - not Math.Inf|NaN()
                                  #  - only literals or const VAR.
                                  #    Not var VAR.
                                  #  - operators, builtin FUNC imag|real|complex|len|cap(), TYPE(), unsafe.*().
                                  #    Not other FUNC()
                                  #If not typed at declaration-time, "untyped constant". Becomes typed when:
                                  #  - needs type (e.g. passed as argument|operand or assigned to VAR), through type inference
                                  #  - explicitely transtyped (TYPE())
const ...                         #Like var ... but CONST_VAL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           FUNCTION            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


func FUNC([VAR] [TYPE],...)       #Function declaration
 [TYPE2|([VAR2] [TYPE2],...)]     #TYPE|TYPE2 defaults to the next one
 { ... }                          #If VAR omitted:
                                  #  - all other VAR must be omitted
                                  #  - cannot refer to any arguments
                                  #TYPE2 is return type
                                  #  - TYPE,... is when returning MVAL
                                  #  - if named (VAR2): declare the variable on top of function
                                  #TYPE can be variadic ...TYPE, i.e. 0-n arguments:
                                  #  - must be last.
                                  #  - is a []TYPE
                                  #  - called with FUNC(MVAL) or FUNC(SLICE...)

func(...) [...] {...}             #Anonymous function (no FUNC name)
                                  #Same as function declaration except:
                                  #  - can be used as value
                                  #  - cannot be a method
                                  #Higher operator priority than FUNC(), i.e. can do func(...) {...}(...)

func(...) [...]                   #Function TYPE
                                  #I.e. anonymous functions can FUNC arguments
                                  #Receiver is not part of function TYPE

return [MVAL]                     #Required when there is a return TYPE2. Optional otherwise.
                                  #If any return value is named (VAR2), MVAL defaults to them ("naked return"):
                                  #  - if mixed with unnamed, those use their zero-value

FUNC([MVAL])                      #Call a function


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STRUCT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


struct                            #STRUCT_TYPE
 { [[VAR,...] TYPE [STR]];... }   #Ordered object whose keys are names and values any TYPE.
                                  #If VAR omitted ("embedded field"):
                                  #  - default name is "TYPE"
                                  #     - if PACKAGE.TYPE, only "TYPE"
                                  #  - TYPE must be type name, not type literal
                                  #     - can be *TYPE
                                  #  - if TYPE is INTERFACE|STRUCT, can access TYPE.* directly from STRUCT_TYPE.* ("promoted field")
                                  #     - including added to "method set"
                                  #     - exluding in literal STRUCT_TYPE{...}
                                  #STR is "tag":
                                  #  - no semantics but:
                                  #     - can be retrieved with reflect PACKAGE
                                  #     - part of TYPE identity
                                  #  - usually `VAR:"STR" ...`
                                  #  - default: ``

EMPTY STRUCT ==>                  #Zero-value, i.e. each element uses its own zero-value
                                  #No nil

STRUCT_TYPE{ [VAR:][VAL],... }    #Creates a new STRUCT, instance of STRUCT_TYPE
                                  #If VAR, named, otherwise positional. Cannot mix.
                                  #VAL defaults to zero-value
                                  #  - if positional, only if all VAL omitted

STRUCT.VAR [= VAL]                #Get|set property


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           INTERFACE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


func (VAR3 TYPE3) FUNC(...)       #Method declaration.
 ... {...}                        #Function with special argument VAR3 ("receiver") similar to "this" in other languages:
                                  #  - called using VAR3.FUNC(...) ("method")
                                  #  - TYPE3:
                                  #     - must be a defined type (type TYPE TYPE2)
                                  #     - type name must be defined in same package
                                  #  - can overload|re-declare functions, providing they have a different receiver (including none)
                                  #"Method set" is all methods of a specific receiver.
                                  #  - inherited by identical types only
                                  #     - i.e. not by "type TYPE TYPE2"

interface {                       #INTERFACE_TYPE
  [FUNC(...) [...]];...           #FUNC(...) [...] is like FUNC_TYPE but with a function name
  [INTERFACE_TYPE2];...           #If INTERFACE_TYPE2, include its methods ("embedded")
}                                 #  - if some methods already exists, must exactly match
                                  #  - cannot embed itself (including recursively)
                                  #Recommended names
                                  #  - if INTERFACE single FUNC (e.g. Write()) -> "FUNCer" (e.g. Writer)
                                  #  - if FUNC is meant for transtyping to TYPE -> "Type()" (not ToType())

interface {}                      #Empty INTERFACE can be used to describe "any TYPE"

nil                               #Zero-value
                                  #Unlike empty INTERFACE:
                                  #  - cannot call any method

TRANSTYPE ==>                     #Any TYPE can transtype to INTERFACE_TYPE providing it includes at least the same methods ("method set")
                                  #  - methods order is not significant
                                  #  - it wraps the underlying TYPE ("dynamic type"), i.e. acting as an abstraction type ("static type")
                                  #  - only INTERFACE.METHOD(...) can be used, unless transtyped to underlying TYPE

INTERFACE.(TYPE)                  #Transtype back to underlying TYPE ("type assertion")
                                  #Must be used instead of TYPE(INTERFACE)
                                  #Returns MVAL of TYPE, BOOL
                                  #BOOL is whether TYPE is exact same underlying TYPE
                                  #  - if not, panic unless BOOL was retrieved (i.e. can be used for asserting)
switch
 [EXPR;] VAR := INTERFACE.(type)
 { ... }                          #"Type switch": like normal switch except value is TYPE


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              MAP              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/



map[KTYPE]VTYPE                   #MAP_TYPE
                                  #Unordered object whose keys are KTYPE and values are VTYPE
                                  #KTYPE must allow ==, i.e. cannot be FUNC|MAP|SLICE

nil                               #Zero-value.
                                  #Like empty MAP:
                                  #  - can get|delete
                                  #  - length is 0
                                  #Unlike empty MAP:
                                  #  - cannot set

map[KTYPE]VTYPE{ [VAL: VAL2],... }#Creates a MAP with some elements
make(map[KTYPE]VTYPE[, UINT])->MAP#Creates an empty MAP.
                                  #Pre-allocates space for UINT elements
                                  #  - only for performance optimization. Size grows dynamically.

MAP[KVAL]                         #Get an element.
                                  #Return VAL, BOOL:
                                  #  - if element not found, VAL is zero-value and BOOL is false
MAP[KVAL] = VAL                   #Set an element
delete(MAP, KVAL)                 #Delete an element

len(MAP)->UINT                    #Number of keys


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ARRAY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[UINT]TYPE                        #ARR_TYPE
                                  #UINT is static size.
                                  #  - can be an EXPR

EMPTY ARR ==>                     #Zero-value, i.e. each element uses its own zero-value
                                  #No nil

[UINT]TYPE{[VAL],...}             #Creates a new ARR
                                  #VAL defaults to zero-value
[...]TYPE{[VAL],...}              #Same but guesses UINT

ARR[UINT] [= VAL]                 #Get|set element
                                  #Error if out-of-bound

len(ARR)->UINT                    #Number of elements
cap(ARR)->UINT                    #Same


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             SLICE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[]TYPE                            #SLICE_TYPE
                                  #Reference to part of an ARR
                                  #No static size
                                  #Different type than ARR, e.g. cannot transtype from|to ARR

nil                               #Zero-value.
                                  #Like empty SLICE:
                                  #  - has 0 length|capacity
                                  #  - can be read|listed
                                  #  - can be manipulated by append(), behaving like an empty SLICE
                                  #Unlike empty SLICE:
                                  #  - has no underlying ARR
                                  #  - SLICE[...:...] returns another nil

MEMORY EFFICIENCY ==>             #Since it keeps whole ARR in memory but only use a subset, it is more memory efficient,
                                  #but less CPU efficient, to create a new smaller ARR that fits the SLICE, so the bigger
                                  #one can be garbage collected when function returns:
                                  #  sliceB := make([]TYPE, len(sliceA))
                                  #  copy(sliceB, sliceA)

make([]TYPE, UINT[, UINT2])->SLICE#Creates a new SLICE, including the underlying ARR, with zero-value elements.
                                  #UINT is length, UINT2 is capacity (def: UINT)
[]TYPE{[VAL],...}                 #Creates a new SLICE, including the underlying ARR, with specific elements

ARR[[UINT]:[UINT2]]               #Creates a new SLICE from ARR[UINT] to ARR[UINT2 - 1]
                                  #UINT defaults to 0, UINT2 to len(ARR)
                                  #Error if out-of-bound
SLICE[[UINT]:[UINT2]]             #Creates a new SLICE2 from the underlying ARR
                                  #UINT adds to SLICE's own UINT, i.e. can only go forward
                                  #But UINT2 replaces SLICE's own UINT2, i.e. can increase size
                                  #Error if out-of-bound

SLICE[UINT] [= VAL]               #Like ARR

len(SLICE)->UINT                  #Number of elements of SLICE
cap(SLICE)->UINT2                 #Number of elements of max-resized SLICE[:UINT2], i.e. number of elements of underlying ARR
                                  #from same start UINT

copy(SLICE, SLICE2)->UINT         #Copy UINT first elements of SLICE2 to SLICE's underlying ARR
                                  #UINT is min(len(SLICE), len(SLICE2))
append(SLICE, VAL...)->SLICE2     #Write VAL,... to SLICE's underlying ARR, after SLICE end
                                  #If underlying ARR too small, creates a new one, and write to it instead
                                  #Return new SLICE2 contains all original+new elements


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ERROR             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PANIC ==>                         #Like an exception.

defer FUNC(...)                   #Call a function, right after return statement evaluated, but before function returns.
                                  #Arguments are evaluated right away though. If anonymous FUNC, closure kept.
                                  #Last defer is executed first.
                                  #Purpose: like a try/catch/finally block.

error                             #INTERFACE
                                  #Error TYPEs should be STRUCT implementing this INTERFACE
                                  #Must be returned and tested != nil.
error.Error()->STR                #Serialize an ERROR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           GOROUTINE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go FUNC(...)                      #Call a function but inside a new thread.
                                  #Arguments are evaluated in the current thread though.
                                  #Threads:
                                  #  - consume less CPU and memory than processes
                                  #  - share same memory|scope
                                  #  - run concurrently
                                  #Process does not wait for thread exit
                                  #  - but process exit terminates threads
                                  #  - can used CHAN to wait


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CHANNEL            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


chan TYPE                         #Pipe|FIFO with TYPE elements, meant for cross-thread communication
chan <- TYPE
<- chan TYPE                      #Same but only allows sending or receiving

nil                               #Zero-value.
                                  #Receive|send block forever.
                                  #Length|capacity is 0

make(chan TYPE[, UINT])->CHAN     #Creates a CHAN instance
                                  #UINT is buffer size (def: 0, i.e. unbuffered)

CHAN <- VAL                       #Send VAL to CHAN (push).
                                  #If unbuffered, blocks until it gets received.
                                  #If buffered and buffer full, blocks until it can push.
<-CHAN                            #Receive VAL from CHAN (pop).
                                  #Blocks until a VAL is available
                                  #Returns VAL, BOOL
                                  #  - BOOL is whether CHAN was closed
                                  #  - if CHAN closed, panic unless BOOL was retrieved

close(CHAN)                       #Make receive|send noop:
                                  #  - any buffered VAL is still received
                                  #  - then receive returns VAL, true, where VAL is CHAN's TYPE zero-value
                                  #Panic if CHAN is either receive-only, or nil
                                  #Automatically done at end of process. Only necessary when either:
                                  #  - using for VAL := range CHAN
                                  #  - want receive|send to become noop

for VAL := range CHAN { ... }     #Iterates unless CHAN closed

for {
  select {
    [case EXPR:                   #All EXPR must contain CHAN <- VAL or <-CHAN
      ...]...                     #Repeat the loop at regular interval (polling)
    [default:                     #For each loop:
      ...]                        #  - execute block of any EXPR unblocked
  }                               #  - if none, runs default block
}                                 #To prevent infinite loop, use return

len(CHAN)->UINT                   #Number of buffered elements
cap(CHAN)->UINT                   #Buffere size
