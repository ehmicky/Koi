
      
   GO  
      



TODO:
  - all go CMD
  - all go* executable
  - https://blog.golang.org
  - https://github.com/golang?type=source
  - go through to_learn.txt

VERSION ==>                       #1.14.4


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             BUILD             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ENVVAR GOROOT                     #Global go directory.
                                  #Contains go|gofmt executable
                                  #Def: /usr/local/go

go build FILE.go                  #Compile FILE.go to executable FILE
go build [DIR]                    #Compile DIR/*.go to executable DIRNAME
                                  #Must all be from same PACKAGE
                                  #Def DIR: .


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              ENV              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go env                            #Prints all GO*|CGO* ENVVARs, and also GCC-related ENVVARs
                                  #After default value resolution
go env "ENVVAR",...               #Print value
go env -w ENVVAR=VAL,...          #Sets value
go env -u ENVVAR                  #Unsets value

-json                             #Prints as JSON

ENVVAR GOENV                      #Where go env -w|-u ... is stored
                                  #Def: ~/.config/go/env


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            MODULE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


MODULE ==>                        #Group of PACKAGEs

"[NAMESPACE]/MODULE"              #"MODULE_PATH", identifier of the MODULE
                                  #NAMESPACE is location among:
                                  #  - standard library STR
                                  #  - PATH, relative to:
                                  #     - $PWD[/...]
                                  #     - $GOROOT/src
                                  #     - $GOPATH/src
                                  #  - URI

go.mod                            #File containing:
                                  #  - first line: "MODULE_PATH"
                                  #  - last line: "Go VERSION"
                                  #Location determines the module's root directory:
                                  #  - any subdirectory's PACKAGE is included
                                  #  - subdirectory with another go.mod are excluded
go mod init "MODULE_PATH"         #Creates ./go.mod

go install ["MODULE_PATH"|DIR]    #Downloads MODULE and installs as binary in GOBIN
                                  #If DIR (def: '.'), searches in DIR
GOBIN                             #By priority:
                                  #  - ENVVAR GOBIN
                                  #  - FIRST_GO_PATH/bin, where FIRST_GO_PATH is ENVVAR GOPATH's first path
                                  #  - HOME/go/bin/MODULE
                                  #     - HOME is $HOME on Unix, %USERPROFILE% on Windows


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PACKAGE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


package PACKAGE                   #Declare which PACKAGE it belongs
                                  #Must be first statement
                                  #All *.go within same DIR must have same PACKAGE
                                  #Package top-level scope is shared by all files
                                  #Recommended lowercase

package main                      #CLI entry point (as opposed to programmatic)
                                  #Must have a main func

"MODULE_PATH[/PATH]"              #"IMPORT_PATH", identifier of a PACKAGE

EXPORT ==>                        #Any top-level variable whose variable name starts with uppercase is exported
                                  #Recommended not to namespace their variable name, since PACKAGE already namespaces them

import "IMPORT_PATH"              #Import PACKAGE as a top-level variable named PACKAGE
                                  #Must be available in GOBIN
import (
  "..."
  ...
)                                 #Same as several import "..."


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           COMMENTS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


// COMMENT
/* COMMENT */                     #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           STATEMENT           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPR[;]                           #; is optional (and not recommended) most of the time


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            VALUES             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


(VAL)                             #Parenthesis can be used to override operator precedence


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             TYPE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NESTING ==>                       #All non-simple types can be nested: **TYPE, [][]TYPE, map[TYPE]map[TYPE2]TYPE3, etc.,
                                  #including mixed

INLINE INFERING ==>               #When inlining nested TYPE, nested TYPE2 can be omitted.
                                  #For example [][]TYPE{[]TYPE{}, []TYPE{}} -> [][]TYPE{{}, {}}

type TYPE TYPE2                   #Type alias
                                  #Often used with struct|interface to name them


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             BOOL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/

bool                              #TYPE
                                  #Zero value is false

true|false                        #BOOL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            NUMBER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ZERO-VALUE ==>                    #0

[u]int8|16|32|64                  #TYPE with 8|16|32|64 bits
[u]int                            #TYPE with 32|64 bits depending on OS
byte                              #Alias for uint8, meant for binary data
rune                              #Alias for int32, meant for Unicode codepoints

[-]N...                           #[U]INT

float32|64                        #TYPE with 32|64 bits

[-]INT[.N...]                     #FLOAT

complex64|128                     #TYPE for complex numbers, with 64|128 bits

FLOAT [+|- FLOAT2i]               #COMPLEX

uintptr                           #TYPE. Size is same as uint


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STRING             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


string                            #TYPE
                                  #Zero-value is ""

"..."                             #STR
                                  #Can contain \n


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            POINTER            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


*TYPE                             #TYPE2. Pointer of a TYPE.
                                  #Used to pass a STRUCT|ARR by reference instead of value
                                  #Lower operator priority than [NUM] or .VAR

nil                               #Zero-value of any *TYPE

&VAR                              #Generate a pointer (TYPE -> *TYPE)
*VAR                              #Dereference a pointer (*TYPE -> TYPE)

STRUCT_POINTER.VAR                #Same as (*STRUCT_POINTER).VAR
ARR_POINTER[NUM]                  #Same as (*ARR)[NUM]
POINTER.FUNC(...)                 #Same as (*VAL).FUNC(...) when using a non-POINTER_TYPE receiver
VAL.FUNC(...)                     #Same as (&VAL).FUNC(...) when using a POINTER_TYPE receiver


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ASSIGNMENT           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


VARIABLE NAME ==>                 #Recommended camelcase over snake_case

var VAR,... TYPE
var (
  VAR TYPE
  ...                             #Declare + assign zero-value
)                                 #Block-scoped (including if block, etc.). Can be used by child scopes but not parent

VAR = VAL
VAR,... = MVAL                    #Assign

var|const VAR [TYPE] = VAL        #Declare + assign
var|const VAR,... [TYPE] = MVAL   #If const, cannot assign anymore
var|const (                       #Infers TYPE from value:
  VAR [TYPE] = VAL                #  - for NUM:
  ...                             #     - complex128 if imaginary part
)                                 #     - float64 if decimal part
                                  #     - int otherwise
                                  #  - happens at reference-time, not declaration-time
                                  #     - i.e. when passed as FUNC parameter, use its argument TYPE
VAR := VAL                        #Shortcut syntax for var VAR = VAL
VAR,... := MVAL                   #Cannot be top-level scope


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           TRANSTYPE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TYPE(VAL)                         #Explicit transtype.
                                  #Transtype cannot be implicit.
                                  #The only ones allowed are the following.

UINT32 -> STR                     #Using Unicode codepoint
NUM -> other NUM                  #Only if can perfectly convert, i.e. not if:
                                  #  - negative NUM -> UINT
                                  #  - too high NUM -> smaller NUM
                                  #  - FLOAT with decimal -> [U]INT
                                  #  - COMPLEX with imaginary part -> [U]INT|FLOAT
FUNC -> other FUNC2               #Only if exact same number and type of arguments and return values
                                  #Names VAR|VAR2 insignificant
                                  #Receiver insignificant
STRUCT|MAP|ARR|SLICE ->
 other STRUCT|MAP|ARR|SLICE       #Only if exact same, including number, names and types


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           FUNCTION            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


func [(VAR3 TYPE3)]               #Function declaration
 FUNC([VAR] [TYPE],...)           #TYPE|TYPE2 defaults to the next one
 [TYPE2|([VAR2] [TYPE2],...)]     #TYPE2 is return type
 { ... }                          #  - TYPE,... is when returning MVAL
                                  #  - if named (VAR2):
                                  #     - declare the variable on top of function
                                  #     - return with no MVAL defaults to returning those
                                  #TYPE can be variadic ...TYPE, i.e. 0-n arguments:
                                  #  - must be last.
                                  #  - is a []TYPE
                                  #  - called with FUNC(MVAL) or FUNC(SLICE...)
                                  #VAR3 is special argument ("receiver") similar to "this" in other languages:
                                  #  - called using VAR3.FUNC() ("method")
                                  #     - if *TYPE3, can VAR3.FUNC() instead of (&VAR3).FUNC()
                                  #  - TYPE3:
                                  #     - must be a "type TYPE3" alias
                                  #     - alias must be defined in same package
                                  #  - can overload|re-declare functions, providing they have a different receiver (including none)

func(...) [...] {...}             #Anonymous function (no FUNC name)
                                  #Same as function declaration except:
                                  #  - can be used as value
                                  #  - cannot be a method
                                  #Current|parent scope variables are kept available ("closure")

func(...) [...]                   #Function TYPE
                                  #I.e. anonymous functions can FUNC arguments
                                  #Receiver is not part of function TYPE

return [MVAL]                     #Required when there is a return TYPE2. Optional otherwise.
                                  #If any return value is named (VAR2), MVAL defaults to them ("naked return"):
                                  #  - if mixed with unnamed, those use their zero-value

FUNC([MVAL])                      #Call a function
                                  #Pass any argument by deep copy.
                                  #  - however *TYPE are addresses, i.e. can be used for references
                                  #  - MAP (not STRUCT), SLICE (not ARR) also behave like pointers|references

defer FUNC(...)                   #Call a function, right after it returns.
                                  #Arguments are evaluated right away though.
                                  #Last defer is executed first.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           INTERFACE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


interface { [FUNC(...) [...]];...}#INTERFACE_TYPE
                                  #FUNC(...) [...] is like FUNC_TYPE but with a function name
                                  #Any TYPE can transtype to INTERFACE_TYPE providing it includes at least the same methods
                                  #  - it wraps the underlying TYPE, i.e. acting as an abstraction type
                                  #  - it still behaves as if it was that TYPE, except for transtyping
                                  #  - it validates that those methods exist
                                  #Recommended names
                                  #  - if INTERFACE single FUNC (e.g. Write()) -> "FUNCer" (e.g. Writer)
                                  #  - if FUNC is meant for transtyping to TYPE -> "Type()" (not ToType())

interface {}                      #Empty INTERFACE can be used to describe "any TYPE"

nil                               #Zero-value
                                  #Unlike empty INTERFACE:
                                  #  - cannot call any method

INTERFACE.(TYPE)                  #Transtype back to underlying TYPE ("type assertion")
                                  #Must be used instead of TYPE(INTERFACE)
                                  #Returns MVAL of TYPE, BOOL
                                  #BOOL is whether TYPE is exact same underlying TYPE
                                  #  - if not, panic unless BOOL was retrieved (i.e. can be used for asserting)
switch
 [EXPR;] VAR := INTERFACE.(type)
 { ... }                          #"Type switch": like normal switch except value is TYPE


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           MULTIPLE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


VAL,...                           #Multiple values (MVAL)
                                  #Similar to array, except must be stored in one variable each


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STRUCT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


struct { [[VAR,...] TYPE2];... }
struct {
 [[VAR,...] TYPE2]
 ...
}                                 #STRUCT_TYPE

STRUCT_TYPE{ [VAR:][VAL],... }    #Creates a new STRUCT, instance of STRUCT_TYPE
                                  #If VAR, named, otherwise positional. Cannot mix
                                  #VAL defaults to zero-value
                                  #  - if positional, only if all VAL omitted

STRUCT.VAR [= VAL]                #Get|set property


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              MAP              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/



map[KTYPE]VTYPE                   #MAP_TYPE
                                  #Object whose keys are KTYPE and values are VTYPE
                                  #Behaves like a *TYPE, i.e. passed as reference, not copy to FUNC
nil                               #Zero-value of MAP
                                  #Like empty MAP:
                                  #  - can get|delete
                                  #Unlike empty MAP:
                                  #  - cannot set

map[KTYPE]VTYPE{ [VAL: VAL2],... }#Creates a MAP with some elements
make(map[KTYPE]VTYPE)->MAP        #Creates an empty MAP

MAP[KVAL]                         #Get an element.
                                  #Return VAL, BOOL:
                                  #  - if element not found, VAL is zero-value and BOOL is false
MAP[KVAL] = VAL                   #Set an element
delete(MAP, KVAL)                 #Delete an element


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ARRAY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[UINT]TYPE                        #ARR_TYPE
                                  #UINT is static size.
                                  #  - part of the type, e.g. cannot transtype

[UINT]TYPE{[VAL],...}             #Creates a new ARR
                                  #VAL defaults to zero-value
[...]TYPE{[VAL],...}              #Same but guesses UINT

ARR[UINT] [= VAL]                 #Get|set element
                                  #Error if out-of-bound

len(ARR)->UINT                    #Number of elements
cap(ARR)->UINT                    #Same


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             SLICE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[]TYPE                            #SLICE_TYPE
                                  #Reference to part of an ARR
                                  #  - behaves like a *TYPE, i.e. passed as reference, not copy to FUNC
                                  #No static size
                                  #Different type than ARR, e.g. cannot transtype from|to ARR

MEMORY EFFICIENCY ==>             #Since it keeps whole ARR in memory but only use a subset, it is more memory efficient,
                                  #but less CPU efficient, to create a new smaller ARR that fits the SLICE, so the bigger
                                  #one can be garbage collected when function returns:
                                  #  sliceB := make([]TYPE, len(sliceA))
                                  #  copy(sliceB, sliceA)

nil                               #Zero-value.
                                  #Like empty SLICE:
                                  #  - has 0 length|capacity
                                  #  - can be read|listed
                                  #  - can be manipulated by append(), behaving like an empty SLICE
                                  #Unlike empty SLICE:
                                  #  - has no underlying ARR
                                  #  - SLICE[...:...] returns another nil

make([]TYPE, UINT[, UINT2])->SLICE#Creates a new SLICE, including the underlying ARR, with zero-value elements.
                                  #UINT is length, UINT2 is capacity (def: UINT)
[]TYPE{[VAL],...}                 #Creates a new SLICE, including the underlying ARR, with specific elements

ARR[[UINT]:[UINT2]]               #Creates a new SLICE from ARR[UINT] to ARR[UINT2 - 1]
                                  #UINT defaults to 0, UINT2 to len(ARR)
                                  #Error if out-of-bound
SLICE[[UINT]:[UINT2]]             #Creates a new SLICE2 from the underlying ARR
                                  #UINT adds to SLICE's own UINT, i.e. can only go forward
                                  #But UINT2 replaces SLICE's own UINT2, i.e. can increase size
                                  #Error if out-of-bound

SLICE[UINT] [= VAL]               #Like ARR

len(SLICE)->UINT                  #Number of elements of SLICE
cap(SLICE)->UINT2                 #Number of elements of max-resized SLICE[:UINT2], i.e. number of elements of underlying ARR
                                  #from same start UINT

copy(SLICE, SLICE2)->UINT         #Copy UINT first elements of SLICE2 to SLICE's underlying ARR
                                  #UINT is min(len(SLICE), len(SLICE2))
append(SLICE, VAL...)->SLICE2     #Write VAL,... to SLICE's underlying ARR, after SLICE end
                                  #If underlying ARR too small, creates a new one, and write to it instead
                                  #Return new SLICE2 contains all original+new elements


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ERROR             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PANIC ==>                         #Process abort

error                             #INTERFACE
                                  #Error TYPEs should be STRUCT implementing this INTERFACE
                                  #Must be returned and tested != nil. No throwing.
error.Error()->STR                #Serialize an ERROR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             LOOPS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/



if [EXPR;] BOOL_EXPR { ... }
 [else if [EXPR;] BOOL_EXPR {...}]
 ...
 [else { ... }]                   #If EXPR, executed before BOOL_EXPR, but scoped within { ... }

switch [EXPR;] [EXPR2] {
  [case EXPR3:                    #Execute first case where EXPR2 == EXPR3
    ...]...                       #EXPR2 defaults to true
  [default:                       #Cases are indentation-based
    ...]                          #No break needed, each case does not follow through next one
}                                 #If EXPR, executed before BOOL_EXPR, but scoped within { ... }

for [EXPR]; [BOOL_EXPR]; [EXPR2]  #For loop
 { ... }                          #BOOL_EXPR defaults to true

for [BOOL_EXPR] { ... }           #Same as for ; [BOOL_EXPR]; { ... }
                                  #I.e. while loop

for KEY_VAR[, VAL_VAR2]           #Iterates
  := range ARR|SLICE { ... }      #VAL is copy. However *TYPE|MAP|SLICE elements behave like references (like in FUNC())
for ... = range ...               #Same but with already declared KEY_VAR, VAL_VAR

SLICE reference
STRUCT|ARR copy


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           GOROUTINE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go FUNC(...)                      #Call a function but inside a new thread.
                                  #Arguments are evaluated in the current thread though.
                                  #Threads:
                                  #  - consume less CPU and memory than processes
                                  #  - share same memory|scope
                                  #  - run concurrently
                                  #Process does not wait for thread exit


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CHANNEL            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


chan TYPE                         #Pipe|FIFO with TYPE elements, meant for cross-thread communication

nil                               #Zero-value for CHAN
                                  #Cannot read|write from it

make(chan TYPE[, NUM])            #Creates a CHAN instance
                                  #NUM is buffer size (def: 0)

CHAN <- VAL                       #Push VAL to CHAN.
                                  #If buffer full, blocks until it can push.
                                  #  - if buffer size 0, blocks until it gets popped
<-CHAN                            #Pop VAL from CHAN.
                                  #Blocks until a VAL is available
                                  #Returns VAL, BOOL
                                  #  - BOOL is whether CHAN was closed
                                  #  - if CHAN closed, panic unless BOOL was retrieved

close(CHAN)                       #Do not allow read|write anymore.
                                  #Automatically done at end of process. Only necessary when either:
                                  #  - using for VAL := range CHAN
                                  #  - want read|write to fail

for VAL := range CHAN { ... }     #Iterates unless CHAN closed

for {
  select {
    [case EXPR:                   #All EXPR must contain CHAN <- VAL or <-CHAN
      ...]...                     #Repeat the loop at regular interval (polling)
    [default:                     #For each loop:
      ...]                        #  - execute block of any EXPR unblocked
  }                               #  - if none, runs default block
}                                 #To prevent infinite loop, use return
