
                       
   GO_STANDARD_LIBRARY  
                       



VERSION ==>                       #See Go language

DOCUMENTED ELSEWHERE ==>          #In go language (because part of language spec):
                                  #  - unsafe
                                  #  - runtime.Error|TypeAssertionError
                                  #  - runtime.Gosched|[Un]lockOSThread|Goexit|NumGoroutine
                                  #  - runtime.NumCgoCall|SetCgoTraceback
                                  #In go CLI:
                                  #  - runtime.GOROOT|Compiler
                                  #In go testing:
                                  #  - testing
                                  #In go debugging:
                                  #  - runtime/pprof
                                  #  - runtime.Breakpoint|[Read]MemStats|*Profile*|StackRecord


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            RUNTIME            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


import "runtime"                  #
import "runtime/debug"            #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          RUNTIME OS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


go version                        #Prints "go version goX.Y GOOS/GOARCH"
runtime.Version()->STR            #'goX.Y' or 'COMMIT-DATE'

runtime.GOOS                      #OS name
                                  #Among "linux", "darwin", "windows", "freebsd|netbsd|openbsd|dragonfly", "solaris|illumos", "plan9",
                                  #"aix", "android", "nacl" (Chrome OS), "js" (with GOARCH "wasm")
                                  #Can be set manually with ENVVAR GOOS

runtime.GOARCH                    #CPU architecture
                                  #Among "386|amd64[p32]", "arm[64]", "ppc64[le]", "mips[64][le]", "s390x", "riscv64", "wasm"
                                  #Can be set manually with ENVVAR GOARCH
ENVVAR GOARM                      #"5|6|7". ARM version, with GOARCH=arm
ENVVAR GO386                      #"387|sse2". Floating point version, with GOARCH=386
ENVVAR GOMIPS[64]                 #"hardfloat|softfloat". Floating point version, with GOARCH=mips[64][le]
ENVVAR GOWASM                     #"FEAT,...". Experimental features, with GOARCH=wasm, among "satconv|signext"

ENVVAR GOHOSTOS|GOHOSTARCH        #Like ENVVAR GOOS|GOARCH except readonly

ENVVAR GOEXE                      #Built file file extension. "" on Unix, ".exe" on Windows
                                  #Read-only


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          RUNTIME CPU          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


runtime.NumCPU()->INT             #Number of CPU cores
runtime.GOMAXPROCS(0)->INT2       #Max number of goroutines running in parallel
runtime.GOMAXPROCS(INT)->INT2     #Sets it, and returns the previous one
ENVVAR GOMAXPROCS                 #Default value for runtime.GOMAXPROCS.
                                  #Def: runtime.NumCPU()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         RUNTIME STACK         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


debug.Stack()->[]BYTE             #Retrieve current call stack formatted
                                  #Only for current goroutine
debug.PrintStack()                #Like os.Stderr.Write(debug.Stack())
runtime.Stack([]BYTE, BOOL)->INT  #Lower-level function.
                                  #Write current call stack formatted to []BYTE, writing INT bytes
                                  #  - []BYTE must already have some length
                                  #  - if INT < len([]BYTE), must extend length, then call again
                                  #If BOOL true, includes other goroutines

runtime.Callers(INT, []UINTPTR)   #Fills []UINTPTR with current call stack frames (skipping INT innermost stack frames)
 ->INT2                           #Returns number of UINTPTR written
runtime.Caller(INT)               #Returns current stack FRAME.PC|File|Line
 ->UINTPTR,'/PATH',LINE_INT,OK    #Skips INT innermost frames.
runtime.CallersFrames([]UINTPTR)
 ->*FRAMES                        #Transform to FRAMES

runtime.Frames                    #Call stack. From inner to outer
FRAMES.Next()->FRAME,BOOL         #BOOL is false is last frame.

runtime.Frame                     #Stack frame
FRAME.PC                          #UINPTR. Address
                                  #Can be 0 if inline func or not Go
FRAME.Func                        #*RUNTIME_FUNC.
                                  #nil if non-Go or inlined.
FRAME.Function                    #Like FRAME.Func.Name()
FRAME.File                        #Like FRAME.Func.FileLine(FRAME.PC)[0]
FRAME.Line                        #Like FRAME.Func.FileLine(FRAME.PC)[1]
FRAME.Entry                       #Like FRAME.Func.Entry()

runtime.Func                      #Go function
runtime.FuncForPC(UINTPTR)
 ->*RUNTIME_FUNC                  #Find the function of a specific address
RUNTIME_FUNC.Name()
 ->'PACKAGE.FUNC_NAME'            #Can be empty ''
RUNTIME_FUNC.FileLine(UINTPTR)    #File|line of a specific line of code inside function
 ->'/PATH',LINE_INT               #Can be empty ''|0
RUNTIME_FUNC.Entry()->UINTPTR     #Function's address
                                  #Can be 0 if inline func or not Go


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          RUNTIME GC           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GC ==>                            #Mark-and-sweep.
                                  #Sweeping happens both incrementally and during stop-the-world events (STW)
                                  #STW are triggered when HeapInUse reaches a changing specific heap size threshold
                                  #STW are broken down into several "pauses".

runtime.GC()                      #Force running a GC stop-the-world

MEM_STATS.NextGC UINT64           #Next GC threshold to trigger STW
MEM_STATS.NumGC UINT32            #Number of GC STWs
MEM_STATS.NumForcedGC UINT32      #Number of runtime.GC() calls
MEM_STATS.PauseTotalNs UINT64     #Number of ns spent in all GC STWs
MEM_STATS.PauseNs [256]UINT_64    #Time spent in each of the last 256 GC pauses. If none, 0.
MEM_STATS.GCCPUFraction FLOAT64   #How much % of CPU time was spent in GC
MEM_STATS.LastGC UINT64           #Last GC's Unix timestamp (in ns). If none, 0.
MEM_STATS.PauseEnd [256]UINT_64   #Unix timestamp (in ns) of the last 256 GC pauses. If none, 0.

MEM_STATS.EnableGC BOOL           #Whether GC is enabled (def: true)
MEM_STATS.DebugGC BOOL            #Always false

runtime.SetFinalizer              #Calls FUNC(VAL) when VAL is about to be GC'd
 (VAL, FUNC(VAL)|nil)             #  - should not rely:
                                  #     - on when|whether GC happens, since this is very variable
                                  #     - on it to guess when|whether GC happens
                                  #If nil, removes any finalizer FUNC instead.
                                  #VAL must be *STRUCT
                                  #If VAL contains members with finalizers, run those first
runtime.KeepAlive(VAL)            #When calling SetFinalizer(VAL) and last statement using VAL is async,
                                  #finalizer might be run before async completes.
                                  #Doing KeepAlive() right after async statement prevents this.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONTEXT            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


context.Context                   #INTERFACE
                                  #Used to allow several goroutines to be terminated together (including cancellation|timeout)
                                  #By convention, passed around as first argument between functions.
CONTEXT.Done()->(<-STRUCT_CHAN)   #CHAN meant to await termination
                                  #  - closed on termination
                                  #  - meant to be used in select statement
                                  #      select { case <-CONTEXT.Done(): return CONTEXT.Err() }
                                  #CHAN can be nil if can never cancel
CONTEXT.Deadline()->TIME,BOOL     #Returns timeout's TIME
                                  #BOOL is false is no timeout
CONTEXT.Err()->ERROR|nil          #Termination ERROR
CONTEXT.Value(KEY)->VAL|nil       #Arbitratry value associated with CONTEXT
                                  #KEY should be package-specific to prevent collisions
                                  #  - should not be STR
                                  #  - is often an empty struct{}

context.Background()->CONTEXT     #CONTEXT with no value and never cancelled|timed out.
                                  #Intent is to use as top-level CONTEXT
context.TODO()->CONTEXT           #Same except intention is to use when do not know yet which CONTEXT to use
                                  #Prefered instead of using a nil CONTEXT

context.WithCancel(CONTEXT)       #Create a CONTEXT's child:
 ->CANCEL_CONTEXT,CANCEL_FUNC     #  - inherits CONTEXT.Value()
                                  #When CANCEL_FUNC() is called:
                                  #  - CANCEL_CONTEXT.Done()'s CHAN is closed
                                  #  - CANCEL_CONTEXT.Err()'s ERROR is set
                                  #  - cancels any child CONTEXT
                                  #     - does not cancel parent
                                  #Should call CANCEL_FUNC() on successful termination too
                                  #  - usually with defer
                                  #If CONTEXT already cancelled, cancel CANCEL_CONTEXT with it right away
context.CancelFunc                #CANCEL_FUNC's type
context.Canceled                  #CANCEL_CONTEXT.Err()'s ERROR
CANCEL_CONTEXT.Context            #Parent CONTEXT

context.WithDeadline
 (CONTEXT, TIME)
 ->CONTEXT2,CANCEL_FUNC           #Like context.WithCancel() but automatically calls CANCEL_FUNC() at TIME
context.WithTimeout
 (CONTEXT, TIME_DURATION)
 ->CONTEXT2,CANCEL_FUNC           #Same with TIME_DURATION
context.DeadlineExceeded          #ERROR type for timeouts
DEADLINE_EXCEEDED.Error()->STR    #Always "context deadline exceeded"
DEADLINE_EXCEEDED.Timeout()->true #
DEADLINE_EXCEEDED.
 Temporary()->true                #

context.WithValue
 (CONTEXT, KEY, VAL)->CONTEXT2    #Create a CONTEXT's child with a specific Value()
