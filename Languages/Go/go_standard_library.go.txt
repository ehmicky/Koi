
                       
   GO_STANDARD_LIBRARY  
                       



VERSION ==>                       #See Go language

DOCUMENTED ELSEWHERE ==>          #In go language (because part of language spec):
                                  #  - unsafe
                                  #  - runtime.Error
                                  #In go CLI:
                                  #  - runtime.GOOS|GOARCH|Compiler
                                  #In go testing:
                                  #  - testing
                                  #  - runtime.[Read]MemStats|GC


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            RUNTIME            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


import "runtime"                  #

runtime.NumCPU()->INT             #Number of CPU cores
runtime.GOMAXPROCS(0)->INT2       #Max number of goroutines running in parallel
runtime.GOMAXPROCS(INT)->INT2     #Sets it, and returns the previous one
ENVVAR GOMAXPROCS                 #Default value for runtime.GOMAXPROCS.
                                  #Def: runtime.NumCPU()

runtime.NumGoroutine()->INT       #Number of running goroutines


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         RUNTIME STACK         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


import "runtime"                  #
import "runtime/debug"            #

debug.Stack()->[]BYTE             #Retrieve current call stack formatted
                                  #Only for current goroutine
debug.PrintStack()                #Like os.Stderr.Write(debug.Stack())
runtime.Stack([]BYTE, BOOL)->INT  #Lower-level function.
                                  #Write current call stack formatted to []BYTE, writing INT bytes
                                  #  - []BYTE must already have some length
                                  #  - if INT < len([]BYTE), must extend length, then call again
                                  #If BOOL true, includes other goroutines

runtime.Callers(INT, []UINTPTR)   #Fills []UINTPTR with current call stack frames (skipping INT innermost stack frames)
 ->INT2                           #Returns number of UINTPTR written
runtime.Caller(INT)               #Returns current stack FRAME.PC|File|Line
 ->UINTPTR,'/PATH',LINE_INT,OK    #Skips INT innermost frames.
runtime.CallersFrames([]UINTPTR)
 ->*FRAMES                        #Transform to FRAMES

runtime.Frames                    #Call stack. From inner to outer
FRAMES.Next()->FRAME,BOOL         #BOOL is false is last frame.

runtime.Frame                     #Stack frame
FRAME.PC                          #UINPTR. Address
                                  #Can be 0 if inline func or not Go
FRAME.Func                        #*RUNTIME_FUNC.
                                  #nil if non-Go or inlined.
FRAME.Function                    #Like FRAME.Func.Name()
FRAME.File                        #Like FRAME.Func.FileLine(FRAME.PC)[0]
FRAME.Line                        #Like FRAME.Func.FileLine(FRAME.PC)[1]
FRAME.Entry                       #Like FRAME.Func.Entry()

runtime.Func                      #Go function
runtime.FuncForPC(UINTPTR)
 ->*RUNTIME_FUNC                  #Find the function of a specific address
RUNTIME_FUNC.Name()
 ->'PACKAGE.FUNC_NAME'            #Can be empty ''
RUNTIME_FUNC.FileLine(UINTPTR)    #File|line of a specific line of code inside function
 ->'/PATH',LINE_INT               #Can be empty ''|0
RUNTIME_FUNC.Entry()->UINTPTR     #Function's address
                                  #Can be 0 if inline func or not Go


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONTEXT            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


context.Context                   #INTERFACE
                                  #Used to allow several goroutines to be terminated together (including cancellation|timeout)
                                  #By convention, passed around as first argument between functions.
CONTEXT.Done()->(<-STRUCT_CHAN)   #CHAN meant to await termination
                                  #  - closed on termination
                                  #  - meant to be used in select statement
                                  #      select { case <-CONTEXT.Done(): return CONTEXT.Err() }
                                  #CHAN can be nil if can never cancel
CONTEXT.Deadline()->TIME,BOOL     #Returns timeout's TIME
                                  #BOOL is false is no timeout
CONTEXT.Err()->ERROR|nil          #Termination ERROR
CONTEXT.Value(KEY)->VAL|nil       #Arbitratry value associated with CONTEXT
                                  #KEY should be package-specific to prevent collisions
                                  #  - should not be STR
                                  #  - is often an empty struct{}

context.Background()->CONTEXT     #CONTEXT with no value and never cancelled|timed out.
                                  #Intent is to use as top-level CONTEXT
context.TODO()->CONTEXT           #Same except intention is to use when do not know yet which CONTEXT to use
                                  #Prefered instead of using a nil CONTEXT

context.WithCancel(CONTEXT)       #Create a CONTEXT's child:
 ->CANCEL_CONTEXT,CANCEL_FUNC     #  - inherits CONTEXT.Value()
                                  #When CANCEL_FUNC() is called:
                                  #  - CANCEL_CONTEXT.Done()'s CHAN is closed
                                  #  - CANCEL_CONTEXT.Err()'s ERROR is set
                                  #  - cancels any child CONTEXT
                                  #     - does not cancel parent
                                  #Should call CANCEL_FUNC() on successful termination too
                                  #  - usually with defer
                                  #If CONTEXT already cancelled, cancel CANCEL_CONTEXT with it right away
context.CancelFunc                #CANCEL_FUNC's type
context.Canceled                  #CANCEL_CONTEXT.Err()'s ERROR
CANCEL_CONTEXT.Context            #Parent CONTEXT

context.WithDeadline
 (CONTEXT, TIME)
 ->CONTEXT2,CANCEL_FUNC           #Like context.WithCancel() but automatically calls CANCEL_FUNC() at TIME
context.WithTimeout
 (CONTEXT, TIME_DURATION)
 ->CONTEXT2,CANCEL_FUNC           #Same with TIME_DURATION
context.DeadlineExceeded          #ERROR type for timeouts
DEADLINE_EXCEEDED.Error()->STR    #Always "context deadline exceeded"
DEADLINE_EXCEEDED.Timeout()->true #
DEADLINE_EXCEEDED.
 Temporary()->true                #

context.WithValue
 (CONTEXT, KEY, VAL)->CONTEXT2    #Create a CONTEXT's child with a specific Value()
