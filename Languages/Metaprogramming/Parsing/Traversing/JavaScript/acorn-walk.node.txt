
              
   ACORN-WALK  
              



VERSION ==>                       #6.2.0

AST FORMAT ==>                    #ESTree

NODE.type                         #Include abstract types: 'Expression', 'Statement', 'Pattern', 'Function'
                                  #Add: 'ForInit' (first part of "for in|of")
                                  #Do not include: 'ExportSpecifier', 'ClassBody', 'SwitchCase'

                                  #There is possibility to customize the walker:
                                  #  - i.e. whether children nodes should be walked through or not, or direction of walking
                                  #  - I don't see much reason except performance, so I do not documented here
                                  #  - for information it's done with:
                                  #     - WALK.simple|ancestors() third argument
                                  #     - WALK.make|recursive()
                                  #     - WALK.findNode*() second-to-last argument

                                  #There is also possibility to keep state during walking:
                                  #  - but can also just use a close for that, so not documented here
                                  #  - for information it's done with:
                                  #     - WALK.simple|ancestors() fourth argument
                                  #     - WALK.findNode*() last argument

WALK.simple(NODE, OBJ)            #Walk through AST tree and call OBJ.TYPE(CHILD_NODE) for each CHILD_NODE whose type is TYPE.
                                  #Start with leaves, end with root.
WALK.ancestors(NODE, OBJ)         #Same but instead call OBJ.TYPE(CHILD_NODE, ANCESTOR_NODE_ARR)
                                  #ANCESTOR_NODE_ARR starts with ancestor and ends with CHILD_NODE.
WALK.full[Ancestors](NODE, FUNC)  #Same as two previous except using FUNC(CHILD_NODE, ...) for any CHILD_NODE

WALK.findNodeAt                   #Returns OBJ, with OBJ.node, first NODE where:
(NODE[, START_OFFSET[, END_OFFSET #  - NODE.start === START_OFFSET (unless null|undefined)
[,'TYP'|FUNC('TYP',NODE)->BOOL]]])#  - NODE.end === END_OFFSET (unless null|undefined)
->OBJ                             #  - 'TYPE'|FUNC()->true (can set OFFSET null and only set that test)
                                  #Returns undefined if none found
WALK.findNodeAround(NODE, OFFSET,
'TYP'|FUNC('TYP',NODE)->BOOL)->OBJ#Same with NODE.start <= OFFSET <= NODE.end (OFFSET cannot be null|undefined)
WALK.findNodeAfter(NODE, OFFSET,
'TYP'|FUNC('TYP',NODE)->BOOL)->OBJ#Same with NODE.start >= OFFSET (OFFSET cannot be null|undefined)
WALK.findNodeBefore(NODE, OFFSET,
'TYP'|FUNC('TYP',NODE)->BOOL)->OBJ#Same with OFFSET <= NODE.end (OFFSET cannot be null|undefined)
