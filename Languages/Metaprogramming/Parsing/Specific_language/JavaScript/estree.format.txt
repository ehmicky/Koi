
          
   ESTREE  
          



VERSION ==>                       #Last commit 26/01/2018
                                  #JavaScript AST standard


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             BASIC             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTIONAL VALUES ==>               #Are either defined or null

any                               #NODE:
                                  #  - type STR
                                  #  - [loc] (position in source code):
                                  #     - [source STR]
                                  #     - start|end:
                                  #        - line NUM (1-indexed)
                                  #        - column NUM (0-indexed)
                                  #It is root type, abstract:
                                  #  - all other types inherit from it
                                  #  - all redefine type STR, except if abstract types themselves

EXPR                              #EXPR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          STATEMENTS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FILE                              #Type 'Program':
                                  #  - sourceType 'script|module'
                                  #  - body STATEMENT|MODULE_DECLARATION_ARR
STATEMENT                         #

EXPR_STATEMENT                    #Statement with single EXPR.
                                  #Child of STATEMENT, type 'ExpressionStatement':
                                  #  - expression EXPR
'use strict';                     #Child of EXPR_STATEMENT, type 'Directive':
                                  #  - expression LITERAL
                                  #  - directive STR
;                                 #Empty statement, with only semicolon
                                  #Child of STATEMENT, type 'EmptyStatement'
{...}                             #Child of STATEMENT, type 'BlockStatement':
                                  #  - body STATEMENT_ARR

// COMMENT
/* COMMENT */                     #Ignored


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         DECLARATIONS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DECLARATION                       #Child of STATEMENT. Parent of VARIABLE_DECLARATION, FUNCTION_DECLARATION, CLASS_DECLARATION,
                                  #TS_TYPE_ALIAS_DECLARATION, TS_ENUM_DECLARATION, TS_INTERFACE_DECLARATION,
                                  #TS_MODULE_DECLARATION

QUAL VAR = VAL, ...               #Child of DECLARATION, type 'VariableDeclaration':
                                  #  - declarations VARIABLE_DECLARATOR_ARR (type 'VariableDeclarator'):
                                  #     - id PATTERN
                                  #     - [init EXPR]
                                  #  - kind 'var|let|const'

lvalues                           #PATTERN. Parent of IDENTIFIER, MEMBER_EXPR, OBJ_PATTERN, ARR_PATTERN, REST_ELEMENT,
                                  #ASSIGNMENT_PATTERN, TS_PARAMETER_PROPERTY

VAR                               #Child of EXPR+PATTERN, type 'Identifier':
                                  #  - name STR

OBJ.VAR                           #Child of EXPR+PATTERN, type 'MemberExpression':
OBJ[VAL]                          #  - object EXPR|SUPER (OBJ)
                                  #  - property EXPR (VAL) or IDENTIFIER (VAR)
                                  #  - computed true (VAL) or false (VAR)

{VAR, ...}                        #Child of PATTERN, type 'ObjectPattern' (deconstruction):
{...OBJ, ...}                     #  - properties ARR of either:
                                  #      ASSIGNMENT_PROPERTY (VAR), child of PROPERTY with differences:
                                  #        - value PATTERN
                                  #        - kind always 'init'
                                  #        - method always false
                                  #      REST_ELEMENT (...OBJ)

[VAR,...]                         #Child of PATTERN, type 'ArrayPattern' (deconstruction):
                                  #  - elements PATTERN_ARR (null for parse array element)

...VAR                            #Child of PATTERN, type 'RestElement' (when setting):
                                  #  - argument PATTERN
...VAR                            #Type 'SpreadElement' (when getting):
                                  #  - argument EXPR

VAR = VAL                         #Child of PATTERN, type 'AssignmentPattern' (default values)
                                  #  - left PATTERN
                                  #  - right EXPR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           FUNCTIONS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FUNC                              #FUNCTION:
                                  #  - [id IDENTIFIER] (null if anonymous)
                                  #  - params PATTERN_ARR
                                  #  - body FUNCTION_BODY
                                  #  - generator BOOL
                                  #  - async BOOL
...                               #Child of BLOCK_STATEMENT, type 'FunctionBody':
                                  #  - body STATEMENT|DIRECTIVE_ARR

[async] function [*]FUNC(...){}   #Child of FUNCTION+DECLARATION, type 'FunctionDeclaration'
[async] function [*][FUNC](...){} #Child of FUNCTION+EXPR, type 'FunctionExpression'
[async] [FUNC]() => {...}         #Child of FUNCTION+EXPR, type 'ArrowFunctionExpression':
                                  #  - no id
                                  #  - params PATTERN_ARR
                                  #  - body BLOCK_STATEMENT or (if () => VAL) EXPR
                                  #  - no generator
                                  #  - expression BOOL (if () => VAL)

return [VAL]                      #Child of STATEMENT, type 'ReturnStatement':
                                  #  - [argument EXPR]

yield [*] [VAL]                   #Child of EXPR, type 'YieldExpression':
                                  #  - [argument EXPR]
                                  #  - delegate BOOL (if *)

await VAL                         #Child of EXPRT, type 'AwaitExpression':
                                  #  - argument EXPR

FUNC(...)                         #Child of EXPR, type 'CallExpression':
                                  #  - callee EXPR|SUPER|IMPORT (FUNC)
                                  #  - arguments EXPR|SPREAD_ELEMENT_ARR
new FUNC(...)                     #Child of EXPR, type 'NewExpression':
                                  #  - callee EXPR (FUNC)
                                  #  - arguments EXPR|SPREAD_ELEMENT_ARR

@DECORATOR                        #Type 'Decorator':
                                  #  - expression EXPR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          STRUCTURES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


if (...) {...} [else {...}]       #Child of STATEMENT, type 'IfStatement':
                                  #  - test EXPR
                                  #  - consequent STATEMENT
                                  #  - [alternate STATEMENT]

switch (...) {...}                #Child of STATEMENT, type 'SwitchStatement':
                                  #  - discriminant EXPR
                                  #  - cases SWITCH_CASE_ARR (type 'SwitchCase'):
                                  #     - [test EXPR] (case's VAL) (null if default case)
                                  #     - consequent STATEMENT_ARR (if two following cases, the first one has no consequent)

while (...) {...}                 #Child of STATEMENT, type 'WhileStatement':
                                  #  - test EXPR
                                  #  - body STATEMENT

do {...} while (...)              #Child of STATEMENT, type 'DoWhileStatement':
                                  #  - test EXPR
                                  #  - body STATEMENT

for (...;...;...) {...}           #Child of STATEMENT, type 'ForStatement':
                                  #  - [init VARIABLE_DECLARATION|EXPR]
                                  #  - [test EXPR]
                                  #  - [update EXPR]
                                  #  - body STATEMENT

for (VAR in VAL) {...}            #Child of STATEMENT, type 'ForInStatement':
                                  #  - left VARIABLE_DECLARATION|PATTERN
                                  #  - right EXPR
                                  #  - body STATEMENT

for [await] (VAR of VAL) {...}    #Child of STATEMENT, type 'ForOfStatement':
                                  #  - left VARIABLE_DECLARATION|PATTERN
                                  #  - right EXPR
                                  #  - body STATEMENT
                                  #  - await BOOL

break [LABEL]                     #Child of STATEMENT, type 'BreakStatement':
                                  #  - [label IDENTIFIER]
continue [LABEL]                  #Child of STATEMENT, type 'ContinueStatement':
                                  #  - [label IDENTIFIER]

with (...) {...}                  #Child of STATEMENT, type 'WithStatement':
                                  #  - object EXPR
                                  #  - body STATEMENT

LABEL: ...                        #Child of STATEMENT, type 'LabeledStatement':
                                  #  - label IDENTIFIER
                                  #  - body STATEMENT


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          EXCEPTIONS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


try { ... }                       #Child of STATEMENT, type 'TryStatement':
[catch (...) {...}]               #  - block BLOCK_STATEMENT
[finally {...}]                   #  - [handler CATCH_CLAUSE] (type 'CatchClause'):
                                  #     - param [PATTERN]
                                  #     - body BLOCK_STATEMENT
                                  #  - [finalizer BLOCK_STATEMENT]
throw VAL                         #Child of STATEMENT, type 'ThrowStatement':
                                  #  - argument EXPR

debugger                          #Child of STATEMENT, type 'DebuggerStatement'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         NATIVE TYPES          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


STR|BOOL|NUM|BIGINT|null|REGEXP   #Child of EXPR, type 'Literal':
                                  #  - value STR|BOOL|NUM|BIGINT|null|REGEXP
                                  #  (REGEXP only)
                                  #  - regex:
                                  #     - pattern STR
                                  #     - flags STR
undefined                         #Considered a VAR

TAG`...`                          #Child of EXPR, type 'TaggedTemplateExpression':
                                  #  - tag EXPR
                                  #  - quasi TEMPLATE_LITERAL
`...`                             #Child of EXPR, type 'TemplateLiteral':
                                  #  - quasis TEMPLATE_ELEMENT_ARR (non-${} parts), type 'TemplateElement':
                                  #     - tail BOOL (if last one, including empty "" if ends with ${})
                                  #     - value:
                                  #        - [cooked STR] (null if contain escape sequences)
                                  #        - raw STR
                                  #  - expressions EXPR_ARR (${} parts)

{VAR[: VAL], ...}                 #Child of EXPR, type 'ObjectExpression':
{[VAL]: VAL}                      #  - properties ARR of either:
{...OBJ}                          #      PROPERTY (type 'Property')
{                                 #        - key EXPR (LITERAL if {[VAR]: VAL} or {NUM: VAL})
  [@DECORATOR]                    #        - value EXPR
  FUNC(...){...}                  #        - kind 'init|get|set' (get|set are for getters|setters)
}                                 #        - method BOOL (if FUNC)
                                  #        - shorthand BOOL (if { VAR })
                                  #        - computed BOOL
                                  #        - decorators DECORATOR_ARR
                                  #      SPREAD_ELEMENT (...OBJ)

[VAL...]                          #Child of EXPR, type 'ArrayExpression':
                                  #  - elements EXPR2|SPREAD_ELEMENT_ARR (null for sparse ARR elements)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           OPERATORS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


-VAL
+VAL
!VAL
~VAL                              #Child of EXPR, type 'UnaryExpression':
typeof VAL                        #  - operator '-|+|!|~|typeof|void|delete'
void VAL                          #  - prefix BOOL (whether before VAL, i.e. always true)
delete VAL                        #  - argument EXPR

++VAR                             #Child of EXPR, type 'UpdateExpression':
VAR++                             #  - operator '--|++'
--VAR                             #  - prefix BOOL
VAR--                             #  - argument EXPR

VAL == != === !== < <= > >= <<    #Child of EXPR, type 'BinaryExpression':
>> >>> + - * / % ** | ^ & in      #  - operator '==|!=|===|!==|<|<=|>|>=|<<|>>|>>>|+|-|*|/|%|**|||^|&|in|instanceof'
instanceof VAL2                   #  - left EXPR
                                  #  - right EXPR

VAR = += -= *= /= **= %= <<= >>=  #Child of EXPR, type 'AssignmentExpression':
>>>= |= ^= &= VAL                 #  - operator '=|+=|-=|*=|/=|**=|%=|<<=|>>=|>>>=||=|^=|&='
                                  #  - left PATTERN or (only on older JavaScript engines) EXPR
                                  #  - right EXPR

VAL || && VAL2                    #Child of EXPR, type 'LogicalExpression':
                                  #  - operator '|||&&'
                                  #  - left EXPR
                                  #  - right EXPR

VAL ? VAL2 : VAL3                 #Child of EXPR, type 'ConditionalExpression':
                                  #  - test EXPR
                                  #  - alternate EXPR
                                  #  - consequent EXPR

VAL,...                           #Child of EXPR, type 'SequenceExpression':
                                  #  - expressions EXPR_ARR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             CLASS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[@DECORATOR]                      #Type 'Class':
class [CLASS] [extends PARENT] {  #  - [id IDENTIFIER]
  [@DECORATOR]                    #  - [superClass EXPR]
  [static] FUNC(...) {...}        #  - body CLASS_BODY, type 'ClassBody':
}                                 #     - body METHOD_DEFINITION_ARR, type 'MethodDefinition':
                                  #        - key EXPR
                                  #        - value FUNCTION_EXPR
                                  #        - kind 'constructor|method|get|set'
                                  #        - static BOOL
                                  #        - computed BOOL
                                  #        - decorators DECORATOR_ARR
                                  #  - decorators DECORATOR_ARR
class CLASS ... {}                #Child of CLASS+DECLARATION, type 'ClassDeclaration'
class [CLASS] ... {}              #Child of CLASS+EXPR, type 'ClassExpression'

new.target                        #Child of EXPR, type 'MetaProperty':
                                  #  - meta IDENTIFIER (new)
                                  #  - property IDENTIFIER (target)

this                              #Child of EXPR, type 'ThisExpression'

super                             #Type 'Super'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            MODULES            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


import|export ...                 #MODULE_DECLARATION
{VAR [as VAR2]}                   #Inside import|export. MODULE_SPECIFIER:
                                  #  - local IDENTIFIER (VAR2)

export QUAL VAR = VAL             #Child of MODULE_DECLARATION, type 'ExportNamedDeclaration':
export function VAR() {}          #  (if export QUAL VAR or export FUNC)
export { VAR [as VAR2|default] }  #  - [declaration DECLARATION]
export {}                         #  (empty ARR unless export {...})
export ... from "MDL"             #  - specifiers EXPORT_SPECIFIER_ARR, child of MODULE_SPECIFIER, type 'ExportSpecifier':
                                  #     - local IDENTIFIER (VAR)
                                  #     - exported IDENTIFIER (VAR2|default)
                                  #  (if export ... from "MDL")
                                  #  - [source LITERAL] ("MDL")

export default VAL                #Child of MODULE_DECLARATION, type 'ExportDefaultDeclaration':
                                  #  - declaration (VAL) one of:
                                  #     - EXPR
                                  #     - [ANONYMOUS_]FUNCTION|CLASS_DECLARATION
                                  #        - "ANONYMOUS": same type, but id null
export * from "MDL"               #Child of MODULE_DECLARATION, type 'ExportAllDeclaration':
                                  #  - source LITERAL ("MDL")

import ... from "MDL"             #Child of MODULE_DECLARATION, type 'ImportDeclaration':
                                  #  - source LITERAL ("MDL")
                                  #  - specifiers MODULE_SPECIFIER_ARR among:
import { VAR [as VAR2|default] }  #      IMPORT_SPECIFIER, type 'ImportSpecifier':
                                  #        - imported IDENTIFIER (VAR)
                                  #        - local IDENTIFIER (VAR2, same as VAR by def)
import VAR                        #      IMPORT_DEFAULT_SPECIFIER, type 'ImportDefaultSpecifier':
                                  #        - local IDENTIFIER (VAR)
import * as VAR                   #      IMPORT_NAMESPACE_SPECIFIER, type 'ImportNamespaceSpecifier':
                                  #        - local IDENTIFIER (VAR)
import "MDL"                      #
import {}                         #Those have empty ARR as specifiers

import("MDL")
import(STR).VAR                   #Just a CALL_EXPRESSION


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        TYPESCRIPT/FLOW        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TYPE                              #Type 'typeAnnotation' (TypeScript|Flow)
                                  #TYPE_VAR or TYPE_EXPR

VAR: TYPE
function (VAR: TYPE): TYPE {}
...VAR: TYPE                      #TYPE assertion
{...}: TYPE                       #On IDENTIFIER|FUNC|REST_ELEMENT|OBJ_PATTERN|ARR_PATTERN|ASSIGNMENT_PATTERN|CLASS_PROPERTY:
[...]: TYPE                       #  - [typeAnnotation TYPE_ANNOTATION]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           TSESTREE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


BABEL/PARSER ==>                 ##Some differencess:
                                 ##  - 'TSClassImplements|TSInterface' -> 'TSExpressionWithTypeArguments'
                                 ##  - TS_FUNC_TYPE|TS_CONSTRUCTOR_TYPE|TS_METHOD_SIGNATURE|TS_CALL_SIGNATURE_DECLARATION|TS_CONSTRUCT_SIGNATURE_DECLARATION:
                                 ##     - 'params' -> 'parameters'
                                 ##     - 'returnType' -> 'typeAnnotation'
                                 ##  - TS_TYPE_PARAMETER.name: IDENTIFIER -> STR

TYPE                              #TS_TYPE. TypeScript TYPE
                                  #Parent of TS_TYPE_REFERENCE, TS_PARENTHESIZED_TYPE, TS_TYPE_QUERY, TS_CONDITIONAL_TYPE, TS_INFER_TYPE, TS_TYPE_OPERATOR,
                                  #TS_INDEXED_ACCESS_TYPE, TS_MAPPED_TYPE, TS_*_KEYWORD, TS_LITERAL_TYPE, TS_OPTIONAL_TYPE,
                                  #TS_TYPE_LITERAL, TS_EXPRESSION_WITH_TYPE_ARGUMENTS, TS_FUNCTION_TYPE, TS_CONSTRUCTOR_TYPE,
                                  #TS_THIS_TYPE, TS_ARRAY_TYPE, TS_REST_TYPE, TS_TUPLE_TYPE, TS_UNION_TYPE, TS_INTERSECTION_TYPE,
                                  #TS_TYPE_PREDICATE

TYPE_VAR                          #TS_ENTITY_NAME. Child of IDENTIFIER, for a TS_TYPE.
                                  #TYPE_VAR identifier itself.

TYPE_VAR                          #Child of TS_TYPE, type 'TSTypeReference':
                                  #  - typeName TS_ENTITY_NAME
                                  #TYPE_VAR reference.

(TYPE)                            #Child of TS_TYPE, type 'TSParenthesizedType':
                                  #  - typeAnnotation TS_TYPE

type TYPE_VAR = TYPE2             #Child of DECLARATION, type 'TSTypeAliasDeclaration':
                                  #  - id IDENTIFIER
                                  #  - typeAnnotation TS_TYPE

typeof VAR                        #Child of TS_TYPE, type 'TSTypeQuery':
                                  #  - exprName TS_ENTITY_NAME

TYPE extends TYPE2 ? TYPE3 : TYPE4#Child of TS_TYPE, type 'TSConditionalType':
                                  #  - checkType TS_TYPE (TYPE)
                                  #  - extendsType TS_TYPE (TYPE2)
                                  #  - trueType TS_TYPE (TYPE3)
                                  #  - falseType TS_TYPE (TYPE4)
infer TYPE                        #Child of TS_TYPE, type 'TSInferType':
                                  #  - typeParameter TS_TYPE_PARAMETER

keyof TYPE
unique symbol                     #Child of TS_TYPE, type 'TSTypeOperator':
readonly TYPE[]                   #  - typeAnnotation TS_TYPE
readonly [TYPE,...]               #  - operator: 'keyof|unique|readonly'

TYPE[TYPE2]                       #Child of TS_TYPE, type 'TSIndexedAccessType':
                                  #  - objectType TS_TYPE (TYPE)
                                  #  - indexType TS_TYPE (TYPE2)

{ [T in TYPE]: TYPE2 }            #Child of TS_TYPE, type 'TSMappedType':
                                  #  - typeParameter TS_TYPE_PARAMETER (T in TYPE)
                                  #  - [typeAnnotation TS_TYPE] (TYPE2)
                                  #readonly|optional are not supported by current parsers (but do not throw)

any                               #Child of TS_TYPE, type 'TSAnyKeyword'
unknown                           #Child of TS_TYPE, type 'TSUnknownKeyword'
never                             #Child of TS_TYPE, type 'TSNeverKeyword'
undefined                         #Child of TS_TYPE, type 'TSUndefinedKeyword'
null                              #Child of TS_TYPE, type 'TSNullKeyword'
void                              #Child of TS_TYPE, type 'TSVoidKeyword'
boolean                           #Child of TS_TYPE, type 'TSBooleanKeyword'
number                            #Child of TS_TYPE, type 'TSNumberKeyword'
string                            #Child of TS_TYPE, type 'TSStringKeyword'
bigint                            #Child of TS_TYPE, type 'TSBigIntKeyword'
symbol                            #Child of TS_TYPE, type 'TSSymbolKeyword'
object                            #Child of TS_TYPE, type 'TSObjectKeyword'

BOOL|NUM|STR|BIGINT               #Child of TS_TYPE, type 'TSLiteralType':
                                  #  - literal LITERAL

{ VAR?[: TYPE],... }
{ [T in TYPE]?: TYPE2 }           #On IDENTIFIER|TS_PROPERTY_SIGNATURE|TS_MAPPED_TYPE|TS_METHOD_SIGNATURE|TS_DECLARE_METHOD:
(VAR?[: TYPE],...) => TYPE2       #  - [optional BOOL]

[TYPE?,...]                       #Child of TS_TYPE, type 'TSOptionalType':
                                  #  - typeAnnotation TS_TYPE

[const] enum ENUM {}              #Child of DECLARATION, type 'TSEnumDeclaration':
                                  #  - [const BOOL]
                                  #  - id IDENTIFIER (ENUM)
                                  #  - members TS_ENUM_MEMBER_ARR
  NAME [= EXPR]                   #Type 'TSEnumMember':
                                  #  - id IDENTIFER|LITERAL
                                  #  - [initializer EXPR]

TS_TYPE_ELEMENT                   #TS_PROPERTY_SIGNATURE|TS_INDEX_SIGNATURE|TS_METHOD_SIGNATURE|TS_CALL_SIGNATURE_DECLARATION|TS_CONSTRUCT_SIGNATURE_DECLARATION

{ ... }                           #Child of TS_TYPE, type 'TSTypeLiteral':
                                  #  - members TS_TYPE_ELEMENT_ARR
  VAR: TYPE [= VAL]               #Type 'TSPropertySignature':
                                  #  - key EXPR
                                  #  - [computed BOOL] (when key is [STR])
                                  #  - [typeAnnotation TS_TYPE_ANNOTATION]
                                  #  - [initializer EXPR]
  [VAR: TYPE2]: TYPE              #Type 'TSIndexSignature':
                                  #  - parameters IDENTIFIER_ARR (VAR: TYPE2, with single element, an IDENTIFIER with type assertion)
                                  #  - [typeAnnotation TS_TYPE_ANNOTATION] (TYPE)

class CLASS {}                    #
  constructor                     #Child of PATTERN. Type 'TSParameterProperty'
   (QUAL VAR[?]: TYPE,...)        #  - parameter PATTERN
                                  #  - [accessibility 'public|protected|private']
                                  #  - [readonly BOOL]
  public|protected|private VAR    #On CLASS_PROPERTY|CLASS_METHOD|TS_DECLARE_METHOD:
                                  #  - [accessibility 'public|protected|private']
abstract class ...                #On CLASS_DECLARATION:
                                  #  - [abstract BOOL]
  abstract VAR|FUNC()             #On CLASS_PROPERTY|CLASS_METHOD|TS_DECLARE_METHOD:
                                  #  - [abstract BOOL]

interface INTERFACE {}            #Child of DECLARATION, type 'TSInterfaceDeclaration':
                                  #  - id IDENTIFIER
                                  #  - [extends TS_EXPRESSION_WITH_TYPE_ARGUMENTS_ARR]
                                  #  - body TS_INTERFACE_BODY (type 'TSInterfaceBody'):
                                  #     - body TS_TYPE_ELEMENT_ARR

implements|extends PARENT         #Child of TS_TYPE, type 'TSClassImplements|TSInterface'
                                  #  - expression EXPR (PARENT)
                                  #On CLASS:
                                  #  - implements TS_EXPRESSION_WITH_TYPE_ARGUMENTS_ARR

OBJ_TYPE.VAR                      #Child of TS_ENTITY_NAME, type 'TSQualifiedName':
                                  #  - left TS_ENTITY_NAME
                                  #  - right IDENTIFIER


([...]VAR[?]: TYPE,...) => TYPE2  #Child of TS_TYPE, type 'TSFunctionType':
                                  #  - [params IDENTIFIER|REST_ELEMENT_ARR] (parameters, including type assertions)
                                  #  - [returnType TS_TYPE_ANNOTATION]
new (...) => TYPE2                #Child of TS_TYPE, type 'TSConstructorType':
                                  #  - [params IDENTIFIER|REST_ELEMENT_ARR] (parameters, including type assertions)
                                  #  - [returnType TS_TYPE_ANNOTATION]
{ FUNC(...)[: TYPE2] }            #Type 'TSMethodSignature':
                                  #  - key EXPR
                                  #  - [computed BOOL] (when key is [STR])
                                  #  - [params IDENTIFIER|REST_ELEMENT_ARR]
                                  #  - [returnType TS_TYPE_ANNOTATION]
{ (...)[: TYPE2], ... }           #Type 'TSCallSignatureDeclaration':
                                  #  - [params IDENTIFIER|REST_ELEMENT_ARR]
                                  #  - [returnType TS_TYPE_ANNOTATION]
{ new (...)[: TYPE2] }            #Type 'TSConstructSignatureDeclaration':
                                  #  - [params IDENTIFIER|REST_ELEMENT_ARR]
                                  #  - [returnType TS_TYPE_ANNOTATION]

this                              #Child of TS_TYPE, type 'TSThisType'
                                  #When used as return value type

TYPE[]                            #Child of TS_TYPE, type 'TSArrayType':
                                  #  - elementType TS_TYPE
...ARR_TYPE                       #Child of TS_TYPE, type 'TSRestType':
                                  #  - typeAnnotation TS_TYPE
                                  #for [...ARR_TYPE]
[TYPE[?],...]                     #Child of TS_TYPE, type 'TSTupleType':
                                  #  - elementTypes TS_TYPE_ARR

{ readonly ...[: TYPE],... }      #On CLASS_PROPERTY|TS_MAPPED_TYPE|TS_PROPERTY_SIGNATURE|TS_INDEX_SIGNATURE:
                                  #  - [readonly BOOL]

TYPE | TYPE2                      #Child of TS_TYPE, type 'TSUnionType':
                                  #  - types TS_TYPE_ARR
TYPE & TYPE2                      #Child of TS_TYPE, type 'TSIntersectionType':
                                  #  - types TS_TYPE_ARR

type TYPE<T...> = ...
class CLASS<T...> {}
interface INTERFACE<T,...> {}
[new] <T...>(...) => ...          #Type 'TSTypeParameterDeclaration':
{ FUNC<T...>(...): ... }          #  - params TS_TYPE_PARAMETER_ARR
{ [new] <T...>(...): ... }        #On FUNCTION_DECLARATION|FUNCTION_EXPRESSION|ARROW_FUNCTION_EXPRESSION|CLASS_DECLARATION|CLASS_EXPRESSION|CLASS_METHOD|OBJECT_METHOD
function <T,...>(...) {...}       #TS_TYPE_ALIAS_DECLARATION|TS_INTERFACE_DECLARATION|
<T,...>(...) => ...               #TS_FUNCTION_TYPE|TS_CONSTRUCTOR_TYPE|TS_DECLARE_FUNCTION|TS_DECLARE_METHOD|TS_METHOD_SIGNATURE|
{ FUNC<T,...>(...) {} }           #TS_CALL_SIGNATURE_DECLARATION|TS_CONSTRUCT_SIGNATURE_DECLARATION:
declare function <T,...>(...)     #  - [typeParameters TS_TYPE_PARAMETER_DECLARATION_ARR] (<...>)
 T [extends TYPE3][ = TYPE4]      #Type 'TSTypeParameter':
 T in TYPE3                       #  - [name IDENTIFIER]
                                  #  - [constraint TYPE3]
                                  #  - [default TYPE4]
TYPE<TYPE2_VAR,...>               #Type 'TSTypeParameterInstantiation':
                                  #  - params TS_TYPE_ARR
                                  #On CALL_EXPRESSION|NEW_EXPRESSION|TS_TYPE_REFERENCE|TS_EXPRESSION_WITH_TYPE_ARGUMENT:
                                  #  - [typeParameters TS_TYPE_PARAMETERS_INSTANTIATION]
extends PARENT<...>               #On CLASS_DECLARATION|CLASS_EXPRESSION:
                                  #  - [superTypeParameters TS_TYPE_PARAMETERS_INSTANTIATION]

<TYPE>VAL                         #Child of EXPR, type 'TSTypeAssertion':
<const>VAL                        #  - typeAnnotation TS_TYPE
                                  #  - expression EXPR
VAL as TYPE                       #Child of EXPR, type 'TSAsExpression':
VAL as const                      #  - typeAnnotation TS_TYPE
                                  #  - expression EXPR

...: TYPE                         #Child of TYPE_ANNOTATION, type 'TSTypeAnnotation'
                                  #  - typeAnnotation TS_TYPE
                                  #TypeScript TYPE assertion

function(...): TYPE2 {}
declare function FUNC(): TYPE2
(...): TYPE2 => ...
{ FUNC(...): TYPE2 {} }           #On FUNCTION_DECLARATION|FUNCTION_EXPRESSION|METHOD_DEFINITION|TS_DECLARE_FUNCTION|ARROW_FUNCTION_EXPRESSION|OBJECT_METHOD:
class { FUNC(...): TYPE2 }        #  - [returnType TYPE_ANNOTATION]

VAL!                              #Child of EXPR, type 'TSNonNullExpression':
                                  #  - expression EXPR

var|let VAR!: TYPE                #On VARIABLE_DECLARATOR|CLASS_PROPERTY:
class ... { VAR!: TYPE; ... }     #  - [definite BOOL]

VAR is TYPE                       #Child of TS_TYPE, type 'TSTypePredicate':
                                  #  - parameterName IDENTIFIER|TS_THIS_TYPE
                                  #  - typeAnnotation TS_TYPE_ANNOTATION

namespace NAMESPACE {}            #Child of DECLARATION, type 'TSModuleDeclaration':
declare module "MODULE" {}        #  - id IDENTIFIER|LITERAL
declare module "MODULE"           #  - body TS_MODULE_BLOCK (NAMESPACE) or TS_MODULE_DECLARATION (module|global):
declare global {}                 #  - [global BOOL]
                                  #TS_MODULE_BLOCK:
                                  #  - body STATEMENT_ARR

declare QUAL VAR ...
declare function FUNC() {}
declare enum ...
declare class ...
declare interface ...
declare namespace ...
declare type ...                  #On VARIABLE_DECLARATION|FUNCTION_DECLARATION|CLASS_DECLARATION|
declare module ...                #TS_TYPE_ALIAS_DECLARATION|TS_ENUM_DECLARATION|TS_INTERFACE_DECLARATION|TS_MODULE_DECLARATION:
declare global ...                #  - [declare BOOL]

declare [async] function FUNC()   #Child of DECLARATION, type 'TSDeclareFunction'. Like FUNCTION_DECLARATION except no body
class ... { FUNC() }              #Type 'TSDeclareMethod'. Like METHOD_DEFINITION except no body

export = VAL                      #Child of STATEMENT, type 'TSExportAssignment':
                                  #  - expression EXPR
[export] import VAR = NAMESPACE   #Child of STATEMENT, type 'TSImportEqualsDeclaration':
[export] import VAR = require(STR)#  - id IDENTIFIER
                                  #  - moduleReference TS_ENTITY_NAME (NAMESPACE) or TS_EXTERNAL_MODULE_REFERENCE (require(STR))
                                  #  - [isExport BOOL]
require(STR)                      #Type 'TSExternalModuleReference':
                                  #  - expression EXPR
                                  #Only in import VAR = require(STR)

export as namespace NAME          #Child of STATEMENT, type 'TSNamespaceExportDeclaration':
                                  #  - id IDENTIFIER
