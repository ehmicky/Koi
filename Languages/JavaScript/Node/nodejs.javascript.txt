
          
   NODEJS  
          



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         COMMAND LINE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PURPOSE ==>                                     #Execute JavaScript code server-side
                                                #Based on Chrome JavaScript engine V8

VERSION ==>                                     #11.7.0 (current), 10.15.0 (active LTS), 8.15.0 (active LTS), 6.16.0 (maintenance LTS)
                                                #Branches:
                                                #  - "current": latest major version. New one every 0.5 years
                                                #  - LTS: every even-numbered version
                                                #     - when not current anymore, becomes "active LTS" (only bug fixes) for 1.5 years
                                                #     - then "maintainance LTS" (only critical bug fixes) for 1 more year
                                                #  - non-LTS also have a maintainance period of 0.5 years
                                                #For libraries I should support >=6.9.0
                                            NUM*#Means introduced by NUM.*.*

ES6 ==>                                         #Support is documented in JavaScript doc

node[js] [--] [FILE] [FILE_ARGS]                #Command-line
node[js] -e|--eval|-p|--print STR [--] [ARGS]   #nodejs is symlink to node (prefer the later as this is what nvm uses).
                                                #FILE is JavaScript file (def: stdin). Can be - too
                                                #With -e, evaluates STR
                                                #With -p, evaluates STR, and prints last return value.
                                             10*#All CLI flags can use underscores instead of dashes
NODE_OPTIONS=--OPT,... ENVVAR                 8*#Same as using node --OPT ...
--v8-options                                    #Prints available v8 options.
process.allowedNodeEnvironmentFlags          10*#Read-only SET with all available NODE_OPTIONS

-i
--interactive                                   #Enters REPL even if stdin does not come from a terminal
-c
--check                                         #Run-dry (syntax check)

--completion-bash                               #Output Bash completion script (for CLI flags)

#!/usr/bin/env node                             #Shabang to execute a Node file directly with ./FILE

npm                                             #Node packet manager (see doc)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          EVENT QUEUE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


clear|setTimeout|Interval(...)                  #Like DOM ones (see DOM doc), but extra members
clear|setImmediate(...)                       9*#
ID.[un]ref()->ID                                #Yield the macrotask (see JavaScript doc)
ID.hasRef()->BOOL                            11*#
ID.refresh()->ID                             10*#Reset the counter

queueMicrotask(FUNC())                       11*#Add a new microtask (see JavaScript doc)
                                             11*#Experimental (throw warning)
process.nextTick(FUNC()[, ...])                 #Add a new microtask (see JavaScript doc)
                                                #As opposed to queueMicrotask(), always processed before other microtasks,
                                                #including when calling itself recursively.,


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ASYNC HOOKS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TASK_ID                                       8*#Microtask ID
                                              8*#Is incrementing counter, with top-level microtask having ID 1
                                              8*#Specifics:
                                              8*#  - ID 0 means executed from C++, not JavaScript
                                              8*#  - PROMISE report parent microtask's, not their actual microtask ID, unless
                                              8*#    an enabled HOOK exists
                                              8*#  - async|await (but PROMISE) report parent microtask's, not their actual microtask ID
RESOURCE                                      8*#Any resource, firing 0, 1 or several microtasks (depends on RESOURCE_TYPE)
                                              8*#RESOURCE properties depend on RESOURCE_TYPE. They might not be populated yet in init()
RESOURCE_TYPE                                 8*#Can be:
                                              8*#  - TickObject: process.nextTick()
                                              8*#     - properties: callback FUNC, [args 'VAL'_ARR]
                                              8*#  - Immediate: setImmediate()
                                              8*#     - properties: _onImmediate FUNC, [_argv 'VAL'_ARR]
                                              8*#  - Timeout: setTimeout|setInterval()
                                              8*#     - properties:
                                              8*#        - _onTimeout FUNC
                                              8*#        - _idleTimeout NUM
                                              8*#        - _repeat null|NUM: same but null with setTimeout()
                                              8*#        - [_timerArgs 'VAL'_ARR]
                                              8*#  - TIMERWRAP: setTimeout|setInterval()
                                              8*#  - PROMISE:
                                              8*#     - on:
                                              8*#        - new Promise(FUNC), Promise.resolve|reject()
                                              8*#        - PROMISE.then|catch|finally(FUNC), await PROMISE
                                              8*#        - calling an async FUNC
                                              8*#     - properties:
                                              8*#        - promise PROMISE
                                              8*#        - isChainedPromise BOOL:
                                              8*#           - true if resolving|rejecting with another PROMISE2
                                              8*#           - including await PROMISE, resolve|reject(PROMISE) or
                                              8*#             return PROMISE in then|catch|finally()
                                              8*#  - TTYWRAP: console.*
                                              8*#     - properties: callback FUNC, [args 'VAL'_ARR]
                                              8*#  - SIGNALWRAP: OS signal
                                              8*#  - FSEVENTWRAP, FSREQWRAP, GETADDRINFOREQWRAP, GETNAMEINFOREQWRAP, HTTPPARSER,
                                              8*#    JSSTREAM, PIPECONNECTWRAP, PIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,
                                              8*#    STATWATCHER, TCPCONNECTWRAP, TCPSERVER, TCPWRAP, UDPSENDWRAP, UDPWRAP,
                                              8*#    WRITEWRAP, ZLIB, SSLCONNECTION, PBKDF2REQUEST, RANDOMBYTESREQUEST, TLSWRAP: others

executionAsyncId()->TASK_ID                   8*#Current microtask
triggerAsyncId()->PARENT_TASK_ID              8*#Parent microtask, i.e. caller

createHook(OPTS)->HOOK                        8*#Fires callbacks on new microtasks|resources, using OPTS:
                                              8*#  - init(TASK_ID, RESOURCE_TYPE, PARENT_TASK_ID, RESOURCE):
                                              8*#     - when RESOURCE is initialized.
                                              8*#  - before|after(TASK_ID):
                                              8*#     - before|after each microtask starts|ends
                                              8*#     - since some RESOURCE create no microtasks, or several,
                                              8*#       this might not be called, or be called several times
                                              8*#  - destroy(TASK_ID): when RESOURCE is destroyed
                                              8*#  - resolve(TASK_ID):
                                              8*#     - when a PROMISE is resolved|rejected, including to another PROMISE2
                                              8*#     - only for RESOURCE_TYPE PROMISE
                                              8*#Exceptions thrown in callbacks are uncaught exceptions, but cannot be handled.
                                              8*#Doing async operations (i.e. creating microtasks) inside callbacks:
                                              8*#  - can cause infinite recursion
                                              8*#  - this includes console.*(), which can be replaced e.g. by
                                              8*#    fs.writeSync(1, util.format(VAL))
HOOK.enable|disable()->HOOK                   8*#HOOK callbacks will only be fired in enabled (disabled by def)

new AsyncResource('RESOURCE_TYPE'[, OPTS])    9*#Custom RESOURCE
                                              9*#OPTS:
                                              9*#  - triggerAsyncId PARENT_TASK_Id (def: executionAsyncId())
                                              9*#  - requireManualDestroy BOOL: if false (def), calls emitDestroy() when object
                                              9*#    is garbage collected
ASYNCRESOURCE.runInAsyncScope
 (FUNC[, THIS][, ...ARGS])                    9*#This is automatically create a new TASK_ID and call 'before|after' events
ASYNCRESOURCE.emitDestroy()                   9*#
ASYNCRESOURCE.asyncId()->TASK_ID              9*#
ASYNCRESOURCE.triggerId()->PARENT_TASK_ID     9*#

node --no-force-async-hooks-checks            9*#Do not do extra runtime checks related to async hooks


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         DEBUGGER (V8)         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


HOW TO DEBUG ==>                              7*#There are three ways: v8 (node --inspect), node --debug and Electron
                                              7*#Prefer node --inspect

node --inspect[-brk][=[HOST:]PORT] ...        7*#Launches node ... but with debugger server
                                              7*#Must then:
                                              7*#  - go to chrome://inspect and click on a link to open devtools
                                              7*#  - or directly click on the Node symbol in devtools
                                              7*#Also forwards console messages
                                              7*#If -brk, will put breakpoint at first line
                                              7*#Unless -brk, breakpoints are ignored until a client is connected
                                              7*#HOST: def 127.0.0.1
                                              7*#PORT: def 9229, 0 for "any available"
                                              7*#Difference with node --debug:
                                              7*#  - only for Chrome devtools as client
                                              7*#  - but optimized for it, with more features (ES6, async stack, profiling, source
                                              7*#    maps, workspaces, blackboxing, etc.)
                                              7*#Note that child processes must be started with node --inspect as well
                                              7*#Prefered way to debug


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        DEBUGGER (OLD)         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


node --debug[-brk][=PORT] ...                   #Same as node --inspect, but for any client, and exposed on localhost:PORT
                                                #Def PORT: 5858
                                                #Can add --debug flag on the fly to existing node process by sending SIGUSR1
                                                #Should prefer node --inspect when Chrome client is available

node debug -p PID                               #Start debugger CLI client.
node debug URL                                  #Commands:
                                                #  - breakpoints are specified by:
                                                #    - putting breakpoint; in FILE
                                                #    - sb([[FILE, ]LINE_NUM]): by def, current line
                                                #    - sb('FUNC()')
                                                #    - cb(...): clear breakpoints
                                                #  - [un]watch(VAL): watch points
                                                #  - watchers: list watch points
                                                #  - c: continue
                                                #  - n: next
                                                #  - s: step in
                                                #  - o: step out
                                                #  - pause: pause running code
                                                #  - run|restart|kill
                                                #  - repl: open console to execute in current context
                                                #  - bt: call stack
                                                #  - list(NUM): list NUM next lines
                                                #  - scripts: list all FILE
node debug ...                                  #Same as node --debug-brk + node debug

node-inspector                                 ##Start Chrome developer tools debugger client proxy
                                               ##How:
                                               ##  - start debugger server, i.e. node --debug[-brk]
                                               ##  - on same machine, start debugger proxy:
                                               ##     - node-inspector
                                               ##     - if /usr/bin/node not available, make a symlink from /usr/bin/node
                                               ##  - on any machine, visit http://HOST:PORT/debug?port=PORT2 (see options)
                                               ##Uses 'rc' module for configuration
                                               ##Node package (0.12.10).
--web-port PORT                                ##Def: 8080. Port to be listened.
--web-host HOST                                ##Def: 0.0.0.0
--debug-port PORT2                             ##Def: 5858. Listening port.
--save-live-edit                               ##Live edit change files directly
--hidden '["REGEXP",...]'                      ##Files to hide
--no-preload                                   ##Faster boot-time
--inject                                       ##When using debugger extensions
--stack-trace-limit                            ##Def: 50
--ssl-key|cert                                 ##FILE

node-debug ...                                 ##Part of node-inspector package.
                                               ##Same as node --debug-brk ..., followed by node-inspector, then open browser.
                                               ##Same arguments with also:
--[no-]debug-brk                               ##Stop on first line
--cli                                          ##Don't open browser
--nodejs "[...]"                               ##Pass options to NodeJS process


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      DEBUGGER (ELECTRON)      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


IRON-NODE ==>                                  ##Another way to debug is to use Electron.
JAM3 DEVTOOL ==>                               ##Those two apps do this
                                               ##There are many problems I encountered with those, so I prefer node --inspect


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ERROR             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ERROR                                           #Are v8 errors, i.e. what follows is shared by Chrome
                                                #See JavaScript doc for more information, including on async stack trace

Error.captureStackTrace(OBJ[, FUNC])            #Adds OBJ.stack, unless already exists
                                                #Automatically done by ERROR, i.e. Error.captureStackTrace(ERROR) is useless
                                                #If FUNC, stops stack frame at FUNC
--stack-trace-limit=NUM
Error.stackTraceLimit                           #Def: 10

Error.prepareStackTrace                         #When set with FUNC(ERROR, CALL_ARR)->'STACK', override how OBJ.stack is get
                                                #Default is something along the lines of:
                                                #  ERROR.name: ERROR.message
                                                #    at [new] CALL.getFunctionName() [as methodName] (LOCATION)
                                                #    at <anonymous> (LOCATION)
                                                #    at eval (PARENT_CALL, <LOCATION2>)
                                                #    at native
                                                #    at uknown location
                                                #    ...
                                                #LOCATION is:
                                                #  (CALL.getFileName():CALL.getLineNumber():CALL.getColumnNumber())
CALL.getFileName()->'FILENAME'                  #undefined if eval
CALL.getEvalOrigin()->'FILENAME'                #Same but when using eval() (or related)
CALL.getScriptNameOrSourceURL()->'FILENAME'     #Same but when using eval() (or related) with //# sourceURL comment
CALL.getFunction()->FUNC                        #undefined in 'strict mode'
CALL.getFunctionName()->'[CLASS.]FUNC|null'     #
CALL.getMethodName()->'FUNC'|null               #
CALL.getThis()->THIS                            #undefined in 'strict mode'
CALL.getTypeName()->STR|null                    #THIS's TYPE
CALL.getLine|ColumnNumber()->NUM                #
CALL.isTopLevel()->BOOL                         #
CALL.isEval()->BOOL                             #From eval() (or related)
CALL.isNative()->BOOL                           #From native C++ code
CALL.isConsructor()->BOOL                       #Using new


NERROR                                          #Node internal error, as opposed to standard JavaScript ERROR
                                                #Often filesystem errors, including permissions
NERROR.code                                     #NERROR_NAME
                                                #Most start with E* and are cross-OS. Some start with W* and are Windows-specific.
OS.constants.errno.NERROR_NAME                  #NERROR_NUM
                                                #OS-specific
NERROR.errno                                    #-NERROR_NUM (as negative number)
UTIL.getSystemErrorName(-NERROR_NUM)
 ->NERROR_NAME                                9*#
NERROR.syscall                                  #STR (e.g. 'access')
NERROR.path|dest                                #Src|dest 'PATH', if any
NERROR.address|port                             #HOST|PORT, if any
NERROR.info                                     #Extra info, if any


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            EVENTS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EventEmitter                                    #Base class of all objects receiving events
                                                #'EVENT' can be a SYM
                                                #Events are emitted synchronously
EVENTEMITTER.on('EVENT', FUNC)->EVENTEMITTER    #
EVENTEMITTER.once('EVENT', FUNC)->EVENTEMITTER  #
EVENTEMITTER.prepend[Once]Listener(...)         #Like on[ce](...) but adds to beginning of listeners list, not end
EVENTEMITTER.removeListener('EVENT', FUNC)
  ->EVENTEMITTER                                #
EVENTEMITTER.off(...)                        10*#Same
EVENTEMITTER.removeAllListeners(['EVENT'])
  ->EVENTEMITTER                                #
EVENTEMITTER.emit('EVENT'[, ...])->BOOL         #True if there were listeners
                                                #If 'EVENT' is 'error' and there are not listeners, throws instead

EVENTEMITTER.listeners(EVENT)->FUNC_ARR         #
EVENTEMITTER.rawListeners(EVENT)->FUNC_ARR    9*#Same but also with what Node.js adds, e.g. once() wrapper
EVENTEMITTER.listenerCount(EVENT)->NUM          #Slightly faster than EVENTEMITTER.listeners(STR).length
EVENTEMITTER.eventNames()->'EVENT'_ARR          #
EVENTEMITTER.setMaxListeners(NUM)->EVENTEMITTER #0 for unlim. Beyond max, does not stops adding listeners, only print warning.
EVENTEMITTER.getMaxListeners()->NUM             #
EVENTEMITTER.defaultMaxListeners                #10
EVENTEMITTER.on                                 #Event when a new event handler is added or removed.
 ("new|removeListener", FUNC(EVENT, FUNC2))     #Added|removed FUNC2 might still [not] be in EVENTEMITTER.listeners(EVENT)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GLOBAL             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GLOBAL VARIABLES ==>                            #  - global|GLOBAL|root: global scope reference
                                                #  - clear|setImmediate|Interval|Timeout, Object, URL, console, encodeURI, etc.: JavaScript globals
                                                #  - module, require, exports, __filename, __dirname: module-related globals
                                                #  - process, url: core modules
                                                #  - Buffer: core modules property
                                                #  - all core modules (e.g. http): in CLI only


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            MODULE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


MODULE ==>                                      #Can be:
                                                #  - Node JavaScript file: executes it
                                                #  - JSON file: same as module.exports = JSON.parse('JSON')
                                                #  - machine code file:
                                                #     - must be *.node
                                                #     - loaded by dlopen()
                                                #     - exports available in void init(Handle<Object> exports)
                                                #     - must use libraries: V8, libuv, others
                                                #     - use node-gyp for packaging/compilation
                                                #     - on Windows, must first npm install -g windows-build-tools as admin
                                                #Decides type with file extension
                                                #Done runtime. See JavaScript modules doc for more info
module                                          #Current MODULE, i.e. file being loaded.
                                                #There are builtin modules, which are the chapters of this doc.

node -r STR                                     #Load file STR:
node --require STR                              #  - 'ID': core module
require(STR)                                    #  - 'FILE' (absolute or relative)
                                                #  - 'DIR' (absolute or relative):
                                                #     - DIR/package.json, using main 'PATH' (relative to DIR)
                                                #     - DIR/index.EXT
                                                #  - 'MODULE':
                                                #     - i.e. anything that does not start with / or .
                                                #     - tries require('DIR2/MODULE'), with DIR2 [.../[..]]./node_modules/
                                                #Paths can omit extensions: .mjs, .js, .json, .node
                                                #If not found, throw ERROR with code "MODULE_NOT_FOUND"

require.resolve(STR[, OPTS])->'ID'              #How [MODULE.]require(STR) would resolve
                                              8*#OPTS:
                                              8*#  - paths 'DIR'_ARR: alternative directories to look into
                                              8*#    Their [.../[..]]./node_modules will always be searched
require.resolve.paths(STR)->'DIR'_ARR         8*#Directories that would be looked into when [MODULE.]require(STR) would resolve
createRequireFromPath('PATH')->require(STR)  10*#Returns a require() function that will load PATH.join(['${__dirname}/PATH', STR])

require.cache[ID]                               #[MODULE.]require(STR) cache (i.e. modules are only loaded once).
                                                #ID is require.resolve(STR) result
                                                #Builtins are not cached.
                                                #Can delete it to remove cache, or restart current code.

MODULE.require                                  #Reference to require

CIRCULAR DEPENDENCIES ==>                       #If a module require its parent:
                                                #  - it will receive its parent current module.exports, even though its parent is not finished loading
                                                #  - it will not execute its parent, since its parent is already loading

SCOPE ==>                                       #Variables are local to each file, except for MODULE.exports
exports                                         #Return value (by reference if OBJ) when required. Must be assigned sync.
                                                #Can be any type.
MODULE.exports                                  #Reference to exports.
                                                #Must be used when want to overwrite, i.e. exports = VAL (as opposed to exports.VAR = VAL)
this                                            #Is, according to ENVVAR NODE_MODULE_CONTEXTS:
                                                #  - 0 (def): module.exports
                                                #  - 1: global

require.main                                    #Root file (first to have been loaded), as MODULE
process.mainModule                              #Same but updated if root file changed at runtime
MODULE.parent|children                          #MODULE[_ARR]|null
MODULE.loaded                                   #False for the first time the file is loaded (i.e. sync)
                                                #True for async functions

__filename                                      #Current file absolute path.
MODULE.filename                                 #Reference to __filename
MODULE.id                                       #For core modules, a string like "buffer". For others, module.filename.
__dirname                                       #Current file absolute dirname

require('module').builtinModules              9*#List of system 'MODULE'_ARR (e.g. 'http') including internal ones

CLI ==>                                         #require.main, process.mainModule: undefined
                                                #MODULE.loaded: false
                                                #__filename, __dirname: undefined (but MODULE.filename is '$PWD/repl')
                                                #MODULE.id: 'repl'
                                                #exports is undefined (but not MODULE.exports)

import|export ...                             8*#ES modules
                                              8*#Must:
                                              8*#  - use node --experimental-modules
                                              8*#     - --experimental-vm-modules for use in VM
                                              8*#  - use FILE.mjs instead of FILE.js
                                              8*#     - .mjs can require .js, .js can require .mjs only with import()
                                              8*#Loading:
                                              8*#  - use same algorithm to find module
                                              8*#  - PATH are URL (only file: supported), i.e. need to be URI encoded
                                              8*#No CommonJS, i.e. no require|module|exports|__filename|__dirname
                                              8*#Not supported yet: import(), no import.meta

DIFFERENCES ==>                                 #Difference from require(), import and import()
                                                #Steps:
                                                #  - resolution (all): resolve PATH to absolute PATH
                                                #  - read file (all)
                                                #  - wrapping:
                                                #     - require(): wrap in anonymous function, with global variables as
                                                #       arguments, i.e.
                                                #       (function(exports, require, module, __filename, __dirname){...})(...)
                                                #     - import[()]: no wrapper, is top-level function
                                                #  - parsing:
                                                #     - require(), import(): normal
                                                #     - import: also find symbols from named imports (import { VAR }) and link
                                                #       them
                                                #  - running|evaluating (all)
                                                #  - cache return value (all)
                                                #Parse-time vs runtime:
                                                #  - require(), import(): everything done runtime
                                                #  - import:
                                                #     - everything done parse-time (except running), running then done runtime
                                                #     - i.e.:
                                                #        - cannot do e.g. export { VAL as [DYNAMIC_VAR] }
                                                #        - also better static analysis
                                                #        - VAR are implicitely const
                                                #Sync vs async:
                                                #  - require(): sync
                                                #  - import: async:
                                                #     - same behavior as if it was sync, since it is parse-time
                                                #     - but means that might go over several loops of the event loop
                                                #  - import(): async with PROMISE
                                                #Top-level:
                                                #  - require(), import(): does not have to be top-level
                                                #  - import: must be top-level

node --loader FILE.mjs                          #Customize the behavior of "import"
                                                #FILE must export OBJ.resolve('PATH', 'URL', FUNC2)->{ url, format }:
                                                #  - called instead of normal import behavior
                                                #     - normal import behavior still available as FUNC2
                                                #  - 'PATH' is relative path
                                                #  - 'URL' is absolute base. Is a URL, e.g. file: protocol with filesystem
                                                #  - url is resolved absolute URL
                                                #  - format can be 'esm' (.mjs), 'cjs' (.js), 'json' (.json), 'addon' (.node),
                                                #    'builtin' (core module) or 'dynamic'
                                                #When returning format 'dynamic', the loading process is customized as well,
                                                #and FILE must export async OBJ.dynamicInstantiate(URL)->{exports, execute(EXPORTS)}:
                                                #  - URL is the resolved absolute URL returned by OBJ.resolve()
                                                #  - exports is the 'VAR'_ARR of exported variables
                                                #  - execute() must call EXPORTS.VAR.get()|set(VAL) to set the value of the
                                                #    exported variables


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        STRING_DECODER         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new StringDecoder(['ENCODING'])                 #Returns DECODER. Def: "utf8"
                                                #Does TDBUFFER -> STR translation
DECODER.write|end(TDBUFFER)->STR                #Adds to current string. If:
                                                #  - it still contains incomplete chars, returns ''
                                                #  - otherwise, resets and returns current string
DECODER.end()->STR                              #Returns current string, but does not reset.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BUFFER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Buffer                                          #Child of Uint8Array (including constructors), with extra methods:
                                                #  - mixes in DATAVIEW flexibility (of changing current type)
                                                #  - better serialization: toString(), toJSON()
                                                #  - can decode STR according to different encodings
                                                #  - can swap bytes, compare bytes
                                                #  - some performance improvements, and some convenience functions

[S][T][D][U][A]BUFFER                           #Means BUFFER|[STR]|[TYPED_ARR]|[DATAVIEW]|[UINT8ARR]|[ARRBUFFER]
BVAL                                            #UINT (like Uint8Array), STR, BUFFER or UINT8ARR

constants.MAX_LENGTH                            #Max BUFFER.length
constants.MAX_STRING_LENGTH                     #Max STR.length

Buffer.isEncoding('ENCODING')->BOOL             #
transcode(UBUFFER, "ENCODING", "ENCODING2")
 ->BUFFER2                                      #Returns BUFFER2 with ENCODING2, based on UBUFFER with ENCODING

new TYPED_ARR(BUFFER)                           #Copy, not reference
                                                #Each single BUFFER BVAL -> a single TYPED_ARR VAL
Buffer.allocUnsafe[Slow](NUM)->BUFFER           #Similar to new TYPED_ARR(NUM)
                                                #Max size is require("buffer").kMaxLength (64 bits on 64 bits architecture)
                                                #Unless "Slow", will reuse preallocated buffer from a pool (i.e. faster)
                                                #if NUM <= Buffer.poolSize (def: 8192) / 2
Buffer.alloc(NUM[, NUM2|SBUFFER[, 'ENCODING']]) #Like Buffer.allocUnsafeSlow(NUM).fill(NUM2|SBUFFER, 'ENCODING') (def: \0),
 ->BUFFER                                       #for security reasons
                                                #If node --zero-fill-buffers, will fill with \0 even Buffer.allocUnsafe[Slow]()
Buffer.from(NUM_ARR)->BUFFER                    #Similar to new TYPED_ARR(NUM_ARR)
Buffer.from(ARRBUFFER, ...)->BUFFER             #Similar to new TYPED_ARR(ARRBUFFER, ...)
Buffer.from(STR[, 'ENCODING'])->BUFFER        8*#
Buffer.from(BUFFER)->BUFFER                     #Copies
Buffer.concat(UBUFFER_ARR[, UINT])->BUFFER      #Similar to Array.prototype.concat.call(null, ...) but with UBUFFER_ARR
                                                #Providing final length UINT can speed up performance.
BUFFER.buffer                                   #Inherited from UINT8ARR. Reference to underlying ARRBUFFER

Buffer.byteLength(STDABUFFER[, 'ENCODING'])->NUM#Similar to TYPED_ARR.byteLength

Buffer.isBuffer(VAL)->BOOL                      #
BUFFER.equals(UBUFFER2)->BOOL                   #
BUFFER.compare(UBUFFER2[, 4 NUM])->-1|0|1       #Sort comparison. NUMs are UBUFFER2 start|end and UBUFFER start|end
Buffer.compare(UBUFFER, UBUFFER2)->-1|0|1       #Same as BUFFER.compare(UBUFFER2)

BUFFER.toString(['ENCODING'[, ...])->STR        #Like:
                                                #  let decoder = new StringDecoder('ENCODING');
                                                #  decoder.write(BUFFER.slice(...));
                                                #  return decoder.end()
BUFFER.toJSON()                                 #Returns as '{"type": "Buffer", "data": [...]}'

BUFFER.slice(...)->BUFFER                       #Like [TYPED_]ARR, but returns a reference
BUFFER.[last]indexOf(..., 'ENCODING')->NUM      #Like [TYPED_]ARR but:
BUFFER.includes(..., 'ENCODING')->BOOL          #  - VAL is BVAL
BUFFER.fill(...[, 'ENCODING'])                  #  - can use 'ENCODING'

BUFFER.write(STR[, UINT[, UINT2[, 'ENCODING']]])#Writes STR on BUFFER
 ->NUM                                          #UINT is offset (def: 0) and UINT2 is length (def: all)
BUFFER.copy(UBUFFER2[, 3 UINT])->UINT4          #Copies bytes from BUFFER at position UINT to UBUFFER2 from position UINT2 to
                                                #UINT3 (def: UBUFFER2.length)

BUFFER.readFloat|Double|[U]Int8|16|32]LE|BE
(UINT[, BOOL])->VAL                             #Similar to DATAVIEW.get|set* but:
BUFFER.writeFloat|Double|[U]Int8|16|32LE|BE     #  - use LE|BE instead of BOOL argument
(VAL, UINT[, BOOL])                             #  - if BOOL true, faster but no validation of UINT buffer overflow
BUFFER.read[U]Int[LE|BE](UINT, UINT2[, BOOL])
BUFFER.write[U]Int[LE|BE](VAL,UINT,UINT2[,BOOL])#Same but specifies [U]Int size UINT2 (up to 48)

BUFFER.swap16|32|64()->BUFFER                   #Swaps every couple of 1|2|4 bytes. Return value is reference


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STREAM             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SVAL                                            #UBUFFER or (if setEncoding() called) STR, or null if nothing to read
OBJECT MODE ==>                                 #SVAL is any VAL (except null):
                                                #  - encoding is ignored
                                                #  - both ISTREAM and OSTREAM must be in objectMode
                                                #  - ISTREAM.read() NUM argument is ignored (always 1)

ISTREAM ==>                                     #Input stream. Actually called Readable
                                                #Is an ASYNC_ITERABLE
new STREAM.Readable([OBJ])                      #OBJ:
                                                #  - encoding 'ENCODING' (def: null, i.e. uses BUFFER)
                                                #  - objectMode BOOL: see above
                                                #  - highWaterMark NUM:
                                                #     - buffer size (def: 16kb)
                                                #     - on ISTREAM: data available for read but not read yet
                                                #     - on OSTREAM: data not flushed yet
                                                #     - if buffer full, waits
ISTREAM.on("readable", FUNC())                  #New chunks available, or just before "end"
ISTREAM.on("data", FUNC(SVAL))                  #Each new chunk available. Firing FUNC() consumes that chunk.
                                                #Not fired if ISTREAM is empty
ISTREAM.read([UINT])->SVAL                      #Like on("data") but:
                                                #  - sync: waits until chunk available (i.e. prefer on("data"))
                                                #  - specify (max) chunk size UINT (def: all)
                                                #  - SVAL is null if ISTREAM empty
ISTREAM.on("end", FUNC())                       #When all chunks have been read
ISTREAM.on("close", FUNC())                     #When underlying fd is closed (not all ISTREAM close)
ISTREAM.on("error", FUNC(ERROR))                #
ISTREAM.pause|resume()                          #Makes it stop|resume emit "data" events.
ISTREAM.isPaused()                              #
ISTREAM.setEncoding('ENCODING')                 #
ISTREAM.readable                             11*#BOOL
ISTREAM.readableHighWaterMark                 9*#NUM
ISTREAM.readableLength                        9*#NUM. Number of bytes not read yet
ISTREAM.readableFlowing                         #Can be:
                                                #  - null: when all data has been consumed, or stream has not started been read yet
                                                #  - true: when stream is being read, i.e. after on('data')
                                                #  - false: when stream is being paused, i.e. after pause()
ISTREAM.pipe(OSTREAM[, { end: BOOL }])->OSTREAM #Same as ISTREAM.on("data", sval => OSTREAM.write(SVAL))
                                                #If BOOL true (def), call OSTREAM.end() on ISTREAM.on('end|error') (except on stdout|stderr)
ISTREAM.unpipe([OSTREAM])                       #Stops pipe() (def: all)
ISTREAM.unshift(SVAL)                           #Put last SVAL read back in ISTREAM
ISTREAM.destroy([ERROR])                      8*#

OSTREAM ==>                                     #Output stream. Actually called Writable
STREAM.Writable([OBJ])                          #Constructor for OSTREAM. OBJ members are:
                                                #  - decodeStrings BOOL: if true (def), decodes to BUFFER before
                                                #    calling underlying OSTREAM._write()
                                                #  - objectMode BOOL: see above
                                                #  - highWaterMark NUM: see above
OSTREAM.write(SVAL[, 'ENCODING'[,FUNC()]])->BOOL#Writes chunks.
                                                #FUNC() is fired when buffered + flushed.
                                                #BOOL:
                                                #  - false if data cannot be buffered anymore (i.e. buffer is full)
                                                #  - i.e. should wait for OSTREAM.once('drain') before writing again
OSTREAM.end(SVAL[, 'ENCODING'[, FUNC()]])
 ->OSTREAM                                      #Same but for final chunk. FUNC is the finish event handler
OSTREAM.destroy([ERROR])                      8*#
OSTREAM.setDefaultEncoding('ENCODING')->OSTREAM #
OSTREAM.writable                             11*#BOOL
OSTREAM.writableHighWaterMark                 9*#NUM
OSTREAM.writableLength                        9*#NUM. Number of bytes not flushed yet
OSTREAM.[un]cork()                              #cork() forces buffering to disk, uncork() flushes
                                                #To do when writing a lot of small I/O, to make them all flush at once.
OSTREAM.on("close", FUNC())                     #Like ISTREAM
OSTREAM.on("finish", FUNC())                    #Fired when end() done
OSTREAM.on("[un]pipe", FUNC(ISTREAM))           #Fired by ISTREAM.[un]pipe()
OSTREAM.on("error", FUNC(ERROR))                #

finished(ISTREAM|OSTREAM[,FUNC(ERROR)])      10*#Resolved on:
 ->PROMISE                                   10*#  - ISTREAM|OSTREAM: 'close', destroy()
                                             10*#  - ISTREAM: 'end'
                                             10*#  - OSTREAM: 'finish'
                                             10*#  - REQ|RES: 'complete', underlying stream 'finish'
                                             10*#Rejected on:
                                             10*#  - most: 'error', premature 'close', or destroy(ERROR)
                                             10*#  - REQ|RES: 'abort'
ON-FINISHED(REQ|RES, FUNC(ERROR, REQ|RES))     ##Fires FUNC() when it ended because of:
ON-FINISHED.isFinished(REQ|RES)->BOOL          ##  - an ERROR, i.e. IOSTREAM events 'error'
                                               ##  - request|response sent, i.e. IOSTREAM events 'end', 'finish', 'close'
                                               ##Does not work well with CONNECT HTTP method nor Upgrade [C]
                                               ##Prefer Stream.finished()
                                               ##on-finished Node module (2.3.0)
pipeline(ISTREAM|OSTREAM[_ARR]...            10*#Like finished(STREAM.pipe(STREAM2).pipe(...), ...)
 [, FUNC(ERROR)])->PROMISE                   10*#Also if one STREAM errors then other STREAM are closed (with STREAM.abort|destroy())

IOSTREAM ==>                                    #Implement both ISTREAM and OSTREAM. Actually called either:
                                                #  - STREAM.Duplex
                                                #  - STREAM.Transform:
                                                #     - same but where there is a correlation between input and output (ex: crypto, but not HTTP)
                                                #     - only semantic

INHERITING STREAMS ==>                          #To create STREAM child classes, just inherit them and reimplement functions
                                                #_read(), _write[v](), _transform() or _flush() (see online doc), without calling them directly.


process.stdout|err|in                           #OSTREAM|ISTREAM with extra member:
                                                #  - isTTY BOOL: if true, will be a READSTREAM|WRITESTREAM
                                                #Unless used as a pipe, are sync (unless other STREAM which are async by def).


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              TTY              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


READSTREAM                                      #Child of TCPSOCKET, but without destroy(), connect event nor *address*
                                                #Instantiated by process.stdin if process.stdin.isTTY true
                                                #Will keep process alive until destroyed.
READSTREAM.isRaw                                #BOOL: raw or character device.
READSTREAM.bytesRead                            #So far
READSTREAM.setRawMode(BOOL)                     #

WRITESTREAM                                     #Same but for process.stdout|stderr
WRITESTREAM.columns|rows                        #UINT
WRITESTREAM.getColorDepth([process.env])->NUM 9*#Number of bits per channel, 1|4|8|24
WRITESTREAM.on("resize", FUNC())                #

isatty(FD_INT)                                  #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           READLINE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


INTERFACE                                       #Read CLI input and pipe it to output
                                                #I.e. when using stdin and stdout on a terminal, will create a CLI
                                                #If Node prompt is already there, will double output on input
createInterface(OBJ)->INTERFACE                 #OBJ:
                                                #  - input ISTREAM
                                                #  - output OSTREAM
                                                #  - terminal BOOL (def: OSTREAM.isTTY): use READSTREAM|WRITESTREAM
                                                #  - completer(STR[, FUNC(ERROR, ARR)])[->ARR]:
                                                #     - used to tab completion
                                                #     - can be sync or async
                                                #     - ARR: [STR2_ARR, STR]
                                                #        - STR is original string
                                                #        - STR2_ARR are possible matches. If only one left, autocompletes
                                                #  - historySize NUM (def: 30) (0 for none)
                                                #  - removeHistoryDuplicates BOOL (def: false): new history lines that are duplicate
                                                #    of a previous one removes that older one
                                                #  - prompt STR (def: '> ')
                                                #  - crlfDelay NUM (def: 100, cannot be lower): if input reads \r and \n
                                                #    successively but more than NUMms apart, treat them as two newlines, not one
INTERFACE.close()                               #Called by ISTREAM.end(), CTRL-C and CTRL-D.
INTERFACE.on("close", FUNC())                   #

INTERFACE.on("line", FUNC(STR))                 #Fired each time a line is read from ISTREAM.
INTERFACE[Symbol.asyncIterator]              11*#I.e. can do for (const STR of INTERFACE)
INTERFACE.write(STR[, OBJ])                     #Prints STR on OSTREAM or, if OBJ { ctrl|meta|shift: true, name: STR },
                                                #on CTRL|META|SHIFT-STR
                                                #Be careful as it will be read by ISTREAM, if ISTREAM and OSTREAM point to same thing (e.g. terminal).
INTERFACE.setPrompt(STR)                        #Change OBJ.prompt (see above)
INTERFACE.prompt([BOOL])                        #Write in beginning of current OSTREAM line the OBJ.prompt
                                                #If line was not empty, will place cursor at character number UINT of prompt (def) or, if true, at end of line.
INTERFACE.question(STR, FUNC(STR2))             #Replace current prompt by STR on OSTREAM, and fires FUNC(STR2) on line event instead of normal line event.
INTERFACE.pause|resume()                        #Pause|resume ISTREAM.
                                                #ISTREAM still accept input but buffers it, and reads it once resumed.
                                                #Also fired by SIGCONT or SIGTSTP (CTRL-Z)
                                                #resume() is also called by write(), prompt() and question()
INTERFACE.on("pause|resume", FUNC())            #
INTERFACE.on("SIGNINT|TSTP|CONT", FUNC())       #

clearScreenDown(WRITESTREAM)                    #
clearLine(WRITESTREAM, NUM)                     #Can be 0 (entire line) or -1|1 (to the left|right of cursor)
cursorTo|moveCursor(WRITESTREAM, NUM, NUM2)     #Move cursor absolutely|relatively
emitKeypressEvents(WRITESTREAM[, INTERFACE])    #Enable OSTREAM.on('keypress')


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             REPL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


start([OBJ])->REPLSERVER                        #Creates a REPLSERVER:
                                                #  - INTERFACE made specifically for Node.js command line:
                                                #     - line event handler is eval()
                                                #     - core modules are loaded by default
                                                #  - this is what is used by node with no FILE.
                                                #If NODE_NO_READLINE envvar is defined to 1, readline is not used.
                                                #OBJ members are:
                                                #  - input|output|terminal|prompt:
                                                #     - like createInterface()
                                                #     - but with defaults process.stdin|stdout
                                                #  - eval(STR, OBJ, FILENAME, FUNC(ERROR, STR)):
                                                #     - function to perform after each line
                                                #        - if ERROR is new Recoverable(ERROR), keep prompt ongoing (e.g. for multiline input)
                                                #     - def is async. wrapper of eval():
                                                #        - STR is command
                                                #        - OBJ is current context (global object)
                                                #        - STR2 is current module.filename
                                                #  - useColors BOOL (def: same as terminal)
                                                #     - can also use ENVVAR NODE_DISABLE_COLORS=1
                                                #  - useGlobal BOOL (def: false): use current context, and not local one
                                                #  - ignoreUndefined BOOL (def: false): if true, doesn't print output when it is undefined
                                                #  - writer FUNC(VAL): output printing, def. is util.inspect
                                                #  - replMode:
                                                #     - can be:
                                                #        - REPL_MODE_STRICT: "use strict"
                                                #        - REPL_MODE_SLOPPY: inverse
                                                #     - def is ENVVAR NODE_REPL_MODE 'sloppy|strict' (def: 'sloppy')
                                                #  - breakEvalOnSigint BOOL: if true (def: false), stops on CTRL-C
REPLSERVER.on("reset", FUNC())                  #When ".clear" is called.
REPLSERVER.on("exit", FUNC())                   #
REPLSERVER.context                              #Global environment, as OBJ
                                                #REPL command ".clear" resets it.


REPL COMMANDS ==>                               #
_                                               #Last expression evaluated
_error                                        9*#Last uncaught exception
.save FILE                                      #Save all input so far to FILE
.load FILE                                      #Input FILE
.exit
CTRL-D                                          #
.break
CTRL-C                                          #
.editor                                         #Start multiline session
.help                                           #
REPLSERVER.defineCommand('STR', OBJ|FUNC(...))  #Custom commands called .STR
                                                #OBJ:
                                                #  - action(...)
                                                #     - can use REPLSERVER.displayPrompt([BOOL]) to reshow the prompt
                                                #       using INTERFACE.prompt(BOOL)
                                              9*#     - can call REPLSERVER.clearBufferedCommand() to cancel itself
                                                #  - help STR

NODE_REPL_HISTORY ENVVAR                        #Def: ~/.node_repl_history
NODE_REPL_HISTORY_SIZE ENVVAR                   #Def: 1000


node --experimental-repl-await               10*#Allow using await top-level


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             DGRAM             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


createSocket(STR|OPTS[, FUNC(BUFFER, OPTS)])    #OPTS:
 ->UDPSOCKET                                    #  - type "udp4|6"
                                                #  - reuseAddr BOOL (def: false): make UDPSOCKET.bind() reuse an address already bound
                                              8*#  - lookup FUNC (def: DNS.lookup)
                                              8*#  - recvBufferSize|sendBufferSize NUM: in|out buffer size
                                             11*#  - ipv6Only BOOL (def: false)
                                                #STR is OPTS.type
                                                #FUNC is 'message' event handler.
UDPSOCKET.address()                             #{ address, port, family }

UDPSOCKET.bind(OBJ[, FUNC()])                   #Start listening. OBJ:
UDPSOCKET.bind(PORT_NUM[, 'ADDR'][, FUNC()])    #  - port PORT_NUM
                                                #  - address 'ADDR' (def: all available)
                                                #FUNC() is 'listening' event handler
                                                #Program will block until UDPSOCKET.close() is called. Can also use UDPSOCKET.[un]ref()
UDPSOCKET.on("listening", FUNC())               #After bind()
UDPSOCKET.on("message", FUNC(BUFFER, OBJ))      #OBJ is like UDPSOCKET.address()
UDPSOCKET.close([FUNC()])                       #FUNC is close event handler
UDPSOCKET.on("close", FUNC())                   #
UDPSOCKET.on("error", FUNC(ERROR))              #

UDPSOCKET.send                                  #Sends to PORT_NUM, address 'ADDR'.
(SUBUFFER[_ARR][, UINT, UINT2],                 #Payload is first arg, from byte UINT, length UINT2
PORT_NUM, 'ADDR'[, FUNC(ERROR, UINT3)])         #If bind() has not been called, UDPSOCKET gets assigned a random port, and an adress "0.0.0.0"
                                                #When done, fires FUNC: UINT3 is the number of bytes sent.
                                                #Max. SUBUFFER size is the MTU, which must be found with PMTUD.
                                              8*#'ADDR' is optional

UDPSOCKET.setRecv|SendBufferSize(NUM)         8*#
UDPSOCKET.getRecv|SendBufferSize()->NUM       8*#

UDPSOCKET.setBroadcast(BOOL)                    #
UDPSOCKET.setMulticastLoopback(BOOL)            #
UDPSOCKET.setMulticastInterface(STR)          8*#
UDPSOCKET.add|dropMembership(STR[, STR2])       #Routing options
UDPSOCKET.set[Multicast]TTL(UINT)               #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              NET              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


createServer([OBJ, ][FUNC()])->TCPSERVER        #FUNC is 'connection' event handler
                                                #OBJ:
                                                #  - allowHalfOpen BOOL: see below
                                                #  - pauseOnConnect BOOL (def: false): if true, calls TCPSOCKET.pause()
                                                #on 'connection'

TCPSERVER.listen                                #Makes the TCSERVER:
(PORT_NUM|'PORT'[, 'ADDR'][, UINT][, FUNC()])   #  - listen to PORT_NUM|'PORT':
                                                #     - if 0, random port
                                                #     - can fire 'error' event with ERROR.code "EADDRINUSE" if another process
                                                #       already uses this port.
                                                #  - listen to 'ADDR':
                                                #     - def: INADDR_ANY, i.e. any available IP on the machine will work
                                                #  - UINT:
                                                #     - max number of pending connections, i.e. TCP sent SYN packet, but not
                                                #       ACK yet.
                                                #     - refuse connection if above max.
                                                #     - def: 511 (which is pretty ok)
                                                #     - OS limits are determined by sysctl settings like tcp_max_backlog
                                                #       and somaxconn (which is 511 in my system)
                                                #  - FUNC is 'listening' event hander
                                                #Can only be called once.
TCPSERVER.listen('PATH'[, UINT][, FUNC()])      #Same but by explictely creating a socket at 'PATH' (should be in /tmp)
TCPSERVER.listen(OBJ[, UINT][, FUNC()])         #Same but for either:
                                                #  - { fd: UINT }: with file descriptor, not on Windows
                                                #  - TCPSERVER|TCPSOCKET
TCPSERVER.listen(OBJ[, FUNC()])                 #Same with OBJ:
                                                #  - port, host, path, backlog UINT
                                                #  - readableAll|writableAll BOOL (def: false): file permission for the socket
                                             11*#  - ipv6Only BOOL (def: false)
TCPSERVER.on("listening", FUNC())               #Fired when listen() is called.
TCPSERVER.listening                             #BOOL
TCPSERVER.close([FUNC()])                       #Stops the server from accepting new connections:
                                                #  - keeps existing ones
                                                #  - when existing ones have stopped, emits "close" event
                                                #FUNC is 'close' event listener
TCPSERVER.on("close", FUNC())                   #Fired on TCPSERVER.close()
TCPSERVER.address()->OBJ                        #Returns { port: UINT, address STR, family: "IPv4|6" }
                                                #After listen() has been called
TCPSERVER.[un]ref()->TCPSERVER                  #Yield the macrotask (see JavaScript doc)
                                                #listen() call ref(), and stop() or stop event handlers call unref()

TCPSERVER.on("connection", FUNC(TCPSOCKET))     #Fired when a TCP connection is initiated.
TCPSERVER.on("error", FUNC(ERROR))              #Fired when connection problem. Will fire TCPSERVER.close()
TCPSERVER.maxConnections                        #Def: null
                                                #0|null means no limits.
                                                #Above that, will refuse connections.
TCPSERVER.getConnections([FUNC(ERROR, UINT)])   #Number of connections


connect|createConnection(ARGS[, FUNC()])
  ->TCPSOCKET                                   #Same as new Socket(OBJ) followed by TCPSOCKET.connect(...)
TCPSOCKET                                       #IOSTREAM but:
                                                #  - no readable event, read() or unshift() (but still data event)
                                                #  - nothing about piping
                                                #  - close event handler: FUNC(BOOL): true if close because of error
                                                #  - error event handler: FUNC(ERROR)
new Socket([OBJ])                               #OBJ:
                                                #  - fd: UINT
                                                #  - readable|writable BOOL (def: false): only when fd was used
                                                #  - allowHalfOpen BOOL (def: false):
                                                #     - if true, when other socket closes connection, doesn't automatically
                                                #       call end()
                                                #     - which means:
                                                #        - can still write to it (but non-readable)
                                                #        - must manually call end()
TCPSOCKET.connect(ARGS[, FUNC()])               #ARGS:
                                                #  - OBJ:
                                                #     - port PORT_NUM|'PORT'
                                                #     - host 'ADDR'
                                                #     - localAddress|localPort
                                                #     - path 'PATH' (only for UNIX sockets, only option then)
                                                #     (see DNS.lookup())
                                                #     - family 4|6|null
                                                #     - hints
                                              8*#     - lookup (def: DNS.lookup())
                                                #  - HOST[, PORT]
                                                #  - "PATH"
                                                #FUNC() is 'connect' event handler.
TCPSOCKET.pending                               #BOOL: true before connect() or before 'connect' event
TCPSOCKET.connecting                            #BOOL: true after connect() but before 'connect' event
TCPSOCKET.on                                    #Fired after hostname resoution, but before TCP connection.
("lookup", FUNC(ERROR, 'IP', VAL, 'HOST'))      #VAL is family 4|6|null
TCPSOCKET.on("connect", FUNC())                 #
TCPSOCKET.on("ready", FUNC())                 9*#
TCPSOCKET.destroy([ERROR])                      #No more read|write. Only necessary when error happened.
                                                #If ERROR, 'error' event is fired
TCPSOCKET.destroyed                             #BOOL
TCPSOCKET.[un]ref()->TCPSOCKET                  #Like TCPSERVER

TCPSOCKET.setTimeout(UINT[, FUNC()])->TCPSOCKET #Emits timeout event after UINTms of idleness.
                                                #Not emitted after TCPSOCKET is destroyed.
                                                #0 (def) disables.
                                                #By def, timeout handler does not do anything, but can end|destroy()
                                                #FUNC is 'timeout' event handler
                                                #Uses setTimeout(), i.e. done at macrotask level, i.e. might take longer than
                                                #UINTms if long macrotasks.
TCPSOCKET.on('timeout', FUNC())                 #

TCPSOCKET.setKeepAlive(BOOL, UINT)->TCPSOCKET   #Def: false and 0.
                                                #TCP keepalive
TCPSOCKET.setNoDelay(BOOL)->TCPSOCKET           #If false (def), use buffers:
                                                #  - to reduce amount of requests i.e. send data in chunks
                                                #  - more efficient when using a lot of small requests, but can delay them
                                                #  - even disabled, underlying IOSTREAM still use buffer to keep up with
                                                #    high demand
TCPSOCKET.bufferSize                            #Currently buffered size.
                                                #If ever growing, should use pause|resume()
TCPSOCKET.bytesRead|Written                     #So far

TCPSOCKET.address()->OBJ                        #Like TCPSERVER
TCPSOCKET.local|remotePort|Address              #
TCPSOCKET.remoteFamily                          #'IPv4|6'
isIp('ADDR')->0|4|6                             #
isIpv4|6('ADDR')->BOOL                          #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              TLS              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


getCiphers()->STR_ARR                           #All suite of SSL ciphers are [PREFIX-]ALGO[-HASH]
                                                #ALGO: AES128|256, 3DES, DES, Camellia128|256, IDEA, RC4, SEED
                                                #PREFIX:
                                                #  - ECDH[E]-ECDSA|RSA: for AES, DES, RC4
                                                #  - DH[E]-DSS|RSA: for AES, Camellia, SEED
                                                #  - EDH-DSS|RSA: for DES
                                                #  - PSK: for AES, 3DES, RC4
                                                #  - SRP-[DSS|RSA]: for AES, 3DES
                                                #HASH ([-]#ALGO means ALGO with[out] PREFIX SPK|SRP):
                                                #  - sha: -#AES*, Camellia*, RC4, SEED
                                                #  - gcm-sha256: -#AES128
                                                #  - gcm-sha384: -#AES256
                                                #  - sha256: -#AES*
                                                #  - cbc3-sha: -#DES
                                                #  - cbc-sha: IDEA, #AES
                                                #  - md5: RC4 (unless any PREFIX)
                                                #  - ede-cbc-sha: #DES
                                                #Can be changed with node --tls-cipher-list=LIST
TLSSOCKET.getEphemeralKeyInfo()->OBJ            #Gets information about cipher's (only [EC]DH) use of perfect forward secrecy:
                                                #  - type '[EC]DH'
                                                #  - name STR
                                                #  - size NUM

TLS.createSecureContext(OBJ)->SECURECONTEXT     #OBJ:
                                                #  - key STR[_ARR]|BUFFER|OBJ_ARR:
                                                #     - server private key, in PEM format
                                                #     - OBJ is { pem STR|BUFFER, passphrase STR }
                                              7*#        - passphrase is optional
                                                #  - cert STR[_ARR]|BUFFER[_ARR]: server certificate, in PEM format
                                                #  - pfx STR[_ARR]|BUFFER[_ARR]|OBJ_ARR:
                                                #     - key+cert+ca in PFX or PKCS12 format
                                                #     - OBJ is { buf STR|BUFFER[, passphrase STR] }
                                                #  - ca STR[_ARR]|BUFFER[_ARR]:
                                                #        - list of root certificates, in PEM format
                                                #        - by def., well-known root CAs
                                                #           - are known builtin, either:
                                              6*#              - node --use-bundled-ca (def): Mozilla CA store
                                              6*#              - node --use-openssl-ca:
                                              6*#                 - OpensSSL CA store, modified by distributions,
                                              6*#                   can be modified by ENVVARs
                                              7*#                 - can use ENVVAR SSL_CERT_DIR=DIR and SSL_CERT_FILE=FILE
                                              7*#           - can also be augmented with ENVVAR NODE_EXTRA_CA_CERTS=FILE
                                                #        - otherwise, can be used to authorize self-signed certificates
                                                #  - passphrase STR: passphrase used to decrypt the server private key (when a private key is encrypted)
                                                #  - crl STR[_ARR]: CRLs, in PEM format
                                                #  - secureProtocol STR:
                                                #     - "SSLv2|3|TLSv1_[client|server_]method": forces SSL version for client and|or server
                                                #        - no client|server means both
                                                #     - def: uses the best one accepted by client
                                                #  - honorCipherOrder BOOL:
                                                #     - if true, server will choose cipher preference, not client
                                                #     - list is designated by ciphers STR
                                                #     - def: false, but true recommended
                                                #  - ciphers STR:
                                                #     - defaults to "*AES*:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA"
                                                #     - AES are in order: 128 > 256, SHA384 > SHA256, ECDHE > DHE, RSA > ECDSA
                                                #  - sessionIdContext STR:
                                                #     - STR concatened in front of SSL session ID.
                                                #     - if requestCert is true, it is a MD5 nonce. Otherwise, it is "".
                                                #  - ecdhCurve STR (def: "auto"): for ECDH
                                                #  - dhparam STR|BUFFER: for DH
                                              9*#  - clientCertEngine STR: OpenSSL engine
                                                #  - secureOptions { CRYPTO.SSL_OP_*: VAL }: OpenSSL options
                                             11*#  - min|maxVersion 'TLSv1[.1|2]' (def: no restrictions)

TLSSERVER                                       #Child of TCPSERVER:
                                                #  - since it inherits from TCPSERVER, can accept TCP connections, not only SSL ones.
                                                #  - all TLSSERVER will fire for both SSL and normal TCP connections.
                                                #Authorization:
                                                #  - if rejectUnauthorized is true:
                                                #     - non-authorized SSL are still accepted (and communication is encrypted)
                                                #     - but can be checked as non-authorized
                                                #  - certificate check will follow CA chain until CA roots:
                                                #  - authorization also checks the domain in certificate === host being connected
createServer(OBJ[, FUNC(TLSSOCKET)])->TLSSERVER #OBJ:
                                                #  - any SECURECONTEXT.* property
                                                #  - requestCert BOOL (def: false): request authentication (with certificate) of other end (i.e. client)
                                                #  - rejectUnauthorized BOOL (def: true): throw error to other end if cannot authentify it
                                                #  - handshakeTimeout (def: 120000, in ms): when timing out, emits tlsClientError
                                                #  - ALPNProtocols SUBUFFER[_ARR]: list of application protocols that can be used, ordered by priority.
                                                #  - SNICallback('HOST', FUNC(ERROR, OBJ)):
                                                #     - when client asks for SNI, calls it with requested server 'HOST'
                                                #        - if success, must call FUNC(null, OBJ2), where OBJ2 is TLSSOCKET.secureContext
                                                #     - can also use TLSSERVER.addContext('HOST', SECURECONTEXT)
                                                #  - sessionTimeout (def: 300, in sec): expiration for TLS identifiers and session tickets
                                                #  - ticketKeys BUFFER: 48 bytes divided in three 16 bytes parts: prefix, HMAC, AES key
                                                #     - can use TLSSERVER.getTicketKeys()->BUFFER and TLSSERVER.setTicketKeys(BUFFER)
                                                #FUNC is 'secureConnection' event handler
TLSSERVER.setSecureContext(OBJ)              11*#OBJ: any SECURECONTEXT.* property
TLSSERVER.on("secureConnection",FUNC(TLSSOCKET))#Like TCPSERVER.on("connection"), but for SSL.
                                                #Only fired by SSL connections, not normal TCP ones.
TLSSERVER.on
("tlsClientError", FUNC(ERROR, TLSSOCKET))      #See handshakeTimeout
TLSSERVER.on("newSession",FUNC(ID,DATA,FUNC2()))#Fired when client creates new session: ID is the session ID, DATA the shared secret.
                                                #Must fire FUNC2 when done
TLSSERVER.on("resumeSession",                   #Fired when client wants to resume a session. Must call FUNC2() to do so:
FUNC(ID, FUNC2(ERROR, DATA)))                   #  - DATA is the one stored with newSession event
                                                #  - if no new session, ERROR|DATA should be null

connect([PORT_NUM[,'HOST']]OBJ[,FUNC(TLSSOCKT)])#Like TCP.connect(), but for TLS (client connection). OBJ members are:
  ->TLSSOCKET                                   #  - secureContext SECURECONTEXT or SECURECONTEXT.* directly
                                                #  - rejectUnauthorized, ALPNProtocols: like createServer()
                                                #     - except rejectUnauthorized is true by def.
                                                #  - session: like new TLSSocket()
                                                #  - host 'HOST', port PORT_NUM, path 'PATH'
                                                #  - socket TCPSOCKET|IOSTREAM: use an existing TCPSOCKET (host+port can be ommitted then)
                                                #  - servername: for SNI, hostname to choose
                                                #  - checkServerIdentity('HOST', CERT_BUFFER): if throw error, refuse connection
                                                #  - minDHSize NUM (def: 1024)
                                                #  - lookup FUNC: DNS lookup, def: DNS.lookup()
                                                #FUNC is 'secureConnect' event handler
                                                #Returns a TLSSOCKET.

TLSSOCKET                                       #Child of TCPSOCKET, but for SSL.
                                                #Contains other end's authentication status and certificate, providing requestCert: true has been used.
new TLSSocket(TCPSOCKET, OBJ)                   #OBJ:
                                                #  - secureContext SECURECONTEXT or SECURECONTEXT.* directly
                                                #  - requestCert, rejectUnauthorized, ALPNProtocols, SNICallback: like createServer()
                                                #  - session BUFFER
                                                #  - requestOCSP BOOL (def: false):
                                                #     - OCSP is alternative protocol to use CRL
                                                #        - ask to Certificate authority instead of using CRL list
                                                #     - TLSSERVER.on('OCSPRequest', FUNC(BUFFER, BUFFER2, FUNC(ERROR, BUFFER3))):
                                                #        - BUFFER[2] are primary|issuer DER-encoded certificates
                                                #        - BUFFER3: see just below
                                                #     - TLSSOCKET.on('OCSPResponse', FUNC(BUFFER3))
                                                #  - isServer BOOL
                                                #  - server TCPSERVER
TLSSOCKET.on("secureConnect", FUNC())           #Like TCPSOCKET.on("connect"), but for SSL.
TLSSOCKET.getPeerCertificate([BOOL])->OBJ       #Returns other end's certificate.
                                                #OBJ: subject, issuer, valid_from|to, fingerprint[256], pubkey, etc.
                                                #If true, returns full chain, i.e. OBJ.issuer
TLSSOCKET.getCertificate()->OBJ                 #Same but for current end.
TLSSOCKET.encrypted                             #Always true. To distinguish from TCPSOCKET.
TLSSOCKET.authorized                            #False if certificate was not signed by CA specified in ca: STR_ARR
                                                #If false, reason might be given in TLSSOCKET.authorizationError STR
TLSSOCKET.getCipher()->OBJ                      #Current SSL cipher used as { name STR, version STR }
TLSSOCKET.getProtocol()->STR                    #Among 'SSLv3|TLSv1[.1|2]|unknown'
TLSSOCKET.alpnProtocol                          #Protocol selected among ALPNProtocols (see above)
TLSSOCKET.servername                            #For SNI, chosen 'HOST'
TLSSOCKET.renegotiate(OBJ[, FUNC(ERROR)])       #OBJ: rejectUnauthorized, requestCert
                                                #Automatically done after session expires:
                                                #  - TLS.CLIENT_RENEG_LIMIT (def: 3) times every TLS.CLIENT_RENEG_WINDOW (def: 600, in sec),
                                                #to avoid DDoS as it takes resources
TLSSOCKET.disableRenegotiation()              8*#
TLSSOCKET.setMaxSendFragment(NUM)->BOOL         #Def|max: 16384. Min: 512.
                                                #True on success.
                                                #Smaller: smaller latency but slower.
TLSSOCKET.getSession()->OBJ                     #OBJ: ASN.1 encoded
TLSSOCKET.getTLSTicket()->BUFFER                #
TLSSOCKET.get[Peer]Finished()->BUFFER         9*#Returns the "Finished" message, i.e. a hash of the handshake


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             HTTP              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


node --http-parser=legacy|llhttp             11*#Low-level HTTP parsing library:
                                             11*#  - legacy (def)
                                             11*#  - llhttp: faster

STATUS_CODES                                    #{ STATUS_NUM: 'STATUS_NAME', ... }
                                                #Misses 419
METHODS                                         #STR_ARR of HTTP methods, including common ones, WEBDEV and more obscure ones

HTTPSERVER                                      #Child of TCPSERVER
createServer([OPTS, ][FUNC()])->HTTPSERVER      #FUNC is 'request' event handler
                                              9*#OPTS:
                                              9*#  - IncomingMessage|ServerResponse FUNC: to replace constructors of REQ|RES
HTTPSERVER.on("request", FUNC(REQ, RES))        #Fired on client request
HTTPSERVER.on("checkContinue", FUNC(REQ, RES))  #Fired on client request with Expect: 100-continue [C]
                                                #If request is ok, should use RES.writeContinue() to sends a 100 status code
                                                #to the client.
HTTPSERVER.on                                   #Fired on client request with CONNECT method
("connect", FUNC(REQ, TCPSOCKET, BUFFER))       #Client's body is in BUFFER.
HTTPSERVER.on                                   #Fired on client request with Upgrade [C]
("upgrade", FUNC(REQ, TCPSOCKET, BUFFER))       #Client's body is in BUFFER.
HTTPSERVER.on("clientError",FUNC(ERR,TCPSOCKET))#Fired on connection problem.
                                                #Def: TCPSOCKET.destroy()
                                                #ERR has members:
                                                #  - bytesParsed NUM
                                              9*#  - rawPacket BUFFER

HTTPSERVER.maxHeadersCount                      #Maximum number of headers incoming (def: 1000, 0 for unlim)
maxHeaderSize
node --max-http-header-size NUM              11*#Def: 8KB

RES|CLIENTREQ.setTimeout(UINT[, FUNC()])        #Call underlying TCPSOCKET.*
RES|CLIENTREQ.on("timeout", FUNC())             #Unless 'timeout' event handler overriden, calls RES|CLIENTREQ.socket.destroy()
HTTPSERVER.setTimeout(UINT[, FUNC()])           #Calls RES.setTimeout(...) on each new RES
                                                #Def: 12e4, i.e. 2 mins
HTTPSERVER.timeout                              #Same
HTTPSERVER.on("timeout", FUNC(RES))             #Called when any RES 'timeout' event is fired
HTTPSERVER.headersTimeout                    11*#Like HTTPSERVER.timeout but for the time taken to receive HTTP headers.
                                             11*#Def: 4e4, i.e. 40 secs

HTTPSERVER.keepAliveTimeout                   8*#Keep TCPSOCKET NUMms (def: 5000) after RES.end() was called, so it can be
                                              8*#reused if a new request from same host arrives.
                                              8*#0 to disable.
                                              8*#It is different from REQ|CLIENTREQ|HTTPSERVER.timeout:
                                              8*#  - HTTPSERVER.timeout is for idleness while request is ongoing
                                              8*#  - HTTPSERVER.keepAliveTimeout is for idleness between requests
                                              8*#Is not Keep-Alive: timeout=NUM [S] but behaves like if Keep-Alive: timeout=NUM [C]
                                              8*#was specified (although that header does not exist).
                                              8*#As long as TCPSOCKET is opened, TCPSOCKET.unref() won't be called, keeping the
                                              8*#server open.

CLIENTREQ.NoDelay|SocketKeepAlive(...)          #Call underlying TCPSOCKET.*

REQ                                             #ISTREAM, reading the body
REQ.httpVersion[Major|Minor]                    #
REQ.method                                      #"GET|DELETE|..." (not for CLIENTREQ's REQ)
REQ.url                                         #STR (not for CLIENTREQ's REQ). Does not include origin
REQ.headers                                     #As { VAR: 'VAL'[_ARR] ... }. Normalized:
                                                #  - 'VAR' lowercase
                                                #  - duplicates:
                                                #     - common ones are merged as 'VAL'
                                                #     - Set-Cookie: 'VAL'_ARR
                                                #     - others are joined with ','
REQ.rawHeaders                                  #As [ 'VAR', 'VAL', ... ]. Not normalized
REQ.[raw]trailers                               #Same for trailer headers
REQ.statusCode|Message                          #Only for CLIENTREQ's REQ
REQ.socket                                      #TCPSOCKET
REQ.flush()                                     #Send the headers right away, instead of trying to send in same TCP packet
                                                #as body.
                                                #Useful if headers are given quickly but body retrieval takes time.
REQ.on('aborted', FUNC())                       #Aborted by client
REQ.aborted                                  10*#BOOL

RES                                             #OSTREAM, writing the body:
                                                #  - headers must be set first
                                                #  - write() sends to client
                                                #  - end() finishes
                                                #Automatically create following headers:
                                                #  - Date [S] (if RES.sendDate true (def))
                                                #  - Connection: keep-alive [S]
                                                #  - Transfer-Encoding: chunked [S]
RES.on("close", FUNC())                         #Fired if closed before end() was called
RES.headersSent                                 #True if headers are sent
RES.finished                                    #True if all sent (i.e. after end())
RES.statusCode|Message                          #If statusMessage not set, use STATUS_CODES[statusCode]
RES.setHeader('VAR', 'VAL'[_ARR])               #'VAL'_ARR: same as doing setHeader() several times.
RES.getHeader('VAR')->'VAL'[_ARR]               #
RES.getHeaderNames()->'VAR'_ARR               7*#
RES.getHeaders()->OBJ                         7*#
RES.hasHeader('VAR')->BOOL                    7*#
RES.removeHeader('VAR')                         #
RES.writeHead(STATUS_NUM[, 'STATUS_NAME'][,OBJ])#Sets RES.statusCode|Message|headers (must be done only once)
RES.addTrailers(OBJ)                            #Add trailing header fields, i.e. between write() and end() of the body.
                                                #Do not forget Trailer [C] at beginning of response
RES.writeProcessing()                        10*#Send 102 response

ON-HEADERS(RES, FUNC())                        ##Fires FUNC() (with RES as this) just before RES starts sending headers
                                               ##Node module 'on-headers' (1.0.1)

CLIENTREQ                                       #Outgoing HTTP request (as opposed to incoming)
                                                #OSTREAM (like RES)
                                                #Headers:
                                                #  - Content-length [C]: only compatible with utf8 encoding for write()
                                                #  - Expect: 100-continue [C]:
                                                #     - call end() right away
                                                #     - should set a timeout
                                                #     - and listen to 'continue' event
                                                #  - default:
                                                #     - all:
                                                #         Host: HOST:PORT [C]
                                                #         Connection: keep-alive [C]
                                                #     - not GET|HEAD:
                                                #         Transfer-Encoding: chunked [C]
request(['URI'|URI][, OBJ][, FUNC(REQ)])        #Sends a HTTP request.
 ->CLIENTREQ                                  7*#Can use URI
                                             10*#Can use both first arguments, instead of OBJ.url
                                                #OBJ:
                                                #  - protocol STR (def: 'http:')
                                                #  - host[name] STR (def: "localhost")
                                                #     - prefer hostname
                                                #     - will fire exception if non existing
                                                #  - family 4|6 (def: both)
                                                #  - port PORT_NUM (def: 80)
                                                #  - socketPath STR: incompatible with host[name] and port
                                                #  - localAddress STR
                                                #  - method STR (def: "GET")
                                                #  - path STR (def: "/"): including hash and query string
                                                #  - headers OBJ
                                                #  - auth STR: e.g. "auth:password"
                                                #  - agent AGENT|false (def: globalAgent)
                                                #  - keepAlive[Msecs]: see AGENT
                                                #  - createConnection(...): see AGENT
                                                #  - timeout NUM
                                                #FUNC is 'response' event handler.
get(['URI'|URI][, OBJ][, FUNC(REQ)])            #Same but use method "GET" and automatically calls OSTREAM.end()
CLIENTREQ.on("socket", FUNC(TCPSOCKET))         #Fired when socket is created to send the request.
CLIENTREQ.on("response", FUNC(REQ))             #Response of the server.
                                                #REQ must be read, no matter what.
CLIENTREQ.on("continue", FUNC())                #Fired when server responds with Expect: 100-continue [S]
CLIENTREQ.on("checkExpectation",FUNC(REQ, RES)) #Fired when server responds with Expect [S], except Expect: 100-continue [S]
CLIENTREQ.on("information", FUNC(OBJ))       10*#Fired when server responds with 1** (excluding 101)
                                             10*#OBJ: statusCode STR
CLIENTREQ.on
("connect", FUNC(REQ, TCPSOCKET, BUFFER))       #Fired when server responds to a CONNECT request
CLIENTREQ.on
("upgrade", FUNC(REQ, TCPSOCKET, BUFFER))       #Fired when server responds with Upgrade [S]
CLIENTREQ.abort()                               #
CLIENTREQ.on('abort', FUNC())                   #Aborted by client, i.e. CLIENTREQ.abort()
CLIENTREQ.on('aborted', FUNC())                 #Aborted by server
CLIENTREQ.flushHeaders()                        #Like REQ.flush()

AGENT                                           #Socket pools manager for CLIENTREQ (not REQ|RES)
new AGENT(OBJ)                                  #OBJ is:
                                                #  - maxSockets NUM (def: Infinity):
                                                #     - max busy + free sockets per host.
                                                #     - increasing just affect pooling, i.e. more memory used but faster
                                                #     - but does not affect max. number of sockets per host (unlim.)
                                                #  - maxFreeSockets NUM (def: 256):
                                                #     - max free sockets.
                                                #     - only relevant if keepAlive true
                                                #  - keepAlive BOOL (def: true): keep free sockets opened for use
                                                #  - keepAliveMsecs NUM (def: 1000)
                                                #  - timeout NUM
AGENT.max[Free]Sockets                          #
AGENT.[free]sockets                             #Current TCPSOCKET_ARR
AGENT.requests                                  #Current REQ_ARR, not assigned to sockets yet.
AGENT.destroy()                                 #To do to destroy free sockets if keepAliveMsecs high, to avoid hanging.
AGENT.keepSocketAlive = FUNC(TCPSOCKET)       8*#Override function fired on new free socket.
                                              8*#Def: TCPSOCKET.setKeepAlive(true, keepAliveMsecs); TCPSOCKET.unref(); return true;
AGENT.reuseSocket = FUNC(TCPSOCKET, CLIENTREQ)8*#Override function fired when free socket is being picked.
                                              8*#Def: TCPSOCKET.ref();
AGENT.getName(OBJ)                              #Returns OBJ (host, port, localAddress) as unique ID STR
AGENT.createConnection(...)->IOSTREAM           #Same as TCP createConnection(), but can be customized and use any IOSTREAM


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             HTTPS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


HTTPS ==>                                       #Has exactly same members as HTTP except:
                                                #  - createServer(OBJ[, FUNC]): OBJ is same as TLS|HTTP.createServer()
                                                #  - all members:
                                                #      - inherit from HTTP, e.g. HTTPSSERVER inherits HTTPSERVER
                                                #      - use TLS* objects instead of TCP*, e.g. TLSSERVER <- TCPSERVER, TLSSOCKET <- TCPSOCKET, etc.
                                                #      - as such, can be used as HTTP server too
                                                #  - new AGENT(OBJ) and request(OBJ) can use:
                                                #     - all options from TLS.createSecureContext(OBJ)
                                                #     - 'rejectUnauthorized|servername' options from TLS.connect(OBJ)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              URL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NODE_URI                                        #Prefer URI
                                                #OBJ:
                                                #  - protocol STR|null
                                                #  - slashes BOOL: if AUTHORITY starts with //
                                                #  - auth STR|null
                                                #  - host STR|null
                                                #  - port STR|null
                                                #  - hostname STR|null
                                                #  - pathname 'PATH'|null
                                                #  - path 'PATH?QUERY'|null
                                                #  - search '?QUERY'|QUERY_OBJ
                                              9*#    or null
                                                #  - query 'QUERY'|null
                                                #  - hash '#HASH'|null
                                                #  - href 'URI'
                                             11*#Deprecated
parse('URI'[, BOOL[, BOOL2]])->NODE_URI         #BOOL: if true (def: false), NODE_URI.search is QUERY_OBJ
                                                #BOOL2: if true (def: false), protocol can be omitted
                                             11*#Deprecated
resolve('BASE_URI', 'RELATIVE_URI')->'URI'      #
                                             11*#Deprecated

URI                                           7*#As opposed to NODE_URI, is isomorphic, i.e. same as in browser (see DOM doc)
                                             10*#Including the fact that URL is a global object
new URL("URI"[, URI2|'URI2'])->URI            7*#See DOM doc
format(URI[, OPTS])->'URI'                    7*#OPTS:
                                              7*#  - auth BOOL: if false (def: true), ignores username|password
                                              7*#  - fragment BOOL: if false (def: true), ignores hash
                                              7*#  - search BOOL: if false (def: true), ignores search
                                              7*#  - unicode BOOL: if false (def), uses Punycode. Otherwise, URI encoding

ORIGIN                                          #OBJ: scheme STR|null, host STR|null, port STR|undefined, domain STR|null
originFor(...)->ORIGIN                          #Like URL constructor, but returning ORIGIN instead

domainToASCII(STR)->STR2
domainToUnicode(STR)->STR2                    7*#IDN from|to Punycode

fileURLToPath(URI|'URI')->'PATH'             10*#Conversion between file://* and 'PATH' considering:
pathToFileURL('PATH')->URI|'URI'             10*#  - 'PATH' is OS-specific
                                             10*#  - URI requires percent encoding, but not 'PATH'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          QUERYSTRING          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


stringify(QUERY_OBJ[, STR[, STR2[, OPTS]]])     #'QUERY' is escaped
  ->'QUERY'                                     #STR is separator (def: '&'), STR2 delimiter (def: '=')
                                                #ARR is serialized as several VARs
                                                #OPTS:
                                                #  - encodeURIComponent(...) (def: escape(...)): customize escaping
parse('QUERY'[, STR[, STR2]][, OPTS])->QUERY_OBJ#Inverse.
                                                #OPTS:
                                                #  - maxKeys NUM (def: 1000, 0 for unlim)
                                                #  - decodeURIComponent(...) (def: unescape(...)):
                                                #     - customize escaping
                                                #     - transforms + to spaces (instead of escaping)
                                                #Note: QUERY_OBJ does not inherit from OBJ
[un]escape(STR)                                 #Same as en|decodeURIComponent(), but can be overriden to change stringify|parse() behavior

QS ==>                                         ##See QS module for more features


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              DNS              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DIFFERENCE ==>                                  #DNS.resolve*|reverse() and DNS.lookup*() are similar but:
                                                #  - resolve*|reverse(): use C-Ares, a fast library for DNS resolution, which does DNS query directly.
                                                #  - lookup*():
                                                #     - uses getaddrinfo(), which is slower.
                                                #     - it uses underlying OS, i.e. how DNS resolution would behave on that system (e.g. /etc/hosts)
                                                #     - it is used by http.*, tcp.* and udp.* modules.
                                                #Resolving manually the host can give better performance.

lookup('HOST'[, OBJ], FUNC(ERROR, 'HOST', STR4))#DNS forward lookup.
                                                #STR4 is family: 4 (IPv4), 6 (IPv6) or null (both).
                                                #OBJ:
                                                #  - family 4|6|null
                                                #  - hints NUM: or'd flags among:
                                                #     - DNS.ADDRCONFIG
                                                #     - DNS.V4MAPPED: if look for IPv6 but none found, return IPv4 mapped as IPv6
                                                #  - all BOOL: if true (def: false), return all address as STR4_ARR, not only first one
                                                #  - verbatim BOOL: if false (def), reorder IPv4 before IPv6
                                                #The ERROR.name can correspond to several DNS.*, like DNS.NOTFOUND, DNS.NODATA, DNS.NOMEM, etc. (see online doc)
lookupService
(IP, PORT, FUNC(ERROR, 'HOST', 'SCHEME'))       #

new Resolver()                                8*#RESOLVER
                                              8*#In following methods, if RESOLVER is missing, use builtin RESOLVER
[RESOLVER.]resolve
 ('HOST'[, STR2], FUNC(ERROR, VAL_ARR))         #Same as lookup() but STR2 can any PTR record type: "A" (def), "AAAA", "MX", "TXT", "SRV", "PTR", "NS", "CNAME", "SOA", "NAPTR" or "ANY" (guesses)
[RESOLVER.]resolveSTR2                          #Same. STR2 is camelcase, and "A"|"AAAA"->4|6
 ('HOST', [OBJ, ]FUNC(ERROR, VAL_ARR))        7*#OBJ (only with records "A"|"AAAA"):
                                              7*#  - ttl BOOL: if true (def: false), VAL is { address STR, ttl NUM }
[RESOLVER.]reverse('IP', FUNC(ERROR,'HOST'_ARR))#DNS reverse lookup.

[RESOLVER.]setServers('IP[:PORT]'_ARR)          #Sets list of servers IP to use for DNS resolution
[RESOLVER.]getServers()->'IP[:PORT]'_ARR        #List of servers

RESOLVER.cancel()                             8*#Cancel all current resolve*|reverse() calls, with ERROR with code 'ECANCELLED'

promises.*(...)                              10*#Like DNS.*(...) except returns PROMISE and no RESOLVER.cancel()
                                             10*#Experimental (throw warning)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              OS               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


platform()->STR                                 #"linux", "darwin", "win32", "android" or "sunos", "aix", "freebsd", "openbsd"
type()->STR                                     #Similar to platform() but slightly more precise.
                                                #E.g. "Linux", "Darwin", "Windows_NT", "CYGWIN_NT*", ""SunOS", "AIX", "FreeBSD", "OpenBSD"
release()->STR                                  #OS version number, e.g. "3.11.0-14-generic" (Linux), "18.0.0" (Mac), "10.0.17763" (Windows)
arch()->STR                                     #"arm[64]", "ia32", "x32|x64", "mips[el]", "ppc[64]", "s390[x]"
endianness()->STR                               #"BE" or "LE"

uptime()->DOUBLE                                #In seconds
loadavg()->DOUBLE_ARR                           #For last 1, 5 and 15 minutes.
                                                #Returns [0,0,0] on Windows
totalmem|freemem()->NUM                         #RAM

cpus()->OBJ_ARR                                 #OBJ:
                                                #  - model STR
                                                #  - speed UINT (MHz): varies with the load
                                                #  - times OBJ, ms spent by CPU on each member since uptime: user, sys, idle, nice, irq
                                                #     - nice is always 0 on Windows
networkInterfaces()->OBJ_ARR                    #OBJ:
                                                #  - key is interface name ("lo", "wlan0", etc.)
                                                #  - value is OBJ2_ARR, with OBJ2:
                                                #     - address 'IP'
                                                #     - netmask 'MASK'
                                                #     - cidr 'IP/MASK'
                                                #     - family "IPv4|6"
                                                #     - mac STR
                                                #     - internal BOOL (true if boucle local)
                                                #     - scopeid NUM

hostname()->STR                                 #E.g. "ether-laptop"
tmpdir()->STR                                   #E.g.:
                                                #  - Linux: `/tmp`
                                                #  - Mac: `/var/folders/RANDOM/T`
                                                #  - Windows: `C:\Users\USER\AppData\Local\Temp`
homedir()->STR                                  #E.g.:
                                                #  - Linux: `/home/USER`
                                                #  - Mac: `/Users/USER`
                                                #  - Windows: `C:\Users\USER`
userInfo([OBJ])->OBJ2                           #OBJ2:
                                                #  - uid|gid NUM (-1 on Windows)
                                                #  - username 'USER' (ENVVAR USER on Unix, USERNAME on Windows)
                                                #  - homedir 'PATH'
                                                #  - shell 'PATH' (null on Windows)
                                                #OBJ: encoding 'utf8' (def) or 'buffer'

EOL                                             #OS-specific newline "\n" or "\r\n"

setPriority([PID, ]NUM)                      10*#Sets OS process scheduling priority ("niceness").
                                             10*#If 0 (def), current process
                                             10*#NUM is between -20 (high priority) and 19 (low priority) or using os.constants:
                                             10*#  - PRIORITY_LOW: 19
                                             10*#  - PRIORITY_BELOW_NORMAL: 10
                                             10*#  - PRIORITY_NORMAL: 0
                                             10*#  - PRIORITY_ABOVE_NORMAL: -7
                                             10*#  - PRIORITY_HIGH: -14
                                             10*#  - PRIORITY_HIGHEST: -20
getPriority([PID])->NUM                      10*#


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             PATH              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PATH ==>                                        #All these functions look at PATH without caring if file exists.

CROSS-OS ==>                                    #Summary:
                                                #  - should usually use Unix path
                                                #  - except when dealing with input|output outside Node (in shell): use PATH.* then
                                                #  - Node methods input:
                                                #     - Unix path allowed on all OS
                                                #        - but Windows path also allowed in Windows (including mixed)
                                                #     - e.g. require(), PATH.*, FS.*, process.chdir()
                                                #  - Node methods output:
                                                #     - OS-specific
                                                #        - but it's ok since input in Node in Windows allows mixing Unix/Windows
                                                #     - e.g. PATH.*, __dirname, process.argv|execPath|cwd(), OS.userInfo().homedir
                                                #     - exceptions:
                                                #        - PATH.posix|win32.*
                                                #        - output based on input, e.g. createReadStream().path, fs.mkdtemp()
                                                #  - input|output outside Node (in shell): OS-specific

normalize('PATH')->'PATH'                       #Remove leading "./", useless ".." and duplicate "/"
join('PATH',...)->'PATH2'                       #Join with PATH.sep, then do normalize()
resolve('PATH',...)->'PATH2'                    #Like doing several cd 'PATH' from current directory:
                                                #  - 'PATH' can be relative or absolute
                                                #  - 'PATH2' is final DIR, normalized()
relative('PATH', 'PATH2')->'PATH3'              #Print relative PATH3 to go from dir PATH to dir PATH2.
                                                #Return '' if same dir

isAbsolute('PATH')->BOOL                        #

dirname('PATH')->'DIR'                          #
basename('PATH'[, 'EXT'])->'FILE'               #
extname('PATH')->'EXT'                          #Including '.'

parse('PATH')->PATH_OBJ                         #PATH_OBJ: root STR, dir STR, base STR, ext STR, name STR
format(PATH_OBJ)->'PATH'                        #Inverse

sep                                             #OS-specific path delimiter "/" or "\"
delimiter                                       #OS-specific ENVVAR PATH delimiter ":" or ";"
posix|win32.*                                   #Like PATH, but always behave like if on those platforms
toNamespacedPath('PATH')->'PATH'              9*#Returns namespaced path '\\?\LETTER:\'.
                                              9*#Noop unless on Windows.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              FS               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


node --trace-sync-io                            #console.trace() when sync I/O is used

CROSS-OS PERMISSIONS ==>                        #Windows permissions are not supported
                                                #  - except for `readonly` file attribute on regular files, which maps to `a+w`
                                                #  - all other permissions are always on
                                                #This affects `umask()`, `chmod()`, `access()`, `stat().mode` and `opts.mode`
                                                #for `mkdir()` and `open()`.

FS-EXTRA                                       ##Replacement for FS, with extra methods.
                                               ##Version 0.16.3
                                               ##Works well with BLUEBIRD.promisifyAll(FS-EXTRA)
WRENCH                                         ##Other filesystem module, but not drop-in replacement of FS.
                                               ##Version 1.5.8

PATH|FILENAME|DIR                               #Either:
                                                #  - STR
                                              7*#  - URI
                                                #  - BUFFER (less interoperable)
f*                                              #Variant using file descriptior FD_INT
l*                                              #Doesn't deference symlinks

PWD ==>                                         #All relative to process.cwd()
...Sync(...)                                    #All functions have a synchronous variant, without FUNC, except
                                                #[un]watch[File]() and createRead|WriteStream()
                                                #Will throw exceptions instead of using ERROR.

copyFile(PATH, PATH2[, NUM][, FUNC(ERROR)])   8*#NUM is an or'd flag:
                                              8*#  - COPYFILE_EXCL: fail if PATH2 already exists
FS-EXTRA.copy(FILE|DIR, FILE|DIR2, FUNC(ERROR))##
WRENCH.copyDirSync[Recursive]                  ##OBJ:
(FILE|DIR, FILE|DIR2[, OBJ][,FUNC(ERROR)])     ##  - forceDelete BOOL: overwrite destination
                                               ##  - excludeHiddenUnix BOOL: copy dotfiles
                                               ##  - preserveFiles BOOL: keep copy when overwriting
                                               ##  - preserveTimestamps BOOL
                                               ##  - inflateSymlinks BOOL: follow symlinks
                                               ##  - filter REGEXP|FUNC(STR)->BOOL: exclude files to copy
                                               ##  - whitelist BOOL: if true, filter works
                                               ##  - include|exclude REGEXP|FUNC(STR)->BOOL
rename(PATH, PATH2, FUNC(ERROR))                #
FS-EXTRA.move(FILE|DIR, FILE|DIR2[, OBJ],
FUNC(ERROR))                                   ##Can use OBJ.clobber true to overwrite.
GULP-RENAME(VAL)                               ##Rename filenames. VAL can be:
                                               ##  - FILENAME_STR (single file)
                                               ##  - OBJ: dirname STR, basename STR, prefix STR, suffix STR, extname STR
                                               ##    (e.g. ".js")
                                               ##  - FUNC(OBJ)->OBJ, with same OBJ as above
                                               ##Version 1.2.0

[f]truncate(PATH|FD_INT, UINT, FUNC(ERROR))     #

[f|l]chown(PATH|FD_INT, UID, GID, FUNC(ERROR))  #Noop on Windows
WRENCH.chownSyncRecursive(DIR, UID, GID)       ##
[f|l]chmod(PATH|FD_INT, UINT, FUNC(ERROR))      #See above for Windows behavior
                                                #lchmod() is only on Mac
WRENCH.chmodSyncRecursive(DIR, UINT)           ##

[f]utimes(PATH|FD_INT, ATIME, MTIME, FUNC(ERR)) #Change atime|mtime
access(PATH[, NUM], FUNC(ERROR))                #Checks if has permission, according to NUM or'd flags:
                                                #  - FS.constants.F_OK (def, always implied):
                                                #     - files exists and its directory list it
                                                #     - also fails if directory and is not executable
                                                #  - FS.constants.R|W|X_OK:
                                                #     - can be read|written|executed
                                                #     - on Windows, only W_OK works and only means "no readonly attribute"
[f|l]stat(PATH|FD_INT,[OPTS,]FUNC(ERROR,FSSTAT))#FSSTAT:
                                                #  - isFile|Directory|Block|CharacterDevice|FIFO|Socket(), (only with lstat()) isSymbolicLink()
                                                #     - on Windows: can only be file, directory or symlink
                                                #  - dev UINT
                                                #  - ino UINT
                                                #  - mode UINT (see above for file type and permissions behavior)
                                                #  - nlink UINT
                                                #  - uid|gid UINT (0 on Windows)
                                                #  - rdev UINT
                                                #  - size UINT
                                                #  - blksize UINT, blocks UINT (both undefined on Windows)
                                                #  - a|m|ctime DATE
                                              8*#  - a|m|ctimeMs NUM
                                                #  - birthtime DATE: creation time (Windows only)
                                              8*#  - birthtimeMs NUM: creation time (Windows only)
                                             10*#OPTS:
                                             10*#  - bigint BOOL (def: false): make FSSTAT.* BIGINT instead of UINT

symlink(PATH, PATH2[, STR], FUNC(ERROR))        #STR is 'dir', 'file' (def) or 'junction' (Windows only)
link(PATH, PATH2, FUNC(ERROR))                  #Hardlink
GULP-SYMLINK.relative|absolute                 ##Creates a symlink in DIR (creates it if not existing, overwrite if OBJ.force
(DIR_ARR|FUNC(VINYL)->VINYL[,OBJ])             ##true) with same filename as current file, poiting to that file (with a
                                               ##relative|absolute path). Version 2.0.1
readlink(PATH[, OBJ], FUNC(ERROR, PATH2))       #Follow symlink (only once)
                                                #PATH must be a symlink
                                                #OBJ: encoding 'ENCODING'
realpath[.native]                               #Like normalize(), but also follow symlinks (several times if needed), and PATH must exist.
 (PATH[, OBJ], FUNC(ERROR, PATH2))              #OBJ: encoding 'ENCODING'
                                              9*#If "native" does not cache and do less normalization

unlink(PATH, FUNC(ERROR))                       #
rmdir(PATH, FUNC(ERROR))                        #
FS-EXTRA.remove(FILE|DIR, FUNC(ERROR))         ##Like rm -rf
WRENCH.rmdirSyncRecursive(FILE|DIR[, BOOL])    ##Same. If true, fails silently.
RIMRAF(DIR|FILE[, FUNC()])                     ##Same
                                               ##Version 2.2.8
                                               ##Also GULP-RIMRAF([OBJ]):
                                               ##  - Only makes sense after GULP-IGNORE() in the middle of the pipeline
                                               ##    (otherwise use RIMRAF() directly).
                                               ##  - gulp.src() should use { read: false } if only GULP-IGNORE() then
                                               ##    GULP-RIMRAF() are used, so it is faster.
                                               ##  - Must use OBJ.force true if not in $PWD
                                               ##  - Version 0.1.0

mkdir(PATH[, MODE_INT|OPTS], FUNC(ERROR))    10*#OPTS:
                                                #  - mode MODE_INT (def: 0777) (see above for Windows behavior)
                                             10*#  - recursive BOOL (def: false)
FS-EXTRA.ensureFile|Dir(FILE|DIR,FUNC(ERROR))  ##Create file|dir, including parent dirs, if not existing.
FS-EXTRA.mkdirs(DIR, FUNC(ERROR))              ##Like ensureDir()
WRENCH.mkdirSyncRecursive(DIR[, MODE_INT])

readdir(DIR, [OPTS, ]                           #ls: 'FILE' excludes . and ..
 FUNC(ERROR, 'FILE'|DIRENT_ARR))                #OPTS:
                                                #  - encoding 'ENCODING'
                                             10*#  - withFileTypes BOOL (def: false): whether to return DIRENT_ARR or 'FILE'_ARR
WRENCH.readdirSync[Recursive]
(DIR[, OPTS][, FUNC(ERROR, STR2_ARR)])          ##Same but recursive
DIRENT.isFile|Directory|Block|CharacterDevice|
 FIFO|Socket|SymbolicLink()->BOOL            10*#
DIRENT.name                                  10*#STR

open(PATH, STR|NUM[, MODE], FUNC(ERROR, FD_INT))#Open a file and return a file descriptor.
                                                #STR are flags: "r|w|a[s|x][+]":
                                                #  - r: O_RDONLY
                                                #  - w: O_TRUNC + O_CREAT + O_WRONLY
                                                #  - a: O_APPEND + O_CREAT + O_WRONLY
                                                #  - +: O_RDONLY|WRONLY -> O_RDWR
                                                #  - x: O_EXCL. Not with 'r'
                                                #  - s: O_SYNC. Not with 'w'
                                              9*#    Can be done with 'a'
                                                #NUM are or'd flags:
                                                #  - O_RDONLY|O_WRONLY|O_RDWR: read|write-only or not
                                                #  - O_TRUNC: truncate
                                                #  - O_APPEND: append
                                                #  - O_CREAT: create if not exist
                                                #  - O_CREAT + O_EXCL: fail if exist
                                                #  - O_DIRECTORY: fail if not a directory
                                                #  - O_NOFOLLOW: fail if is a symlink
                                                #  - O_SYMLINK: do not follow symlinks
                                                #  - O_NOATIME: do not update atime (Linux only)
                                                #  - O_DIRECT: try to avoid caching|buffering
                                                #  - O_SYNC: synchronous (wait for data)
                                                #  - O_DSYNC: synchronous (wait for data+metadata)
                                                #  - O_NOCTTY: if file is a terminal device, treat it as a normal file
                                                #  - O_NONBLOCK: use async when opening special files like serial ports
                                                #On Windows, those flags are mapped to file attributes, file permissions and share permissions
                                                #MODE INT is 0666 by def.
close(FD_INT, FUNC(ERROR))                      #
write(FD_INT, TDBUFFER, INT, INT2, [ INT3,]     #Write INT2 bytes from TDBUFFER at its position INT to file FD_INT at its position INT3 (def: current).
FUNC(ERROR, INT4, TDBUFFER))                    #INT4 is the number of bytes written.
                                              7*#INT|INT2 are optional
write(FD_INT, STR[, INT3,                       #Similar.
['ENCODING', ]] FUNC(ERROR, INT4, STR))       7*#INT3 is optional
read(FD_INT, TDBUFFER, INT, INT2,
INT3, FUNC(ERROR, INT4, BUFFER))                #
f[data]sync(FD_INT, FUNC(ERROR))                #Flushes to disk
                                                #If 'data', does not flush metadata (e.g. mtime)

readFile                                        #Easier way than using open() and read()
(PATH|FD_INT, [OBJ, ]FUNC(ERROR, BUFFER|STR))   #OBJ:
                                                #  - encoding 'ENCODING' (def: null, i.e. returns BUFFER, otherwise returns STR)
                                                #  - flag STR (def: "r")
                                                #Prefer createReadStream(...).pipe(OSTREAM)
FS-EXTRA.readJson(...)                         ##Same as readFile(), but return as OBJ
write|appendFile(FILENAME|UINT,                 #OBJ has same members but also mode MODE_INT (def: 0666)
[STDBUFFER,] [OBJ, ] FUNC(ERROR))               #Def flag is "w|a"
FS-EXTRA.outputFile(...)                       ##Same as writeFile(), but calls ensureFile() first
FS-EXTRA.writeJson|outputJson(...)             ##Same as writeFile|outputFile(), but with an OBJ (JSON.stringify'd).
createReadStream(PATH[, OBJ])->ISTREAM          #Preferred over readFile().
                                                #Useful with ISTREAM.[.pipe(IOSTREAM)...]pipe(OSTREAM):
                                                #  - transmits to OSTREAM by chunks ("data" events) instead of at once
                                                #    (readFile())
                                                #  - can use IOSTREAM as modular transforms functions (like Unix commands)
                                                #OBJ has members:
                                                #  - flags STR (def: "r")
                                                #  - encoding 'ENCODING' (def: null)
                                                #  - fd FD_INT (def: null)
                                                #  - mode NUM (def: 0666) (see above for Windows behavior)
                                                #  - autoClose BOOL (def: true): close the file descriptor on error|end event
                                                #  - start|end UINT: only use from bytes UINT to UINT2
                                                #ISTREAM has extra:
                                                #  - same members as OBJ
                                                #  - on('open', FUNC(FD_INT))
                                              9*#  - on('ready', FUNC())
                                             11*#  - pending BOOL: true if 'ready' event not emitted yet
                                                #  - path PATH
                                                #  - pos UINT
createWriteStream(PATH[, OBJ])->OSTREAM         #OBJ has members flags, defaultEncoding, fd, mode, autoClose, start
                                                #OSTREAM has extra:
                                                #  - same members as OBJ
                                          |9|11*#  - 'open', 'ready', pending, path, pos: like createReadStream()
                                                #  - bytesWritten UINT
new WRENCH.LineReader(FILE)                    ##Returns LINEREADER
LINEREADER.hasNextLine()                       ##
LINEREADER.getNextLine()                       ##Returns FILE line by line
LINEREADER.close()                             ##

mkdtemp('PATH', FUNC(ERROR, 'PATH2'))           #Create temp file at 'PATHrandom', with random being 6 chars [:alnum:] (36 bits of entropy)
TEMP.open(PREFIX, FUNC(ERROR, OBJ))            ##Creates temp file with permission 0600 under temp directory.
                                               ##OBJ:
                                               ##  - path STR
                                               ##  - fd NUM
                                               ##PREFIX:
                                               ##  - OBJ: prefix STR, suffix STR, dir DIR (def: "", "", OS temp dir)
                                               ##  - STR: only PREFIX_STR
                                               ##  - Path will be TMP_DIR/PREFIX-UUID-AFFIX
                                               ##If TEMP.track() called before, it will erase file on process exit.
                                               ##Version 0.8.1
TEMP.mkdir(PREFIX,FUNC(ERROR,PATH))            ##Same with directory
TEMP.createWriteStream()                       ##Same for file as OSTREAM
TEMP.path(PREFIX)                              ##Same for only the path
TEMP.cleanup(FUNC(ERROR,OBJ))                  ##Remove temp files. TEMP.track() must have been called before.
                                               ##OBJ: files|dirs NUM


watch('DIR'[, OPTS][, FUNC])->FSWATCHER         #FSWATCHER fires events when s file changes name or content.
                                                #OPTS:
                                                #  - persistent BOOL: if true (def), calls ref(), yielding the macrotask
                                                #  - recursive BOOL (def: false) (not on Linux)
                                                #  - encoding 'ENCODING' (def: 'utf8')
                                                #FUNC is the FSWATCHER 'change' event handler.
                                                #Unstable. Prefer Chokidar.
FSWATCHER.on
('change', FUNC('change|rename', SBUFFER))      #SBUFFER is the FILENAME and is not always provided (e.g. never on MacOSX, and not always on other OS)
FSWATCHER.close()                               #
FSWATCHER.on('close', FUNC())                10*#
FSWATCHER.on('error', FUNC(ERROR))              #

[un]watchFile                                   #Uses polling
(FILE[, OPTS], FUNC(PREV_STAT, NEW_STAT))       #OPTS:
                                                #  - persistent BOOL
                                                #  - interval (def: 5000)

constants                                       #Low-level file-system constants, for the current OS


FS.promises                                  10*#Like FS but:
                                             10*#  - return PROMISE instead
                                             10*#     - no FS.unwatch|watch[File]() nor FS.*Stream()
                                             10*#  - FD_INT are FILE_HANDLE instead
                                             10*#     - no FS.close() but FILE_HANDLE.close() is available
                                             10*#  - FS.constants|Stats|*OK remain on FS.*
                                             10*#  - is experimental (throws warning)
FILE_HANDLE                                  10*#Abstraction of a file descriptor, with automatic closing on FS PROMISE rejection
FILE_HANDLE.fd                               10*#FD_INT
FILE_HANDLE.FUNC(...)                        10*#Same as FSP.[f]FUNC(FILE_HANDLE, ...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ZLIB              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


createGzip|Deflate[Raw]([OBJ])->COMPRESS        #COMPRESS is a IOSTREAM, so should do:
                                                #  ISTREAM.pipe(IOSTREAM).pipe(OSTREAM)
                                                #See HTTP for different formats.
                                                #Raw: same but does not append a zlib header.
                                                #OBJ can be:
                                                #  - [finish]flush, among:
                                              7*#     - constants.Z_NO_FLUSH (def)
                                              7*#     - constants.Z_PARTIAL_FLUSH
                                              7*#     - constants.Z_SYNC_FLUSH
                                              7*#     - constants.Z_FULL_FLUSH
                                              7*#     - constants.Z_FINISH
                                              7*#     - constants.Z_BLOCK
                                              7*#     - constants.Z_TREES
                                                #  - chunkSize (def: 16*1024): higher means faster but more memory
                                                #  - windowBits (def: 15): from 9 to 15, higher means better compression but
                                                #    more memory.
                                                #  - dictionary TDABUFFER (deflate|inflate only) (def: "")
                                                #OBJ (compression only):
                                                #  - level: higher means better compression but slower, among:
                                              7*#     - constants.Z_DEFAULT_COMPRESSION (def)
                                              7*#     - constants.Z_BEST_SPEED
                                              7*#     - constants.Z_BEST_COMPRESSION
                                              7*#     - constants.Z_NO_COMPRESSION
                                                #  - memLevel (def: 8): from 1 to 9, higher means better compression but more
                                                #    memory.
                                                #  - strategy, make compression better, according to type of data, among:
                                              7*#     - constants.Z_DEFAULT_STRATEGY: almost random data, and small values
                                              7*#     - constants.Z_FILTERED: in-between
                                              7*#     - constants.Z_HUFFMAN_ONLY: less random, and large repeating chunk
                                              7*#     - constants.Z_RLE: same, but specially for PNG data
                                              7*#     - constants.Z_FIXED: only specific application
                                                #Memory required (in bytes) is:
                                                #  - for compression:
                                                #     - 2^(windowBits+2) + 2^(memLevel+9) + chunkSize, i.e. 272K by def
                                                #  - for decompression:
                                                #     - 2^windowBits + chunkSize, i.e. 48K by def
createBrotliCompress([OBJ])->COMPRESS        11*#Same with Brotli. OBJ:
                                             11*#  - flush NUM, finishFlush ENUM, among:
                                             11*#     - constants.BROTLI_OPERATION_PROCESS (def)
                                             11*#     - constants.BROTLI_OPERATION_FINISH (def for last chunk)
                                             11*#     - constants.BROTLI_OPERATION_FLUSH (def for flush())
                                             11*#     - constants.BROTLI_OPERATION_EMIT_METADATA
                                             11*#  - chunkSize NUM (def: 16KB)
                                             11*#  - params OBJ:
                                             11*#     - [constants.BROTLI_PARAM_MODE] ENUM, among:
                                             11*#        - constants.BROTLI_MODE_GENERIC (def)
                                             11*#        - constants.BROTLI_MODE_TEXT: best for UTF-8 text
                                             11*#        - constants.BROTLI_MODE_FONT: best for WOFF 2.0 fonts
                                             11*#     - [constants.BROTLI_PARAM_QUALITY] NUM:
                                             11*#        - between constants.BROTLI_MIN|MAX_QUALITY (0|11)
                                             11*#        - def constants.BROTLI_DEFAULT_QUALITY (11)
                                             11*#        - higher gives better compression but consumes more CPU-time
                                             11*#     - [constants.BROTLI_PARAM_LGWIN] NUM:
                                             11*#        - between constants.BROTLI_MIN|MAX_WINDOW_BITS (10|24)
                                             11*#           - max BROTLI_LARGE_MAX_WINDOW_BITS (30) if BROTLI_PARAM_LARGE_WINDOW true
                                             11*#        - def constants.BROTLI_DEFAULT_WINDOW (22)
                                             11*#        - higher gives better compression, but consumes more memory, i.e. 2**NUM (i.e. def is 4MB)
                                             11*#     - [constants.BROTLI_PARAM_LGBLOCK] NUM:
                                             11*#        - between constants.BROTLI_MIN|MAX_INPUT_BLOCK_BITS (16|24)
                                             11*#        - higher gives better compression, but consumes more memory, i.e. 3 ** NUM
                                             11*#     - [constants.BROTLI_PARAM_SIZE_HINT] NUM:
                                             11*#        - input size hint
                                             11*#        - def 0, i.e. unknown
                                             11*#     - [constants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING] BOOL:
                                             11*#        - if true (def: false), poorer compression but faster decompression
                                             11*#     - [constants.BROTLI_PARAM_LARGE_WINDOW] BOOL:
                                             11*#        - if true (def: false), allow large windows, good for huge files
                                             11*#     - [constants.BROTLI_PARAM_NPOSTFIX|NDIRECT] NUM:
                                             11*#        - def 0
                                             11*#        - hint for number of direct distance codes and postfix bits.
                                             11*#        - those are two internal parameters of the algorithms, to use only when knowing it.
createGunzip|Inflate[Raw]|Unzip([OBJ])->UNCOMPRS#UNCOMPRESS is a IOSTREAM.
                                                #Unzip: autodetect whether Gunzip or Deflate (but not DeflateRaw).
createBrotliDecompress([OBJ])->UNCOMPRESS    11*#Same with Brotli. OBJ:
                                             11*#  - [constants.BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION] BOOL:
                                             11*#     - affects internal memory allocation
                                             11*#  - [constants.BROTLI_DECODER_PARAM_LARGE_WINDOW] BOOL: same as for compression
[UN]COMPRESS.flush([NUM, ]FUNC(ERROR))          #Compression uses an internal cache. Flush it.
                                                #Don't call unless necessary, because it impacts performance.
                                                #NUM def is constants.Z_FULL_FLUSH|BROTLI_OPERATION_FLUSH. See above for other values.
[UN]COMPRESS.reset()                            #Stop compressing any data going through.
                                                #Only for Deflate|Inflate
[UN]COMPRESS.params(LEVEL, STRATEGY,FUNC(ERROR))#
[UN]COMPRESS.bytesWritten                    10*#NUM

gzip|deflate[Raw]|brotliCompress
(STDABUFFER[, OBJ],FUNC(ERROR, BUFFER))         #
gunzip|inflate[Raw]|unzip|brotliDecompress
(STDABUFFER[, OBJ],FUNC(ERROR, BUFFER2))        #Convenience methods
*Sync(...)                                      #Same but sync


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           WARNINGS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WARNINGS ==>                                    #Are similar to console.warn() except:
                                                #  - can be handled similarly to an exception, but does not stop execution
                                                #  - not part of normal JavaScript code flow
                                                #  - used by Node.js internal warnings, e.g. deprecations
                                                #  - should try to emit only once
                                                #By def, printed to console with console.warn()

node --no-warnings
NODE_NO_WARNINGS=1 ENVVAR                     6*#Does not print to console
node --trace-warnings                           #Use console.trace() instead of console.warn()
node --redirect-warnings=FILE
NODE_REDIRECT_WARNINGS=FILE ENVVAR            8*#I.e. will not be printed to console

PROCESS.emitWarning(ERROR)
PROCESS.emitWarning('MESSAGE'[, 'TYPE']         #Creates a warning
[, 'ID'][, FUNC(ERROR)->ERROR])                 #Def TYPE: 'Warning'
PROCESS.emitWarning('MESSAGE',                8*#Same.
[{ type, code, ctor, detail }])               8*#detail is extra message on next line (e.g. stack trace)

process.on('warning', FUNC(ERROR))              #Fired on warnings.
                                                #ERROR: message 'MESSAGE', name 'TYPE', code 'ID', detail STR
                                                #ERROR.code|detail might be undefined


DEPRECATION ==>                                 #Type of warning with TYPE "DeprecationWarning"

UTIL.deprecate(FUNC, 'MESSAGE'[, 'ID'])->FUNC   #Make FUNC fire PROCESS.emitWarning('MESSAGE', 'DeprecationWarning', 'ID')

node --no-deprecation
node --trace-deprecation                        #Like --no|trace-warnings but for deprecations
node --throw-deprecation                        #throw error on deprecation
node --pending-deprecation
NODE_PENDING_DEPRECATION=1 ENVVAR             8*#Includes upcoming deprecations


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PROCESS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXIT EVENTS ==>                                 #  - normal exit: beforeExit, exit
                                                #  - uncaught exception: uncaughtException, beforeExit, exit
                                                #  - process.exit(): exit
                                                #  - process.abort(): none
                                                #  - SIGINT|SIGTERM (with no handler): none
                                                #  - SIGINT|SIGTERM (with handler): SIGINT|SIGTERM
                                                #The only handler that will prevent exit from happening (graceful exit)
                                                #are SIGINT|SIGTERM
on("beforeExit", FUNC(INT))                     #
on("exit", FUNC(INT))                           #INT is the exit code
                                                #  - process.exitCode is same, providing process.exit() was explicitely called
                                                #FUNC() must be synchronous

on("uncaughtException", FUNC(ERROR))            #Any exception thrown and not caught in try/catch
                                                #Can be exception top-level or within a microtask/macrotask
                                                #  - e.g. a callback or request handler
                                                #  - not possible with Express since it catches any error within request handler
                                                #Unless an event handler exists, calls process.exit(1)
                                                #  - should always call process.exit(1) within event handler to keep this behavior
setUnaughtExceptionCaptureCallback            9*#Same as on("uncaughtException") except:
 (FUNC(ERROR)|null)                           9*#  - unsets "uncaughtException" handler
                                              9*#  - unsets --abort-on-uncaught-exception
hasUnaughtExceptionCaptureCallback()->BOOL    9*#
node --abort-on-uncaught-exception              #Create a dump file when process exited because of uncaught exception

exit([UINT])                                    #Exit with exit code UINT (def: 0)
                                                #Asynchronous tasks will be aborted (including printing to stdout|stderr)
abort()                                         #Aborts: exits + produce a core file.

pid                                             #
ppid                                          9*#Parent's pid

SIGNALS ==>                                     #Node specifics:
                                                #  - signal 0 can be used to test for process existence
                                                #  - "SIGUSR1" will start debugger (not on Windows)
                                                #  - handling SIGINT|SIGTERM will remove default handler
                                                #  - cannot handle SIGKILL|SIGSTOP
                                                #Only on Linux: SIGPOLL, SIGPWR, SIGUNUSED
                                                #Only on Mac: SIGINFO
                                                #On Windows, only following work:
                                                #  - 0, SIGINT, SIGTERM, SIGKILL
                                                #  - listen only, not kill():
                                                #     - SIGBREAK: CTRL-BREAK on Windows, similar to CTRL-C
                                                #     - SIGHUP: closing cmd.exe window
                                                #     - SIGWINCH, SIGILL, SIGABRT, SIGFPE, SIGSEGV

kill(PID_INT[, 'SIGNAME'|SIGNUM])               #Sends a signal (def: "SIGTERM").
                                                #If PID_INT, doesn't exit, throw exception (can use 0 to just test process existence).
OS.constants.SIGNAME                            #SIGNUM
                                                #SIGNAME is OS-agnostic, SIGNUM is OS-specific
on('SIGNAL', FUNC('SIGNAL'))                    #Fires when signal emitted on current process.

on('unhandledRejection, FUNC(VAL, PROMISE))     #When PROMISE:
                                                #  - is rejected
                                                #  - and has no handler (PROMISE.catch())
on('rejectionHandled, FUNC(PROMISE))            #When adding PROMISE.catch() on a PROMISE that:
                                                #  - was already rejected
                                                #  - and had no handler when it was rejected (i.e. 'unhandledRejection')
                                                #  - and was rejected in a previous macrotask
on('multipleResolves',                       10*#When PROMISE is resolved|rejected more than once
 FUNC(STR, PROMISE, VAL))                    10*#  - including being resolved after being rejected, or vice-versa
                                             10*#STR is 'resolve|reject'. VAL is the resolved|rejected value.
                                             10*#STR|VAL are not the initial resolution|rejection but the extra one.

argv                                            #Command line args as STR_ARR. Doesn't include node options.
                                                #First is "node", second the absolute path of FILE, then the other arguments.
execArgv                                        #Same but only for node options (exclude all STR of argv)
execPath                                        #Absolute path of node executable used.
env                                             #Environment variables, as OBJ. Values are strings.
title                                           #Process title displayed in ps. Read/write. Usually short max length.
node --title STR                             10*#Set PROCESS.title

cwd()->'DIR'                                    #Current directory
                                                #Is the one of the main file. Required files do not change it.
chdir('DIR')                                    #

CROSS-OS ==>                                    #All the following throw on Windows
get[e]gid|[e]uid()                              #
set[e]gid|[e]uid(UINT|STR)                      #
getgroups()
setgroups(STR_ARR)                              #Supplementary GIDs.
initgroups(STR, STR2[_ARR])                     #

umask([UINT])                                   #See below for Windows behavior

version                                         #Node.js version 'vSERMVER'
release.name                                    #'node|io.js'
release.sourceUrl|headersUrl                    #'URL'
release.lts                                     #'NAME' when LTS
versions                                        #OBJ with members node v8 uv zlib ares modules nghttp2 napi llhttp http_parser openssl icu unicode cldr tz
config                                          #Config flags and variables used during compilation, as OBJ

arch                                            #Same as OS.arch()
platform                                        #Same as OS.platform()

memoryUsage()->OBJ                              #OBJ:
                                                #  - rss, heapTotal, heapUsed
                                              7*#  - external
cpuUsage([OBJ])->OBJ                            #OBJ: user|system NUM (time usage, in microseconds)
                                                #If OBJ passed, is difference.
uptime()                                        #
hrtime([VAL])->VAL                              #Current time as [UINT, UINT2], where UINT is seconds and UINT2 nanoseconds.
                                                #Not real time, but arbitrary one just to compare with another time check.
                                                #If VAL passed, is difference.
                                                #Better that using new Date(), notably because ns not ms
                                                #Windows is only 100ns-precise
hrtime.bigint()->BIGINT                      10*#Same but using BIGINT nanosecs instead of [UINT, UINT2]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        CHILD_PROCESS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


spawn(STR[, STR2_ARR][, OPTS])->CHILDPROCESS    #Creates and runs a CHILDPROCESS from command line "STR ...STR2_ARR"
                                                #  - cwd STR (def: null, i.e. current)
                                                #  - env OBJ (def: process.env)
                                                #  - uid|gid UINT (def: current ones)
                                                #  - encoding 'ENCODING' (def: "buffer")
                                                #  - stdio STR_ARR:
                                                #     - how parent can access child's file descriptors
                                                #     - at least first three ones, stdin|out|err, but can continue with fd 3, etc.
                                                #     - among:
                                                #        - "pipe": enable CHILDPROCESS.stdio[FD_INT]|stdin|out|err
                                                #        - "ipc":
                                                #           - enable CHILDPROCESS.send()
                                                #           - can only do it for one file descriptor.
                                                #           - file descriptor will be available in child's ENVVAR NODE_CHANNEL_NUM
                                                #        - "ignore": with nothing
                                                #        - STREAM: pipe file descriptor to it (like NUM> FILE)
                                                #        - FD_INT: same with parent file descriptor (like NUM&>FD_INT)
                                                #        - null|undefined (def): "pipe" for stdin|out|err, "ignore" for others.
                                              8*#     - can use the following shortcuts STR instead:
                                              8*#        - "ignore": [ "ignore", "ignore", "ignore" ]
                                              8*#        - "pipe": [ "pipe", "pipe", "pipe" ]
                                              8*#        - "inherit": [ 0, 1, 2 ]
                                                #  - shell STR3|BOOL (def: false)
                                                #     - false (def): runs 'STR ...STR2_ARR'
                                                #        - on Windows, only works with `*.exe|com|cmd|bat`
                                                #     - STR3: runs 'STR3 -c "STR ...STR2_ARR"'
                                                #        - 'STR3 /d /s /c "STR ...STR2_ARR"' instead if cmd.exe
                                                #     - true: same but using '/bin/sh' (Unix) or ENVVAR ComSpec or 'cmd.exe' (Windows)
                                                #  - windowsVerbatimArguments BOOL:
                                                #     - no shell escaping (Windows only)
                                                #     - def: true if OPTS.shell with 'cmd.exe', false otherwise
                                                #  - argv0 STR (def: STR): process.argv[0]
                                                #     - does not work with node.js binary itself
                                                #     - does not modify `process.title` on Windows
                                                #  - detached BOOL (def: false):
                                                #     - run in background
                                                #     - child process will outlive parent
                                                #        - on Linux, child process always does, even if `detached: false`
                                              8*#  - windowsHide BOOL (def: false):
                                              8*#     - if detached true, in Windows and in terminal, do not create new terminal window
                                                #Use CHILDPROCESS.ref(), so needs to use unref() if program can exit while CHILDPROCESS is running.
fork(STR[, STR2_ARR][, OPTS])->CHILD_PROCESS    #Same as spawn() but using 'node STR ...STR2_ARR'
                                                #OPTS:
                                                #  - shell: always false
                                                #  - stdio: def 'inherit'
                                                #Extra OPTS:
                                                #  - execPath 'PATH': instead of 'node'
                                                #  - execArgv STR_ARR: arguments passed to execPath (e.g. node CLI flags)
                                                #  - silent BOOL (def: false): same as OPTS.stdio 'pipe'
execFile(STR[, STR2_ARR][, OPTS],               #Same as spawn() but using FUNC() instead of returning CHILDPROCESS.
 FUNC(ERROR, SVAL, SVAL2))->CHILD_PROCESS       #  - SVAL|SVAL2 is stdout|stderr
                                                #Cannot use OPTS: stdio, argv0, detached
                                                #Extra OPTS:
                                                #  - encoding 'ENCODING' (def: 'utf-8')
                                                #  - timeout NUM (def: 0) (in ms)
                                                #  - maxBuffer NUM (def: 200KB): stdout|stderr max size
                                                #  - killSignal 'SIGNAL'|SIGNUM (def: 'SIGTERM'): sent (with CHILD_PROCESS.kill()) on timeout|maxBuffer
exec(STR[, OPTS], FUNC(ERROR, SVAL, SVAL2))
 ->CHILD_PROCESS                                #Same as execFile() but with OPTS.shell def true

spawnSync(...)                                  #Like spawn() except for the following.
                                                #Extra OPTS:
                                                #  - input STDBUFFER: overrides OPTS.stdio[0]
                                                #  - encoding (def: 'buffer')
                                                #  - timeout, killSignal, maxBuffer
                                                #Returns:
                                                #  - pid UINT
                                                #  - stdout|stderr SVAL
                                                #  - output [stdout, stderr]
                                                #  - status NUM: null if killed by signal
                                                #  - signal 'SIGNAL'
                                                #  - error ERROR
exec[File]Sync(...)                             #Like exec[File]() except for the following.
                                                #Extra OPTS: input, stdio, detached, argv0
                                                #Returns SVAL (stdout). Throws on non-0 exit code.

CHILDPROCESS.pid                                #

CHILDPROCESS.stdio[FD_INT]                      #I|OSTREAM for file descriptor FD_INT
CHILDPROCESS.stdin|out|err                      #Same for 0|1|2

PROCESS|CHILDPROCESS.send                       #Communication:
(VAL[, TCPSOCKET|TCPSERVER][, OPTS]             #  - parent use CHILDPROCESS.on("message") and CHILDPROCESS.send(...)
[, FUNC([ERROR])])                              #  - child use PROCESS.on("message") and PROCESS.send(...)
                                                #Child process must have been created using "ipc" (see above)
                                                #When sending a TCPSOCKET|TCPSERVER, it will be shared between parent and child:
                                                #  - packets will arrive randomly at both
                                                #  - only one needs to listen
                                                #  - for TCPSERVER, both can listen to 'connection' event
                                                #FUNC is fired after sending, before target received.
                                                #If FUNC specified, no 'error' event emitted.
                                                #OPTS:
                                                #  - keepOpen BOOL (def: false): see TCPSOCKET
CHILDPROCESS.on("message",
FUNC(OBJ[, TCPSOCKET|TCPSERVER]))               #CHILDPROCESS will not exit until disconnect() is called or parent exits.
CHILDPROCESS.disconnect()                       #Flush all communication, then becomes impossible to do send()
                                                #Do it before exiting.
CHILDPROCESS.connected                          #
CHILDPROCESS.on("disconnect", FUNC())           #
CHILDPROCESS.on("error", FUNC(ERROR))           #When CHILDPROCESS could not send(), be kill() or be spawn()
                                                #The exit event might be fired or not after error event.
CHILDPROCESS.on("exit|close", FUNC(UINT,STR))   #UINT is the exit code, STR the terminating signal (or null).
                                                #exit is when process exits, close is when its file descriptors are closed.
                                                #file descriptors don't close if shared by other processes.
CHILDPROCESS.kill(['SIGNAL'|SIGNUM])            #Def: "SIGTERM"
CHILDPROCESS.channel                          7*#Underlying IOSTREAM for send()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CLUSTER            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GOAL ==>                                        #A single process will only use only one CPU core.
                                                #Using CHILDPROCESS.fork() on the same code to create one child for each CPU
                                                #core.
                                                #Can manage the workers: kill some, manage a pool, etc.
                                                #Work should be done by child processes, master should only manage them.
                                                #Child processes cannot fork() to grandchild processes.
                                                #One common task is to make CHILDPROCESS TCPSERVER.listen(), in which case:
                                                #  - connections will arrive randomly at the child processes listening to
                                                #    the same port.
                                                #    The randomness uses CLUSTER.schedulingPolicy:
                                                #      - CLUSTER.SCHED_RR (def on Unix, not supported on Windows): improved round-robin
                                                #      - CLUSTER.SCHED_NONE (def on Windows): previous version
                                                #    or use ENVVAR NODE_CLUSTER_SCHED_POLICY "rr|none"
                                                #  - be careful:
                                                #     - listen(TCPSERVER|TCPSOCKET): TCPSERVER|TCPSOCKET must have been sent by master
                                                #       to child, or will create problems
                                                #     - listen({ fd: INT }): looks at parent file descriptor
                                                #  - if UDPSOCKET.bind() or TCPSERVER.listen() OBJ.exclusive true (def: false), socket is not shared
fork([OBJ])                                     #Like CHILD_PROCESS.fork(), but returns a WORKER, which gives extra functions.
                                                #Can fork a separate file for children, but if forking the same file, should
                                                #use if ( CLUSTER.isMaster|Worker ) in beginning of code.
                                                #OBJ is env (def: process.env).
                                                #Options are controlled by CLUSTER.settings, that is available for read once
                                                #CLUSTER.setupMaster(OBJ) has been called to change it (only once):
                                                #  - exec STR: the file the child is forked with (def: process.argv[1])
                                                #  - args STR (def: process.argv.slice(2)): to worker
                                                #  - execArgv STR_ARR (def: process.execArgv): to node
                                                #  - silent BOOL: like CHILDPROCESS.fork() (def: false)
                                              9*#  - cwd, windowHide
                                                #  - uid|gid UINT, stdio
                                                #setupMaster() fire 'setup'(OBJ) event
on("fork|online", FUNC(WORKER))                 #Fired when a child process is created|ready to respond.
WORKER.on("online", FUNC())                     #
on("listening", FUNC(WORKER, OBJ))              #Fired when a child process use TCPSERVER.listen().
                                                #OBJ has members { address, port, addressType: "[udp]4|6|-1(Unix socket)" }
WORKER.on("listening", FUNC(OBJ))               #

workers                                         #All WORKER in an OBJ, where the key is the WORKER.id
                                                #Only available in parent process.
worker                                          #Current WORKER. Only available in child processes.
WORKER.id                                       #
WORKER.process                                  #The underlying CHILDPROCESS.
                                                #In a WORKER, can use process.* directly

WORKER.send(VAL[,TCPSOCKET|TCPSERVER][, FUNC()])#
WORKER.on
("message", FUNC(OBJ[, TCPSOCKET|TCPSERVER]))   #
on('message', FUNC(WORKER TCPSOCKET|TCPSERVER,
OBJ))                                           #
WORKER.kill(['SIGNAL'])                         #Calls WORKER.disconnect(), then in:
                                                #  - the parent, sends signal (def: "SIGTERM")
                                                #  - the child processes, exit with error code 0

WORKER.disconnect()->WORKER                     #If listen() was called, don't accept new connections and emit TCPSERVER.close()
                                                #when no more connections (only server connections, not CLIENTREQ, that
                                                #are closed directly).
                                                #Might be useful to use a timeout to kill the WORKER if connections keep on
                                                #living.
disconnect(FUNC())                              #Call disconnect() on all child processes (must be done from parent).
on("disconnect", FUNC(WORKER))                  #Fired when a child process use disconnect()
WORKER.on("disconnect", FUNC())                 #
WORKER.isConnected()                            #
WORKER.isDead()                                 #True if exited of thrown exception
WORKER.exitedAfterDisconnect                    #When WORKER exits, will be false if exited because of an exception, and true
                                                #if because of kill() or disconnect()
on("exit", FUNC(WORKER, UINT, 'SIGNAL'|null))   #Fired when a child process exits.
                                                #UINT is the exit code
WORKER.on("exit", FUNC(UINT, 'SIGNAL'|null))    #
WORKER.on("error", FUNC(ERROR))                 #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        WORKER_THREADS         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ISOMORPHISM ==>                              10*#Inspired by DOM workers but with notable differences

node --experimental-worker                   10*#Must be used
                                             11*#Must not be used

MULTI-THREADING ==>                          10*#Uses threads not processes, i.e.:
                                             10*#  - uses OS time slicing i.e.:
                                             10*#     - long microtasks are processed in several steps
                                             10*#     - load between threads is balanced by OS
                                             10*#  - for each time slice, uses any available CPU, i.e. scale to all CPUs
                                             10*#I.e. good for CPU-intensive tasks (not I/O intensive)


new Worker('SCRIPT_PATH'[, OPTS])            10*#OPTS:
                                             10*#  - eval BOOL (def: false): use inline 'JAVASCRIPT' instead
                                             10*#  - workerData VAL:
                                             10*#     - assigned to WORKER_THREADS.workerData VAL
                                             10*#     - same possible types as postMessage()

global.*                                     10*#In worker, like in parent except process.*:
                                             10*#  - exit() affects current thread not current process
                                             10*#  - no abort|chdir|initgroups|set*|umask() nor on('SIGNAL')
                                             10*#  - env|title are read-only
                                             10*#Worker and parent's global|process.* are distinct.
                                             10*#Unlike DOM, no concept of WORKERGLOBAL nor "self".

process.stdin|stdout|stderr                  10*#Worker has different standard streams than parent, but they are piped from|to
                                             10*#parent unless OPTS.stdin|stdout|stderr true (def: false)
WORKER.stdin|stdout|stderr                   10*#Worker's standard streams, available to parent

WORKER_THREADS.isMainThread                  10*#BOOL. True if is top-level parent.

WORKER_THREADS|WORKER.threadId               10*#NUM
                                             10*#Top-level parent is 0. Then increments for each worker

WORKER.on('online', FUNC())                  10*#When worker is loaded, just before it starts executing

WORKER.terminate([FUNC(ERROR, EXIT_CODE)])   10*#Worker current microtask will be interrupted
                                             10*#I.e. should not be done when WORKER might be in the middle of executing a Node.js core function
                                             10*#EXIT_CODE will be 1

WORKER.on('exit', FUNC(EXIT_CODE))           10*#When worker ends (including because of uncaught exceptions)

WORKER.on('error', FUNC(ERROR))              10*#Uncaught exception within worker.

MESSAGEPORT|WORKER.[un]ref()                 10*#


WORKER|MESSAGEPORT.postMessage               10*#Like DOM except:
 (VAL[, VAL2_ARR])                           10*#  - child can only use MESSAGEPORT, not global "postMessage()"
                                             10*#  - VAL2:
                                             10*#     - can be SHARED_ARRBUFFER
                                             10*#     - when MESSAGEPORT, VAL must be MESSAGEPORT
WORKER|MESSAGEPORT.on('message', FUNC(VAL))  10*#Like DOM except:
                                             10*#  - receive VAL directly, not MESSAGEEVENT
                                             10*#  - MESSAGEPORT will keep process open until MESSAGEPORT.close|unref()

new MessageChannel()
MESSAGECHANNEL.port1|2
MESSAGEPORT.start|close()                    10*#Like DOM
MESSAGEPORT.on('close', FUNC())              10*#

WORKER_THREADS.parentPort                    10*#Default MESSAGEPORT available in every worker.
                                             10*#null in parent


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              VM               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ALTERNATIVES ==>                                #When running 'Math.random()'
                                                #Execution time:
                                                #  - as is:  0.000006ms
                                                #  - eval(): 0.0001ms
                                                #  - runIn*Context(): 0.001ms
                                                #     - with SCRIPT: same performance, but can divide between loading (new Script)
                                                #       and executing (SCRIPT.runIn*Context())
                                                #  - spawn(): 1.3ms
                                                #  - Worker(): 6ms
                                                #Security:
                                                #  - as is, eval(): access to current process + context
                                                #  - runIn*Context(): access to current process
                                                #  - Worker(): access to none (providing OPTS.stdin|stdout|stderr true)
                                                #  - spawn(): access to none
                                                #Limits:
                                                #  - as is, eval(): defaults (max call stack, max STR|ARR length)
                                                #  - runIn*Context(): defaults, timeout
                                                #  - Worker(): defaults, seems to crash over 1000 threads
                                                #  - spawn(): defaults, timeout, maxBuffer
                                                #Threads/processes:
                                                #  - as is, eval(), runIn*Context(): same thread|process
                                                #  - Worker(): different thread
                                                #  - spawn(): different process

createContext([CONT_OBJ][, CONT_OPTS])->COBJ    #COBJ is an OBJ with some hidden properties.
                                                #CONT_OBJ is merged in.
                                                #CONT_OPTS:
                                                #  - name STR (def: 'VM Context NUM'): for debugging
                                                #  - origin PROTO://HOST[:PORT] (def: ''): for debugging
                                             10*#  - codeGeneration:
                                             10*#     - strings BOOL (def: true): if false, throws on eval() or derivatives (new Function(...), etc.)
                                             10*#     - wasm BOOL (def: true): if false, throws when trying to compile WASM
isContext(COBJ)->BOOL                           #Returns true if COBJ

runInContext(STR, COBJ[, RUN_OPTS])             #Like eval() but use context COBJ as unique global environment:
                                                #  - passed by reference.
                                                #  - does not have any other access to caller otherwise,
                                                #    including current caller local scope
                                                #Also:
                                                #  - use current process:
                                                #     - same file descriptors
                                                #     - throw exception in current process
                                                #     - should create a new process first if VM used for security reason.
                                                #  - returns synchronous return value from code STR
                                                #     - but can still inspect COBJ passed by reference for async return value,
                                                #       or pass COBJ.FUNC()
                                                #RUN_OPTS:
                                                #  - filename STR, line|columnOffset NUM: for stack trace error message
                                                #  - displayErrors BOOL (def: true): prints to current stderr any stderr
                                                #    from code
                                                #  - timeout NUM: throw error if timeout
runInNewContext(STR[, CONT_OBJ]                 #Same but automatically use createContext(CONT_OBJ, CONT_OPTS)
 [, RUN_OPTS|CONT_OPTS])                        #CONT_OPTS must be prefixed with "context"
runInThisContext(STR[, RUN_OPTS])               #Same as runInNewContext(STR, global)

compileFunction('CODE'[, 'PARAM_NAME'_ARR]   10*#Like new Function() but use OPTS.parsingContext COBJ (def: global)
 [, RUN_OPTS|SCRIPT_OPTS])->FUNC             10*#RUN_OPTS|SCRIPT_OPTS:
                                             10*#  - filename, line|columnOffset, cachedData
                                             10*#  - contextExtensions OBJ_ARR (def: []): objects wrapping COBJ

new Script(STR[, RUN_OPTS|SCRIPT_OPTS])         #Returns a SCRIPT, i.e. a compiled version of STR:
                                                #  - separates compiling from running STR
                                                #  - every run can be bound to different COBJ
                                              8*#SCRIPT_OPTS:
                                              8*#  - cachedData BUFFER:
                                              8*#     - copy of script, to improve load performance
                                             10*#     - created by SCRIPT.createCachedData()->BUFFER
                                              8*#     - V8.cachedDataVersionTag()->NUM returns a hash of v8
                                              8*#       version, CLI flags and CPU features
SCRIPT.runIn[New|This]Context(...)              #Same as run*(STR, ...)
                                                #RUN_OPTS also has:
                                                #  - breakOnSigint BOOL

new SourceTextModule(STR[, MODULE_OPTS])      9*#Same as Script but for ES module
                                              9*#Must use --experimental-vm-modules
                                              9*#MODULE_OPTS:
                                              9*#  - context COBJ: reused by every MODULE.run*(...), i.e. cannot be changed
                                              9*#  - url STR (def: 'vm:module(NUM)'): for debugging
                                              9*#  - filename STR, line|columnOffset NUM: for stack trace error message
VMMODULE.link(FUNC('SPECIFIER',PARENT_MODULE))9*#Specifies the function to resolve SPECIFIERs,
 ->[PROMISE_]VMMODULE                         9*#I.e. same as using import { SPECIFIER } from VMMODULE
                                              9*#Must be called only once.
                                              9*#MODULE and PARENT_MODULE must have same COBJ
VMMODULE.linkingStatus                        9*#Can be:
                                              9*#  - 'unlinked': before VMMODULE.link()
                                              9*#  - 'linking': during VMMODULE.link()
                                              9*#  - 'linked': after VMMODULE.link() success
                                              9*#  - 'errored': after VMMODULE.link() error
VMMODULE.error                                9*#If linkingStatus 'errored', contains link() rejected promise value.
                                              9*#Otherwise, accessing it throws an exception.
VMMODULE.instantiate()                        9*#Might throw if problem importing|exporting
                                              9*#The function is memoized.
                                              9*#Must be called after VMMODULE.link()
VMMODULE.evaluate([RUN_OPTS])->PROMISE(VAL)   9*#Runs the code.
                                              9*#Must be called after VMMODULE.instantiate()
                                              9*#RUN_OPTS: timeout, breakOnSigint
VMMODULE.url                                  9*#
VMMODULE.namespace                            9*#
VMMODULE.dependencySpecifiers                 9*#All 'MODULE'_ARR imported by that module


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CRYPTO             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


setEngine(PATH[, NUM])                          #When using custom OpenSSL or alternative crypto library.
                                                #NUM are or'd flags: ENGINE_METHOD_ALL|RSA|DSA|DH|RAND|ECDH|ECDSA|CIPHERS|
                                                #DIGESTS|STORE|PKEY_[ASN1_]METH|NONE
node --openssl-config=FILE
OPENSSL_CONF=FILE ENVVAR                      6*#

createHash(STR)                                 #Returns a HASH, i.e. a IOSTREAM generator: write|read to it to get hashes.
                                                #STR is the algo.
                                                #CRYPTO.getHashes() gives list of supported hashes algos, as STR_ARR:
                                                #includes [EC]DSA, DSS1, MD4|5, RIPEMD, RMD, SHA1|224|256|384|512, Whirlpool
createHmac(STR, STDBUFFER|KEY)                  #Same but for a HMAC. STR is hash algo. Second argument is the key.
createCipheriv(STR, STDBUFFER|KEY,STDBUFFER|null#Same but for a CIPHER (sym. cipher).
 [, OPTS])                                      #Key must be KEY|TDBUFFER or STR with encoding "binary".
                                                #Third argument is IV.
                                              9*#  - can be null
                                                #CRYPTO.getCiphers() gives list of supported sym. ciphers (including mode of
                                                #operation), as STR_ARR: includes AES, Blowfish, Camellia, CAST, DES, DES3,
                                                #DES-X, IDEA, RC2, RC4, SEED,
                                             11*#ChaCha
                                                #OPTS:
                                                #  - any of STREAM.Transform()
                                              9*#  - authTagLength NUM (def: 16): 4-16 (must be even number)
CIPHER.setAutoPadding(BOOL)                     #If false (def: true), disables padding (PKCS padding).
                                                #Use it for personalized padding, i.e. filling with nulls.
CIPHER.getAuthTag()->BUFFER                     #Returns MAC, for sym. ciphers that produce one ("authenticated
                                                #encryption"), i.e. "GCM" only.
CIPHER.setAAD(BUFFER)->BUFFER2                  #Same but for "additional authenticated data" ("GCM" only)
createDecipheriv(...)
DECIPHER.setAutoPadding(BOOL)                   #Same for decryption.
DECIPHER.setAuthTag(TDBUFFER)                   #
DECIPHER.setAAD(BUFFER)                         #

createDiffieHellman(ARGS)                       #Creates a DIFFIEHELLMAN (used for asym. encryption with HL algo).
                                                #ARGS can be:
                                                #  - NUM[, NUM2]: prime length NUM and generator NUM2 (def: 2).
                                                #  - STDBUFFER[, ENCODING][, NUM|STDBUFFER2[, ENCODING2]]: prime STDBUFFER
                                                #    (def ENCODING: "buffer", can also be "binary|base64") and generator
                                                #    NUM|STDBUFFER2 (def: 2)
DIFFIEHELLMAN.getPrime([ENCODING])->SBUFFER     #
DIFFIEHELLMAN.getGenerator([ENCODING])->SBUFFER #
DIFFIEHELLMAN.generateKeys([ENCODING])->SBUFFER #Creates private and public key, and returns public key.
DIFFIEHELLMAN.getPublic|PrivateKey([ENCODING])
 ->SBUFFER                                      #
DIFFIEHELLMAN.setPublic|PrivateKey
 (STDBUFFER, [ENCODING])                        #
DIFFIEHELLMAN.computeSecret(STDBUFFER           #Creates shared secret by using current private key and other part public key
[, ENCODING][, ENCODING2])->SBUFFER             #STDBUFFER (must have used the same prime and generator)
                                                #ENCODING is other part public key encoding, ENCODING2 shared secret returned.
DIFFIEHELLMAN.verifyError                       #Or'd flags showing warning after initialization among:
                                                #  - CRYPTO.DH_CHECK_P_NOT_SAFE_PRIME
                                                #  - CRYPTO.DH_CHECK_NOT_PRIME
                                                #  - CRYPTO.DH_UNABLE_TO_CHECK_GENERATOR
                                                #  - CRYPTO.DH_NOT_SUITABLE_GENERATOR
getDiffieHellman(STR)                           #Returns a DIFFIEHELLMAN but:
                                                #  - without setPublic|PrivateKey()
                                                #  - according to STR "modp1|2|5|14|15|16|17|18", i.e. prime is constant, but
                                                #    it is faster

createECDH(STR)                              10*#Returns ECDH, elliptic curve version of Diffie-Hellman.
                                             10*#Same as DIFFIEHELLMAN but:
                                             10*#  - last arg FORMAT "[un]compressed|hybrid" (def: "uncompressed") to generateKeys() and getPublicKeys()
                                             10*#  - no getPrime(), getGenerator(), verifyError, setPublicKey()
                                             10*#STR is algo, from CRYPTO.getCurves() as STR_ARR: includes Oakley, brainpool,
                                             10*#c2tnb, prime, secp, sect, wap-wsg-idm-ecid-wtls
ECDH.convertKey(STDBUFFER, 'ALGO'[, ENCODING]
 [, ENCODING2], FORMAT)->SBUFFER             10*#Converts public key STDBUFFER to FORMAT

public|privateEncrypt|Decrypt                   #Encrypts/decrypts asym. (RSA) TDBUFFER, with private|public key STR|KEY|OBJ:
 (STR|KEY|OBJ, TDBUFFER)                        #  - key, format, type, passphrase: like createPrivate|PublicKey()
                                                #  - padding: CRYPTO.constants.RSA_NO|PKCS1[_OAEP]_PADDING

generateKeyPair[Sync]('TYPE', OPTS           10*#Create asym key pair, where SBUFFER is publicKey and SBUFFER privateKey
 [, FUNC(ERROR, SBUFFER, SBUFFER2)])         10*#'TYPE' is 'rsa', 'dsa' or 'ec'
 [->{ publicKey|privateKey }]                10*#OPTS:
                                             10*#  - publicKeyEncoding OBJ (def: produces a KEY):
                                             10*#     - type 'pkcs1' (RSA only) or 'spki' (prefered)
                                             10*#     - format 'pem' or 'der'
                                             10*#  - privateKeyEncoding OBJ (def: produces a KEY):
                                             10*#     - type 'pkcs1' (RSA only), 'sec1' (EC only) or 'pkcs8' (prefered)
                                             10*#     - format 'pem' or 'der'
                                             10*#     - cipher 'ALGO', passphrase STR: encrypt using PKCS#5 2.0
                                             10*#  (RSA, DSA)
                                             10*#  - modulusLength NUM: key size (in bits)
                                             10*#  (RSA)
                                             10*#  - publicExponent NUM (def: 0x10001): public exponent
                                             10*#  (DSA)
                                             10*#  - divisorLength NUM: q size (in bits)
                                             10*#  (EC)
                                             10*#  - namedCurve STR: curve name

createPrivate|PublicKey(OPTS|SBUFFER)->KEY   11*#Create asym key pair. OPTS:
                                             11*#  - key SBUFFER
                                             11*#  - format 'pem' (def) or 'der': of key
                                             11*#  - type 'pkcs1', 'spki' or (privateKey only) 'sec1': ignored if format 'pem'
                                             11*#  - passphrase SBUFFER (privateKey only)
createSecretKey(BUFFER)->KEY                 11*#Create sym key.

KEY.type                                     11*#'public|private' (if async) or 'secret' (if sync)
KEY.asymmetricKeyType                        11*#'rsa', 'dsa', 'ec' or (if sym key) undefined
KEY.symmetricSize                            11*#Byte length NUM. undefined if async
KEY.export([OPTS])->SBUFFER                  11*#OPTS (if async):
                                             11*#  - type, format, passphrase: like createPrivate|PublicKey()
                                             11*#  - cipher STR

createSign(STR)                                 #Same as createDecipher() but for signing algo STR.
                                                #List can be found with openssl list-public-key-algorithms.
                                                #Includes RSA, DH, DSA, HMAC and CMAC.
                                                #Unless createCipher(), is only a OSTREAM. To read from it, use
                                                #SIGN.sign(SBUFFER|KEY|OPTS[, ENCODING]), where SBUFFER|OPTS|KEY is the private key.
                                                #OPTS:
                                                #  - key, format, type, passphrase: like createPrivateKey()
                                                #  - padding CRYPTO.constants.RSA_PKCS1_[PSS_]PADDING
                                                #  - saltLength NUM, can be:
                                                #     - CRYPTO.constants.RSA_PSS_SALTEN_DIGEST: digest size
                                                #     - CRYPTO.constants.RSA_PSS_SALTEN_MAX_SIGN
createVerify(STR)                               #Same for verifying algo STR.
                                                #Like createSign(), is only a OSTREAM.
VERIFY.verify                                   #Read from createVerify()
 (SBUFFER|KEY|OBJ, STDBUFFER[,ENCODING])        #SBUFFFER is a certificate or a RSA|DSA public key in PEM format
                                             11*#or a private key
                                                #OBJ: padding, saltLength
                                                #STDBUFFER is the signature.

Certificate()                                 9*#Returns CERTIFICATE, used for SPKAC, used to send certificates client-side to
                                              9*#the server with the HTML5 <keygen>.
CERTIFICATE.verifySpkac(TDBUFFER)->BOOL       9*#
CERTIFICATE.exportChallenge|PublicKey
(STDBUFFER[, ENCODING])->BUFFER               9*#

pbkdf2[Sync](STBUFFER, STBUFFER2, NUM, NUM2,    #Generate a random BUFFER using PBKDF2 with HMAC-SHA1, with first arg being
DIGEST[, FUNC(ERROR, BUFFER)])[->BUFFER]        #the input, second the salt (should be min. 64 bits), NUM the number of
                                                #iterations (should be min. 1000) and NUM2 the final string length.

scrypt[Sync](STDBUFFER, STDBUFFER2, NUM      10*#Generate a derived key BUFFER using Scrypt.
 [, OPTS][, FUNC(ERROR, BUFFER)])[->BUFFER]  10*#First arg is the password, second is the salt (should be 16 bytes long), NUM is BUFFER length.
                                             10*#OPTS:
                                             10*#  - cost|N NUM (def: 16384): CPU/memory cost. Must be power of 2
                                             10*#  - blockSize|r NUM (def: 8): block size
                                             10*#  - parallelization|p NUM (def: 1): parallelization
                                             10*#  - maxmem NUM (def: 32MB): memory bound. Must be > 128*N*r

randomBytes(NUM[, FUNC(ERROR, BUFFER)])         #Generates random BUFFER of length NUM
                                                #Is cryptographically secure (e.g. from /dev/random)
                                                #If no FUNC, synchronous (returns BUFFER)
randomFill[Sync](TDBUFFER[, NUM[, NUM2]]        #Like randomBytes() but by filling in a TDBUFFER instead, from offset NUM
[, FUNC(ERROR, TDBUFFER)])[->BUFFER]            #(def: 0) with length NUM2 (def: TDBUFFER.lBUFFER.length).

getFips()->BOOL                              10*#True if Node has been:
                                             10*#   - built to be FIPS-compliant (by def, is not)
                                             10*#   - run with node --enable-fips or (same but cannot modify CRYPTO.fips) --force-fips
setFips(BOOL)                                10*#

timingSafeEqual(TDBUFFER, TDBUFFER2)->BOOL      #Like TDBUFFER.equals(TDBUFFER2), but protected against timing attacks


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ASSERT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ASSERT                                          #Throws ERROR or ASSERTIONERROR with message 'MESSAGE' if fails.
ASSERT.*(..., 'MESSAGE'|ERROR)                  #Can be always passed as last argument (except ifError()). Def:
                                                #  - [not]equal|ok(): 'VAL ==|!= VAL2'
                                                #  - [not]DeepEqual(): 'VAL [not]DeepEqual VAL2'
                                                #  - fail(): 'Failed'
                                                #  - strictEqual(): diff
                                                #  - others: sentence

ASSERTIONERROR.actual|expected                  #VAL
                                                #With *equal|ok|ifError()
                                                #Does a colored diff
ASSERTIONERROR.operator                         #'==' (equal|ok()) or '!=' (notEqual()), 'fail' (fail()), 'FUNC' (others)

ASSERT.strict.*(...)                          9*#Same as ASSERT.*(...) except:
                                              9*#  - use == instead of ===
                                              9*#  - when arguments are OBJ, prints an OBJ diff instead of showing them in full

ASSERT.fail()                                   #Always fails

ASSERT.[not]equal(VAL, VAL2)                    #VAL == VAL2
ASSERT.[not]strictEqual(VAL, VAL2)              #Object.is(VAL, VAL2)
ASSERT.[not]deepStrictEqual(VAL, VAL2)          #UTIL.isDeepStrictEqual()

ASSERT[.ok](VAL)                                #VAL === true

ASSERT.ifError(VAL)                             #VAL === null

ASSERT.throws|doesNotThrow(FUNC()[, VAL])       #Function throws
                                                #VAL can be:
                                                #  - TYPE|ERROR: instanceof
                                                #  - FUNC(ERROR)->BOOL
                                                #  - REGEXP: against ERROR.message
                                             10*#  - OBJ: deep ==
ASSERT.rejects|doesNotReject                 10*#PROMISE rejection
 (PROMISE[()][, VAL])->PROMISE2              10*#Fails if FUNC()->PROMISE throws before returning the PROMISE
                                             10*#Fails if not using a PROMISE[()]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONSOLE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CONSOLE.*                                       #Like DOM utilities except:
                                                #  - uses UTIL.inspect|format()
                                                #     - with OPTS.colors true, unless inside a WORKER
                                                #  - console.dir(VAL, ...) -> console.log(inspect(VAL, ...))
                                                #  - console.assert() can use format strings
                                                #Includes:
                                              8*#  - console.clear|count[Reset]|debug|dirxml|group[Collapsed|End]|
                                              8*#    markTimeline|profile[End]|timeStamp|timeline[End]()
                                             10*#  - console.table|timeLog()

new Console(OPTS)                               #Returns CONSOLE, same as console but with different stdout|stderr
new Console(OSTREAM[, OSTREAM2][, BOOL])     10*#OPTS:
                                                #  - stdout OSTREAM, stdout OSTREAM2
                                              8*#  - ignoreErrors BOOL (def: true): ignore errors on OSTREAM[2]
                                             10*#  - colorMode BOOL or 'auto' (def, depends on OSTREAM.isTTY|getColorDepth())
                                             11*#  - inspectOptions OPTS: passed to UTIL.inspect()

STDERR ==>                                      #Uses by:
                                                #  - CONSOLE.warn|error() (not other CONSOLE.*)
                                                #  - unhandled exception or promise rejection
                                                #  - process.emitWarning()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          PERF_HOOKS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


performance                                   8*#Like DOM (see doc), except:
PERFORMANCE                                   8*#  - different entryTypes:
PERFENTRY.*                                   8*#     - keep 'mark' and 'measure'
PERFOBSERVER                                  8*#     - 'timing' PERFORMANCETIMING -> 'nodeTiming' PERFNODETIMING
                                              8*#     - no 'navigation' PERFORMANCENAVIGATION
                                              8*#     - also has 'gc' and 'function'
                                              8*#  - no PERFORMANCE.clearMeasures|getEntries*() (but PERFLIST.getEntries*() are kept)
                                              8*#  - PERFOBSERVER.observe OPTS.buffered BOOL:
                                              8*#     - if false (def), fire listener callbacks sync
                                              8*#     - if true, use setImmediate()
                                              8*#  - PERFOBSERVER is an ASYNCRESOURCE
                                              8*#  - DOMTIMESTAMP is nanoseconds-precise

PERFORMANCE.timeOrigin                        8*#DOMGLOBALTIME base of DOMLOCALTIME, i.e. when process started.
                                              8*#Use same logic as process.hrtime() (i.e. arbitrary number),
                                              8*#but as a DOMETIMESTAMP

PERFORMANCE.nodeTiming                        8*#PERFNODETIMING, which is a PERFENTRY with:
                                              8*#  - entryType 'node'
                                              8*#  - name 'node'
                                              8*#  - startTime: same as PERFORMANCE.timeOrigin
                                              8*#  - duration: same as PERFORMANCE.now() - PERFORMANCE.timeOrigin
                                              8*#Is similar to PERFORMANCENAVIGATION, but for Node
PERFNODETIMING.*                              8*#The following use same same logic as process.hrtime(), but in ns
PERFNODETIMING.nodeStart                      8*#Node process started
PERFNODETIMING.v8Start                        8*#v8 process initialized
PERFNODETIMING.environment                    8*#Environment initialized
PERFNODETIMING.bootstrapComplete              8*#End of all require()
PERFNODETIMING.loopStart                      8*#Start of event loop
PERFNODETIMING.loopExit                       8*#End of event loop. Not sure when it is not 0

PERFGCTIMING                                  8*#PERFENTRY for garbage collector, with:
                                              8*#  - entryType 'gc'
                                              8*#  - name 'gc'
                                              8*#  - startTime
                                              8*#  - duration DOMTIMESTAMP
                                              8*#  - kind: constants.NODE_PERFORMANCE_GC_MINOR|MAJOR|INCREMENTAL|WEAKCB (1|2|4|8)

PERFORMANCE.timerify(FUNC)->FUNC              8*#Make FUNC(...) create a PERFENTRY with:
                                              8*#  - entryType 'function'
                                              8*#  - duration: how long FUNC() took
                                              8*#  - name FUNC.name (without 'timerified ')
                                              8*#  - startTime DOMLOCALTIME
                                              8*#Prepend 'timerified ' to FUNC.name
                                              8*#Does not await return value if it is a PROMISE


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             I18N              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ICU DATA                                        #I18n dataset used by:
                                                #  - JavaScript-aware functions: STR.normalize|toLowerCase|toUpperCase(),
                                                #    STR|NUM|DATE.toLocale*(), STR.localeCompare(), Intl, URL,
                                                #    TEXTENCODER|TEXTDECODER
                                                #  - BUFFER.transcode()
                                                #How many languages are included depends on:
                                                #  - compile-time flag --with-intl=STR:
                                                #     - 'full'
                                                #     - 'small-icu' (def on all OS):
                                                #        - supports: STR.normalize|toLowerCase|toUpperCase(), STR.toLocale*(),
                                                #          STR.localeCompare(), URL, BUFFER.transcode()
                                                #        - not supported: Intl, NUM|DATE.toLocale*(), TEXTENCODER|TEXTDECODER
                                                #     - 'system-icu':
                                                #        - same as 'small-icu', except link to ICU dataset dynamically instead
                                                #          of statically
                                                #        - i.e. depends whether OS includes ICU databaset, which most Linux do
                                                #     - 'none': no i18n, and STR.normalize(), Intl and BUFFER.transcode() fail
                                                #  - ENVVAR NODE_ICU_DATA=FILE
                                                #  - node --icu-data-dir=FILE
                                                #Can use package full-icu to down ICU dataset manually.

process.versions.icu                            #'VERSION'|undefined

ENCODING                                        #Either: ascii, utf8 (def), urf16le|ucs2, base64, hex, binary (actually latin-1)
                                                #For TEXTDECODER|TEXTENCODER, it is different (see DOM doc), and depends on ICU:
                                                #  - always: 'utf-8' (def), 'utf-16le'
                                                #  - if 'small|system-icu': 'utf-16be'
                                                #  - if 'full' ICU: many more (see online doc)

UTIL.TextDecoder|TextEncoder                  8*#See DOM doc.
TextDecoder|TextEncoder                      11*#


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             UTIL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


inspect(VAL[, OBJ])                             #Print function used by repl. Returns as STR.
                                                #OBJ members are:
                                                #  - showHidden BOOL: if false (def), doesn't show non-enumerable properties,
                                                #    except SYMs
                                                #  - depth NUM (def: 2): max recursion (null|Infinity for infinite)
                                      11.0-11.3*#    Def: 20
                                                #  - maxArrayLength NUM (def: 100) (null for infinite)
                                                #  - breakLength NUM (def: 60) (null for infinite): maxlength to print OBJ in multiline
                                              9*#  - compact BOOL (def: true): if false, adds more newlines and break long lines
                                                #  - colors BOOL (def: false)
                                                #  - customInspect BOOL (def: true):
                                                #     - call VAL[SYM](UINT[, OBJ])->STR if it exists
                                                #     - SYM is util.inspect.custom
                                             10*#       or Symbol.for('nodejs.util.inspect.custom')
                                                #  - showProxy BOOL: if true (def: false), dereference PROXY (to their target)
                                             10*#  - sorted BOOL (def: false) or FUNC('KEY', 'KEY2')->-1|0|1
                                             11*#  - getters BOOL (def: false) or 'get|set' (only getters with|without a set()):
                                             11*#    show getters values
                                                #Can change inspect.defaultOptions
                                                #require("buffer").INSPECT_MAX_BYTES: number of bytes printed for BUFFER
                                                #(def: 50)
                                             11*#Max output 128MB
inspect.colors                                  #OBJ with members defining colors. styles points category (e.g. number) to
inspect.styles                                  #color category, and colors point color category to color codes.

format(STR[, STR2...])                          #Printf-like FUNC, STR can contain:
                                                #  - "%s": STR
                                                #  - "%d", "%i": INT|BIGINT
                                                #  - "%f": FLOAT
                                                #  - "%j": JSON. Prints '[Circular]' on circular references. Handles toJSON()
                                              8*#  - "%O": OBJ. Uses UTIL.inspect() with default options
                                              8*#  - "%o": OBJ. Uses UTIL.inspect() with options: showHidden true, depth 4, showProxy true
                                      11.0-11.3*#    depth 20
                                                #  - "%%": escape
formatWithOptions(OBJ, ...)                  10*#Like format(...) except if can specify inspect() options OBJ

debuglog(STR)                                   #Returns FUNC() that works like console.error() except:
                                                #  - appends STR
                                                #  - noop unless envvar NODE_DEBUG "STR2,..." (can include *) includes STR

promisify(FUNC(..., FUNC2(ERROR, VAL)))->FUNC 8*#Transform FUNC so FUNC(...)->PROMISE(ERROR|VAL)
                                              8*#If calling FUNC(..., FUNC2), FUNC2 still gets called, and PROMISE do not get
                                              8*#resolved|rejected
                                              8*#If FUNC throws, PROMISE gets rejected.
                                              8*#For this to work:
                                              8*#  - FUNC2 does not have to be last argument in FUNC declaration
                                              8*#  - but caller must specify all arguments up to FUNC2
                                              8*#If FUNC[util.promisify.custom] FUNC3 is defined, returns FUNC3 instead.
                                              8*#  - this is defined for setTimeout|setImmediate(), i.e. can be used even
                                              8*#    though callback is first parameter
                                              8*#Polyfill/ponyfill 'util.promisify' (1.0.0)
callbackify(FUNC()->PROMISE)
 ->FUNC(..., FUNC2(ERROR, VAL))               8*#Inverse. FUNC will not return PROMISE anymore

isDeepStrictEqual(VAL, VAL2)                  9*#Does a deep Object.is()
                                              9*#Does not compare non-enumerable properties

inherits(TYPE_FUNC, TYPEPARENT_FUNC)            #Makes TYPE inherits from TYPEPARENT, i.e. executes:
                                                #  TYPE.prototype = Object.create(TYPEPARENT.prototype)
                                                #  TYPE.prototype.constructor = TYPE
                                                #Also creates a TYPE.super_ that points to TYPEPARENT
                                                #Since it does not use OBJ in Object.create(), needs to create own static
                                                #members with TYPE.prototype.VAR = VAL


types.isRegExp(VAL)->BOOL                    10*#True if REGEXP
types.isDate(VAL)->BOOL                      10*#True if DATE
types.isPromise(VAL)->BOOL                   10*#True if PROMISE
types.is[Weak]Map|Set(VAL)->BOOL             10*#True if [WEAK]MAP|SET
types.isNativeError(VAL)->BOOL               10*#True if instanceof ERROR
types.isProxy(VAL)->BOOL                     10*#True if PROXY

types.isArgumentsObject(VAL)->BOOL           10*#True if arguments

types.isAsyncFunction(VAL)->BOOL             10*#True if async FUNC

types.isGeneratorFunction(VAL)->BOOL         10*#True if FUNC *
types.isGeneratorObject(VAL)->BOOL           10*#True if return value of FUNC * (not just any ITERABLETOR)
types.isMap|SetIterator(VAL)->BOOL           10*#True if MAP|SET.keys|values|entries|Symbol.iterator()

types.is[Shared|Any]ArrayBuffer|DataView|
 TypedArray|[Big]Int|Uint|Float*Array(VAL)
 ->BOOL                                      10*#True if [SHARED]ARRAYBUFFER|DATAVIEW|TYPED_ARR|UINT|INT|FLOAT*ARRAY

types.isBoolean|Number|StringObject(VAL)
 ->BOOL                                      10*#True if new Boolean|Number|String(VAL) (not Boolean|Number|String(VAL))
types.isSymbolObject(VAL)->BOOL              10*#True if Object(Symbol(VAL)) (not Symbol(VAL))
types.isBoxedPrimitive(VAL)->BOOL            10*#True if new Boolean|Number|String(VAL) or Object(Symbol|BigInt(VAL))

types.isModuleNamespaceObject(VAL)->BOOL     10*#True if OBJ from import * as OBJ
types.isWebAssemblyCompiledModule(VAL)->BOOL 10*#True if compiled WASM
types.isExternal(VAL)->BOOL                  10*#True if external C/C++ value


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              V8               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


getHeapStatistics()->OBJ                        #OBJ:
                                                #  - total|used_heap_size[_executable] NUM
                                                #  - total_physical|available_size NUM
                                                #  - heap_size_limit NUM
                                              7*#  - [peak_]malloced_memory NUM
                                              7*#  - does_zap_garbage BOOL
getHeapSpaceStatistics()->OBJ                   #OBJ:
                                                #  - space_name STR
                                                #  - space_[used|available_]size NUM
                                                #  - physical_space_size NUM
setFlagsFromString('--OPT ...')                 #Additional v8 CLI options

serialize(VAL)->BUFFER
deserialize(BUFFER)->VAL                      8*#Serialize|deserialize according to structured clone algorithm (see JavaScript doc)

NODE_V8_COVERAGE=DIR                         10*#See v8 coverage doc
