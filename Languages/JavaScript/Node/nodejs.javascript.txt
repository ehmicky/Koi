
          
   NODEJS  
          



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         COMMAND LINE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PURPOSE ==>                                     #Execute JavaScript code server-side
                                                #Based on Chrome JavaScript engine V8

VERSION ==>                                     #12.7.0 (current), 10.16.0 (active LTS), 8.16.0 (active LTS)
                                                #Branches:
                                                #  - "current": latest major version. New one every 0.5 years
                                                #  - LTS: every even-numbered version
                                                #     - when not current anymore, becomes "active LTS" (only bug fixes) for 1.5 years
                                                #     - then "maintainance LTS" (only critical bug fixes) for 1 more year
                                                #  - non-LTS also have a maintainance period of 0.5 years
                                                #Features are often backported.
                                                #For libraries I should support >=8.12.0
                                            NUM*#Means introduced by NUM.*.*

ES6 ==>                                         #Support is documented in JavaScript doc

node[js] [--] [FILE] [FILE_ARGS]                #Command-line
node[js] -e|--eval|-p|--print STR [--] [ARGS]   #nodejs is symlink to node (prefer the later as this is what nvm uses).
                                                #FILE is JavaScript file (def: stdin). Can be - too
                                                #With -e, evaluates STR
                                                #With -p, evaluates STR, and prints last return value.
                                             10*#All CLI flags can use underscores instead of dashes
NODE_OPTIONS=--OPT,... ENVVAR                   #Same as using node --OPT ...
--v8-options                                    #Prints available v8 options.
process.allowedNodeEnvironmentFlags          10*#Read-only SET with all available NODE_OPTIONS

-i
--interactive                                   #Enters REPL even if stdin does not come from a terminal
-c
--check                                         #Run-dry (syntax check)

--completion-bash                               #Output Bash completion script (for CLI flags)

#!/usr/bin/env node                             #Shabang to execute a Node file directly with ./FILE

npm                                             #Node packet manager (see doc)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          EVENT QUEUE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


clear|setTimeout|Interval(...)                  #Like DOM ones (see DOM doc), but extra members
clear|setImmediate(...)                         #
ID.[un]ref()->ID                                #Yield the macrotask (see JavaScript doc)
ID.hasRef()->BOOL                            11*#
ID.refresh()->ID                             10*#Reset the counter

queueMicrotask(FUNC())                       11*#Add a new microtask (see JavaScript doc)
                                            <12*#Experimental (throw warning)
process.nextTick(FUNC()[, ...])                 #Add a new microtask (see JavaScript doc)
                                                #As opposed to queueMicrotask(), always processed before other microtasks,
                                                #including when calling itself recursively.,


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ASYNC HOOKS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TASK_ID                                         #Microtask ID
                                                #Is incrementing counter, with top-level microtask having ID 1
                                                #Specifics:
                                                #  - ID 0 means executed from C++, not JavaScript
                                                #  - PROMISE report parent microtask's, not their actual microtask ID, unless
                                                #    an enabled HOOK exists
                                                #  - async|await (but PROMISE) report parent microtask's, not their actual microtask ID
RESOURCE                                        #Any resource, firing 0, 1 or several microtasks (depends on RESOURCE_TYPE)
                                                #RESOURCE properties depend on RESOURCE_TYPE. They might not be populated yet in init()
RESOURCE_TYPE                                   #Can be:
                                                #  - TickObject: process.nextTick()
                                                #     - properties: callback FUNC, [args 'VAL'_ARR]
                                                #  - Immediate: setImmediate()
                                                #     - properties: _onImmediate FUNC, [_argv 'VAL'_ARR]
                                                #  - Timeout: setTimeout|setInterval()
                                                #     - properties:
                                                #        - _onTimeout FUNC
                                                #        - _idleTimeout NUM
                                                #        - _repeat null|NUM: same but null with setTimeout()
                                                #        - [_timerArgs 'VAL'_ARR]
                                                #  - TIMERWRAP: setTimeout|setInterval()
                                                #  - PROMISE:
                                                #     - on:
                                                #        - new Promise(FUNC), Promise.resolve|reject()
                                                #        - PROMISE.then|catch|finally(FUNC), await PROMISE
                                                #        - calling an async FUNC
                                                #     - properties:
                                                #        - isChainedPromise BOOL:
                                                #           - true if resolving|rejecting with another PROMISE2
                                                #           - including await PROMISE, resolve|reject(PROMISE) or
                                                #             return PROMISE in then|catch|finally()
                                                #  - TTYWRAP: console.*
                                                #     - properties: callback FUNC, [args 'VAL'_ARR]
                                                #  - SIGNALWRAP: OS signal
                                                #  - FSEVENTWRAP, FSREQWRAP, GETADDRINFOREQWRAP, GETNAMEINFOREQWRAP, HTTPPARSER,
                                                #    JSSTREAM, PIPECONNECTWRAP, PIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,
                                                #    STATWATCHER, TCPCONNECTWRAP, TCPSERVER, TCPWRAP, UDPSENDWRAP, UDPWRAP,
                                                #    WRITEWRAP, ZLIB, SSLCONNECTION, PBKDF2REQUEST, RANDOMBYTESREQUEST, TLSWRAP: others

executionAsyncId()->TASK_ID                     #Current microtask
triggerAsyncId()->PARENT_TASK_ID                #Parent microtask, i.e. caller

createHook(OPTS)->HOOK                          #Fires callbacks on new microtasks|resources, using OPTS:
                                                #  - init(TASK_ID, RESOURCE_TYPE, PARENT_TASK_ID, RESOURCE):
                                                #     - when RESOURCE is initialized.
                                                #  - before|after(TASK_ID):
                                                #     - before|after each microtask starts|ends
                                                #     - since some RESOURCE create no microtasks, or several,
                                                #       this might not be called, or be called several times
                                                #  - destroy(TASK_ID): when RESOURCE is destroyed
                                                #  - resolve(TASK_ID):
                                                #     - when a PROMISE is resolved|rejected, including to another PROMISE2
                                                #     - only for RESOURCE_TYPE PROMISE
                                                #Exceptions thrown in callbacks are uncaught exceptions, but cannot be handled.
                                                #Doing async operations (i.e. creating microtasks) inside callbacks:
                                                #  - can cause infinite recursion
                                                #  - this includes console.*(), which can be replaced e.g. by
                                                #    fs.writeSync(1, util.format(VAL))
HOOK.enable|disable()->HOOK                     #HOOK callbacks will only be fired in enabled (disabled by def)

new AsyncResource('RESOURCE_TYPE'[, OPTS])      #Custom RESOURCE
                                                #OPTS:
                                                #  - triggerAsyncId PARENT_TASK_Id (def: executionAsyncId())
                                                #  - requireManualDestroy BOOL: if false (def), calls emitDestroy() when object
                                                #    is garbage collected
ASYNCRESOURCE.runInAsyncScope
 (FUNC[, THIS][, ...ARGS])                      #This is automatically create a new TASK_ID and call 'before|after' events
ASYNCRESOURCE.emitDestroy()                     #
ASYNCRESOURCE.asyncId()->TASK_ID                #
ASYNCRESOURCE.triggerId()->PARENT_TASK_ID       #

--no-force-async-hooks-checks                   #Do not do extra runtime checks related to async hooks


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           DEBUGGER            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--inspect[-brk][=[HOST:]PORT] ...               #Launches node ... but with debugger server.
                                                #Must connect to it with a debugger client:
                                                #  - go to chrome://inspect and click on a link to open devtools
                                                #  - or directly click on the Node symbol in devtools
                                                #Also forwards console messages
                                                #If -brk, will put breakpoint at first line
                                                #  - unless -brk, breakpoints are ignored until a client is connected
                                                #HOST: def 127.0.0.1
                                                #PORT: def 9229, 0 for "any available"
                                                #Child processes must be started with node --inspect as well
--inspect-publish-uid=STR,...                   #How the debugging information is communicated among:
                                                #  - 'http' (def): endpoint at HOST:PORT/json/list
                                                #  - 'stderr' (def)

IRON-NODE ==>                                  ##Another way to debug is to use Electron.
JAM3 DEVTOOL ==>                               ##Those two apps do this
                                               ##There are many problems I encountered with those, so I prefer node --inspect


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ERROR             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ERROR                                           #Are v8 errors, i.e. what follows is shared by Chrome
                                                #See JavaScript doc for more information, including on async stack trace

Error.captureStackTrace(OBJ[, FUNC])            #Adds OBJ.stack, unless already exists
                                                #Automatically done by ERROR, i.e. Error.captureStackTrace(ERROR) is useless
                                                #If FUNC, stops stack frame at FUNC
--stack-trace-limit=NUM
Error.stackTraceLimit                           #Def: 10

Error.prepareStackTrace                         #When set with FUNC(ERROR, CALL_ARR)->'STACK', override how OBJ.stack is get
                                                #Default is something along the lines of:
                                                #  ERROR.name: ERROR.message
                                                #    at [new] CALL.getFunctionName() [as methodName] (LOCATION)
                                                #    at <anonymous> (LOCATION)
                                                #    at eval (PARENT_CALL, <LOCATION2>)
                                                #    at native
                                                #    at unknown location
                                                #    ...
                                                #LOCATION is:
                                                #  (CALL.getFileName():CALL.getLineNumber():CALL.getColumnNumber())
CALL.getFileName()->'FILENAME'                  #undefined if eval
CALL.getEvalOrigin()->'FILENAME'                #Same but when using eval() (or related)
CALL.getScriptNameOrSourceURL()->'FILENAME'     #Same but when using eval() (or related) with //# sourceURL comment
CALL.getFunction()->FUNC                        #undefined in 'strict mode'
CALL.getFunctionName()->'[CLASS.]FUNC|null'     #
CALL.getMethodName()->'FUNC'|null               #
CALL.getThis()->THIS                            #undefined in 'strict mode'
CALL.getTypeName()->STR|null                    #THIS's TYPE
CALL.getLine|ColumnNumber()->NUM                #
CALL.getPosition()->NUM                         #Byte index
                                             11*#Does not includes CommonJS wrapper anymore
CALL.isToplevel()->BOOL                         #
CALL.isEval()->BOOL                             #From eval() (or related)
CALL.isNative()->BOOL                           #From native C++ code
CALL.isConstructor()->BOOL                      #Using new
CALL.isAsync()->BOOL                         12*#True if async stack trace
                                                #Only for the CALL that triggered an async operation, e.g. `await`.
CALL.isPromiseAll()->BOOL                    12*#True if Promise.all()
CALL.getPromiseIndex()->NUM                  12*#PROMISE index inside Promise.all()


NERROR                                          #Node internal error, as opposed to standard JavaScript ERROR
                                                #Often filesystem errors, including permissions
NERROR.code                                     #NERROR_NAME
                                                #Most start with E* and are cross-OS. Some start with W* and are Windows-specific.
OS.constants.errno.NERROR_NAME                  #NERROR_NUM
                                                #OS-specific
NERROR.errno                                    #NERROR_NAME (same as NERROR.code) or -NERROR_NUM (as negative number)
UTIL.getSystemErrorName(-NERROR_NUM)
 ->NERROR_NAME                                  #
NERROR.syscall                                  #STR (e.g. 'access')
NERROR.path|dest                                #Src|dest 'PATH', if any
NERROR.address|port                             #HOST|PORT, if any
NERROR.info                                     #Extra info, if any


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            EVENTS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EventEmitter                                    #Base class of all objects receiving events
                                                #'EVENT' can be a SYM
                                                #Events are emitted synchronously
EVENTEMITTER.on('EVENT', FUNC)->EVENTEMITTER    #
EVENTEMITTER.once('EVENT', FUNC)->EVENTEMITTER  #
EVENTEMITTER.prepend[Once]Listener(...)         #Like on[ce](...) but adds to beginning of listeners list, not end
once(EVENTEMITTER, 'EVENT')->PROMISE_ARG_ARR 10*#Like EVENTEMITTER.once() but using PROMISE:
                                             10*#  - resolved with ARG_ARR on emit('EVENT', ...ARGS)
                                             10*#  - rejected with VAL on emit('error', VAL) (unless 'EVENT' is 'error' itself)
EVENTEMITTER.removeListener('EVENT', FUNC)
  ->EVENTEMITTER                                #
EVENTEMITTER.off(...)                        10*#Same
EVENTEMITTER.removeAllListeners(['EVENT'])
  ->EVENTEMITTER                                #
EVENTEMITTER.emit('EVENT'[, ...])->BOOL         #True if there were listeners
                                                #If 'EVENT' is 'error' and there are not listeners, throws instead

EVENTEMITTER.listeners(EVENT)->FUNC_ARR         #
EVENTEMITTER.rawListeners(EVENT)->FUNC_ARR    9*#Same but also with what Node.js adds, e.g. once() wrapper
EVENTEMITTER.listenerCount(EVENT)->NUM          #Slightly faster than EVENTEMITTER.listeners(STR).length
EVENTEMITTER.eventNames()->'EVENT'_ARR          #
EVENTEMITTER.setMaxListeners(NUM)->EVENTEMITTER #0 for unlim. Beyond max, does not stops adding listeners, only print warning.
EVENTEMITTER.getMaxListeners()->NUM             #
EVENTEMITTER.defaultMaxListeners                #10
EVENTEMITTER.on                                 #Event when a new event handler is added or removed.
 ("new|removeListener", FUNC(EVENT, FUNC2))     #Added|removed FUNC2 might still [not] be in EVENTEMITTER.listeners(EVENT)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GLOBAL             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GLOBAL VARIABLES ==>                            #  - global|GLOBAL|root: global scope reference
                                                #  - clear|setImmediate|Interval|Timeout, Object, URL, console, encodeURI, etc.: JavaScript globals
                                                #  - module, require, exports, __filename, __dirname: module-related globals
                                                #  - process, url: core modules
                                                #  - Buffer: core modules property
                                                #  - all core modules (e.g. http): in CLI only

--frozen-intrisics                              #Call Object.freeze():deeply on all global objects.

require('timers')                               #Module for clear|setImmediate|Interval|Timeout
                                                #Prefer globals as they work on browsers too


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            MODULE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


MODULE ==>                                      #Can be:
                                                #  - Node JavaScript file: executes it
                                                #  - JSON file: same as module.exports = JSON.parse('JSON')
                                                #  - machine code file:
                                                #     - must be *.node
                                                #     - loaded by dlopen()
                                                #     - exports available in void init(Handle<Object> exports)
                                                #     - must use libraries: V8, libuv, others
                                                #     - use node-gyp for packaging/compilation
                                                #     - on Windows, must first npm install -g windows-build-tools as admin
                                             12*#  - WebAssembly (*.wasm)
                                             12*#     - only with ESM
                                             12*#     - must use --experimental-wasm-modules
                                                #Decides type with file extension
                                                #Done runtime. See JavaScript modules doc for more info
module                                          #Current MODULE, i.e. file being loaded.
                                                #There are builtin modules, which are the chapters of this doc.

-r STR                                          #Load file STR:
--require STR                                   #  - 'ID': core module
require(STR)                                    #  - 'FILE' (absolute or relative)
                                                #  - 'DIR' (absolute or relative):
                                                #     - DIR/package.json, using main 'PATH' (relative to DIR)
                                                #     - DIR/index.EXT
                                                #  - 'MODULE':
                                                #     - i.e. anything that does not start with / or .
                                                #     - tries require('DIR2/MODULE'), with DIR2 [.../[..]]./node_modules/
                                                #Paths can omit extensions: .js, .mjs, .cjs, .json, .node
                                                #If not found, throw ERROR with code "MODULE_NOT_FOUND"
                                             12*#and ERROR.requireStack 'PATH'_ARR

require.resolve(STR[, OPTS])->'ID'              #How [MODULE.]require(STR) would resolve
                                                #OPTS:
                                                #  - paths 'DIR'_ARR: alternative directories to look into
                                                #    Their [.../[..]]./node_modules will always be searched
require.resolve.paths(STR)->'DIR'_ARR           #Directories that would be looked into when [MODULE.]require(STR) would resolve
createRequire('PATH'|URL)->require(STR)      12*#require(STR) will load 'PATH/STR' (PATH is relative to __dirname)
                                             12*#require() is CommonJS, i.e. can be used to use CommonJS in ESM with createRequire(import.meta.url)

require.cache[ID]                               #[MODULE.]require(STR) cache (i.e. modules are only loaded once).
                                                #ID is require.resolve(STR) result
                                                #Builtins are not cached.
                                                #Can delete it to remove cache, or restart current code.

MODULE.require                                  #Reference to require

--preserve-symlinks                             #When require()|import a symlink, use symlink path instead of symlinked file's path for:
                                                #  - caching
                                                #  - module resolution (when walking up the tree)
                                                #Does not apply to main file
--preserve-symlinks-main                     10*#Same but only for main file

SCOPE ==>                                       #Variables are local to each file, except for MODULE.exports
exports                                         #Return value (by reference if OBJ) when required. Must be assigned sync.
                                                #Can be any type.
MODULE.exports                                  #Reference to exports.
                                                #Must be used when want to overwrite, i.e. exports = VAL (as opposed to exports.VAR = VAL)
this                                            #Is, according to ENVVAR NODE_MODULE_CONTEXTS:
                                                #  - 0 (def): module.exports
                                                #  - 1: global

require.main                                    #Root file (first to have been loaded), as MODULE
process.mainModule                              #Same but updated if root file changed at runtime
MODULE.parent|children                          #MODULE[_ARR]|null
MODULE.loaded                                   #False for the first time the file is loaded (i.e. sync)
                                                #True for async functions

__filename                                      #Current file absolute path.
MODULE.filename                                 #Reference to __filename
MODULE.id                                       #For core modules, a string like "buffer". For others, module.filename.
__dirname                                       #Current file absolute dirname

require('module').builtinModules                #List of system 'MODULE'_ARR (e.g. 'http') including internal ones

CLI ==>                                         #require.main, process.mainModule: undefined
                                                #MODULE.loaded: false
                                                #__filename, __dirname: undefined (but MODULE.filename is '$PWD/repl')
                                                #MODULE.id: 'repl'
                                                #exports is undefined (but not MODULE.exports)

import|export ...                               #ES modules
                                                #Must use node --experimental-modules
                                                #  - --experimental-vm-modules for use in VM
                                                #Declaring file as ESM|CommonJS:
                                                #  - FILE.mjs|cjs
                                                #  - FILE.js use PACKAGE.type 'module|commonjs' (def: 'commonjs')
                                                #     - `package.json` can be in nested directories
                                                #  - stdin|--eval|--print use --input-type module|commonjs (def: 'commonjs')
                                                #Mixing:
                                                #  - ESM can import CommonJS
                                                #     - only default import or dynamic import() (no named|namespace import)
                                                #     - but can use dynamic require() with createRequireFromPath()
                                                #  - CommonJS cannot import ESM
                                                #     - including if ESM is a package (node_modules)
                                                #     - but can use dynamic import(), which allows importing ESM
                                                #Loading:
                                                #  - use same algorithm to find node_modules
                                                #  - can import FILE.json
                                                #  - cannot omit file extension or use index.js
                                                #     - unless --es-module-specifier-resolution=node (def: 'explicit')
                                                #  - cannot import FILE.node
                                                #  - PATH is actually URI:
                                                #     - need to be URI encoded
                                                #     - must use file:/// if absolute
                                                #     - can use #HASH or ?QUERY
                                                #        - included in cache key if imported file is ESM, otherwise not
                                                #        - i.e. can load twice a file by using different ?QUERY (if ESM)
                                                #     - can use fileURLToPath|pathToFileURL() to convert
                                                #No CommonJS, i.e. no require|module|exports|__filename|__dirname
                                                #Supports import(), import.meta.url
                                                #Can monkey-patch core modules by modifying their default import.
                                                #Top-level `this` is `undefined` (instead of `module.exports`)

DIFFERENCES ==>                                 #Difference from require(), import and import()
                                                #Steps:
                                                #  - resolution (all): resolve PATH to absolute PATH
                                                #  - read file (all)
                                                #  - global context:
                                                #     - require(): set global context to add exports, require, module, __filename, __dirname
                                                #        - before Node 11, was wrapping in anonymous function, with global variables as
                                                #          arguments, i.e. (function(GLOBALS...){...})(...)
                                                #     - import[()]: does not add those global variables
                                                #  - parsing:
                                                #     - require(), import(): normal
                                                #     - import: also find symbols from named imports (import { VAR }) and link them
                                                #  - running|evaluating (all)
                                                #  - cache return value (all)
                                                #Parse-time vs runtime:
                                                #  - require(), import(): everything done runtime
                                                #  - import:
                                                #     - everything done parse-time (except running), running then done runtime
                                                #     - i.e.:
                                                #        - cannot do e.g. export { VAL as [DYNAMIC_VAR] }
                                                #        - cannot catch errors in try/catch (e.g. optional dependency)
                                                #        - also better static analysis
                                                #        - VAR are implicitely const
                                                #Sync vs async:
                                                #  - require(): sync
                                                #  - import:
                                                #     - async parsing (just cannot be experienced)
                                                #     - sync runtime loading
                                                #  - import(): async with PROMISE
                                                #Top-level:
                                                #  - require(), import(): does not have to be top-level
                                                #  - import: must be top-level
                                                #Circular dependencies:
                                                #  - import(), dynamic require(): no issues
                                                #  - top-level require(): retrieve `module.exports` (not individual properties) by reference (not value)
                                                #     - if accessed during file load, empty object (parent not done loading)
                                                #        - including destructuring during `require()`
                                                #     - but works after file load:
                                                #        - unless parent does `module.exports = VAL` (as opposed to `module.exports.VAR = VAL`), as it removes the reference
                                                #  - import: retrieve individual properties by reference (not value)
                                                #     - if accessed synchronously, throws error (parent not done loading)
                                                #     - otherwise works

DEFAULT EXPORT ==>                              #CommonJS: it is the whole export (module.exports)
                                                #ESM: it is a property named 'default'

NODE-ONLY RESOLVER LOGIC ==>                    #Browsers cannot:
                                                #  - import JSON or Node native modules
                                                #  - omit file extension
                                                #  - import a directory (index.js)
                                                #  - require node_modules / packages
                                                #However some of this is usually done through a dependency bundler.

--loader FILE                                   #Customize the behavior of "import"
                                                #FILE must be ESM, and export:
                                                #  - resolve('PATH', 'URL', import())->{ url, format }:
                                                #     - customize resolution
                                                #     - 'PATH' is relative path
                                                #     - 'URL' is absolute base
                                                #        - is a URL, e.g. file: protocol with filesystem
                                                #        - can be undefined, e.g. REPL
                                                #     - url is resolved absolute URL
                                                #     - format can be 'module' (ESM), 'commonjs', 'json', 'addon', 'builtin' (core module), 'wasm' or 'dynamic'
                                                #  - dynamicInstantiate(URL)->PROMISE_{ exports, execute(EXPORTS) }:
                                                #     - customize loading, for custom formats beyong ESM/CommonJS/JSON
                                                #     - when returning format 'dynamic'
                                                #     - URL is the resolved absolute URL returned by OBJ.resolve()
                                                #     - exports is the 'VAR'_ARR of exported variables
                                                #     - execute() must call EXPORTS.VAR.get()|set(VAL) to set the value of the
                                                #       exported variables


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            POLICY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--experimental-policy=PATH                   11*#PATH to POLICY file

POLICY                                       11*#JSON file
                                             11*#Verify checksum of every loaded file.
                                             11*#Every loaded file must be present and match POLICYFILE.integrity
                                             11*#Running process should not be able to modify it, i.e.:
                                             11*#  - no write permission
                                             11*#  - does not own file (i.e. cannot do chmod)
POLICY.resources.PATH|URL                    11*#POLICYFILE
POLICYFILE.integrity                         11*#STR: 'sha256|384|512' followed by 'HASH'
--policy-integrity=STR                       12*#Same as CLI, i.e. works even if POLICY file was tampered with.
POLICY.onerror                               11*#What do on integrity failures:
                                             11*#  - 'throw' (def): throw ERROR
                                             11*#  - 'exit': print ERROR + process.exit(1)
                                             11*#  - 'log': print ERROR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        STRING_DECODER         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new StringDecoder(['ENCODING'])                 #Returns DECODER. Def: "utf8"
                                                #Does TDBUFFER -> STR translation
DECODER.write|end(TDBUFFER)->STR                #Adds to current string. If:
                                                #  - it still contains incomplete chars, returns ''
                                                #  - otherwise, resets and returns current string
DECODER.end()->STR                              #Returns current string, but does not reset.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BUFFER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Buffer                                          #Child of Uint8Array (including constructors), with extra methods:
                                                #  - mixes in DATAVIEW flexibility (of changing current type)
                                                #  - better serialization: toString(), toJSON()
                                                #  - can decode STR according to different encodings
                                                #  - can swap bytes, compare bytes
                                                #  - some performance improvements, and some convenience functions

[S][T][D][U][A]BUFFER                           #Means BUFFER|[STR]|[TYPED_ARR]|[DATAVIEW]|[UINT8ARR]|[ARRBUFFER]
BVAL                                            #UINT (like Uint8Array), STR, BUFFER or UINT8ARR

constants.MAX_LENGTH                            #Max BUFFER.length
constants.MAX_STRING_LENGTH                     #Max STR.length

Buffer.isEncoding('ENCODING')->BOOL             #
transcode(UBUFFER, "ENCODING", "ENCODING2")
 ->BUFFER2                                      #Returns BUFFER2 with ENCODING2, based on UBUFFER with ENCODING

new TYPED_ARR(BUFFER)                           #Copy, not reference
                                                #Each single BUFFER BVAL -> a single TYPED_ARR VAL
Buffer.allocUnsafe[Slow](NUM)->BUFFER           #Similar to new TYPED_ARR(NUM)
                                                #Max size is require("buffer").kMaxLength (64 bits on 64 bits architecture)
                                                #Unless "Slow", will reuse preallocated buffer from a pool (i.e. faster)
                                                #if NUM <= Buffer.poolSize (def: 8192) / 2
Buffer.alloc(NUM[, NUM2|SBUFFER[, 'ENCODING']]) #Like Buffer.allocUnsafeSlow(NUM).fill(NUM2|SBUFFER, 'ENCODING') (def: \0),
 ->BUFFER                                       #for security reasons
                                                #If node --zero-fill-buffers, will fill with \0 even Buffer.allocUnsafe[Slow]()
Buffer.from(NUM_ARR)->BUFFER                    #Similar to new TYPED_ARR(NUM_ARR)
Buffer.from(ARRBUFFER, ...)->BUFFER             #Similar to new TYPED_ARR(ARRBUFFER, ...)
Buffer.from(STR[, 'ENCODING'])->BUFFER          #
Buffer.from(BUFFER)->BUFFER                     #Copies
Buffer.concat(UBUFFER_ARR[, UINT])->BUFFER      #Similar to Array.prototype.concat.call(null, ...) but with UBUFFER_ARR
                                                #Providing final length UINT can speed up performance.
BUFFER.buffer                                   #Inherited from UINT8ARR. Reference to underlying ARRBUFFER

Buffer.byteLength(STDABUFFER[, 'ENCODING'])->NUM#Similar to TYPED_ARR.byteLength

Buffer.isBuffer(VAL)->BOOL                      #
BUFFER.equals(UBUFFER2)->BOOL                   #
BUFFER.compare(UBUFFER2[, 4 NUM])->-1|0|1       #Sort comparison. NUMs are UBUFFER2 start|end and UBUFFER start|end
Buffer.compare(UBUFFER, UBUFFER2)->-1|0|1       #Same as BUFFER.compare(UBUFFER2)

BUFFER.toString(['ENCODING'[, ...])->STR        #Like:
                                                #  let decoder = new StringDecoder('ENCODING');
                                                #  decoder.write(BUFFER.slice(...));
                                                #  return decoder.end()
BUFFER.toJSON()                                 #Returns as '{"type": "Buffer", "data": [...]}'

BUFFER.slice(...)->BUFFER                       #Like [TYPED_]ARR, but returns a reference
BUFFER.[last]indexOf(..., 'ENCODING')->NUM      #Like [TYPED_]ARR but:
BUFFER.includes(..., 'ENCODING')->BOOL          #  - VAL is BVAL
BUFFER.fill(...[, 'ENCODING'])                  #  - can use 'ENCODING'

BUFFER.write(STR[, UINT[, UINT2[, 'ENCODING']]])#Writes STR on BUFFER
 ->NUM                                          #UINT is offset (def: 0) and UINT2 is length (def: all)
BUFFER.copy(UBUFFER2[, 3 UINT])->UINT4          #Copies bytes from BUFFER at position UINT to UBUFFER2 from position UINT2 to
                                                #UINT3 (def: UBUFFER2.length)

BUFFER.readFloat|Double|[U]Int8|16|32]LE|BE
(UINT[, BOOL])->VAL                             #Similar to DATAVIEW.get|set* but:
BUFFER.writeFloat|Double|[U]Int8|16|32LE|BE     #  - use LE|BE instead of BOOL argument
(VAL, UINT[, BOOL])                             #  - if BOOL true, faster but no validation of UINT buffer overflow
BUFFER.read[U]Int[LE|BE](UINT, UINT2[, BOOL])
BUFFER.write[U]Int[LE|BE](VAL,UINT,UINT2[,BOOL])#Same but specifies [U]Int size UINT2 (up to 48)
BUFFER.readBig[U]Int64LE|BE(UINT)->BIGINT    12*#
BUFFER.readBig[U]Int64LE|BE(BIGINT, UINT)    12*#

BUFFER.swap16|32|64()->BUFFER                   #Swaps every couple of 1|2|4 bytes. Return value is reference


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STREAM             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SVAL                                            #UBUFFER or (if setEncoding() called) STR, or null if nothing to read
OBJECT MODE ==>                                 #SVAL is any VAL (except null):
                                                #  - encoding is ignored
                                                #  - both ISTREAM and OSTREAM must be in objectMode
                                                #  - ISTREAM.read() NUM argument is ignored (always 1)
                                                #  - highWatermMark is per-SVAL and defaults to 16

ISTREAM ==>                                     #Input stream. Actually called Readable
                                                #Is an ASYNC_ITERABLE
                                             11*#  - does not print experimental warning anymore
new STREAM.Readable([OBJ])                      #OBJ:
                                                #  - encoding 'ENCODING' (def: null, i.e. uses BUFFER)
                                                #  - objectMode BOOL: see above
                                                #  - highWaterMark NUM:
                                                #     - buffer size (def: 16kb)
                                                #     - on ISTREAM: data available for read but not read yet
                                                #     - on OSTREAM: data not flushed yet
                                                #     - if buffer full, waits
ISTREAM.on("readable", FUNC())                  #New chunks available, or just before "end"
ISTREAM.on("data", FUNC(SVAL))                  #Each new chunk available. Firing FUNC() consumes that chunk.
                                                #Not fired if ISTREAM is empty
ISTREAM.read([UINT])->SVAL                      #Like on("data") but:
                                                #  - sync: waits until chunk available (i.e. prefer on("data"))
                                                #  - specify (max) chunk size UINT (def: all)
                                                #  - SVAL is null if ISTREAM empty
ISTREAM.on("end", FUNC())                       #When all chunks have been read
ISTREAM.on("close", FUNC())                     #When underlying fd is closed (not all ISTREAM close)
ISTREAM.on("error", FUNC(ERROR))                #
ISTREAM.pause|resume()                          #Makes it stop|resume emit "data" events.
ISTREAM.isPaused()                              #
ISTREAM.readable                                #BOOL
ISTREAM.readableEncoding                     12*#'ENCODING'
ISTREAM.setEncoding('ENCODING')                 #
ISTREAM.readableObjectMode                   12*#BOOL
ISTREAM.readableHighWaterMark                   #NUM
ISTREAM.readableLength                        9*#NUM. Number of bytes not read yet
ISTREAM.readableFlowing                         #Can be:
                                                #  - null: when all data has been consumed, or stream has not started been read yet
                                                #  - true: when stream is being read, i.e. after on('data')
                                                #  - false: when stream is being paused, i.e. after pause()
ISTREAM.pipe(OSTREAM[, { end: BOOL }])->OSTREAM #Same as ISTREAM.on("data", sval => OSTREAM.write(SVAL))
                                                #If BOOL true (def), call OSTREAM.end() on ISTREAM.on('end|error') (except on stdout|stderr)
ISTREAM.unpipe([OSTREAM])                       #Stops pipe() (def: all)
ISTREAM.unshift(SVAL[, 'ENCODING'])             #Put last SVAL read back in ISTREAM
                                             12*#Can specify 'ENCODING'
ISTREAM.destroy([ERROR])                        #

Readable.from(SVAL_ITERABLE[, OBJ])->ISTREAM 12*#OBJ:
                                                #  - same as new Readable(OBJ)
                                                #  - def objectMode is true

OSTREAM ==>                                     #Output stream. Actually called Writable
STREAM.Writable([OBJ])                          #Constructor for OSTREAM. OBJ members are:
                                                #  - decodeStrings BOOL: if true (def), decodes to BUFFER before
                                                #    calling underlying OSTREAM._write()
                                                #  - objectMode BOOL: see above
                                                #  - highWaterMark NUM: see above
OSTREAM.write(SVAL[, 'ENCODING'[,FUNC()]])->BOOL#Writes chunks.
                                                #FUNC() is fired when buffered + flushed.
                                                #BOOL:
                                                #  - false if data cannot be buffered anymore (i.e. buffer is full)
                                                #  - i.e. should wait for OSTREAM.once('drain') before writing again
OSTREAM.end(SVAL[, 'ENCODING'[, FUNC()]])
 ->OSTREAM                                      #Same but for final chunk. FUNC is the finish event handler
OSTREAM.destroy([ERROR])                        #
OSTREAM.setDefaultEncoding('ENCODING')->OSTREAM #Def: 'utf-8'. Used by write() and end()
OSTREAM.writable                                #BOOL
OSTREAM.writableObjectMode                   12*#BOOL
OSTREAM.writableHighWaterMark                   #NUM
OSTREAM.writableLength                        9*#NUM. Number of bytes not flushed yet
OSTREAM.[un]cork()                              #cork() forces buffering to disk, uncork() flushes
                                                #To do when writing a lot of small I/O, to make them all flush at once.
OSTREAM.on("close", FUNC())                     #Like ISTREAM
OSTREAM.on("finish", FUNC())                    #Fired when end() done
OSTREAM.writableFinished                     12*#BOOL. Whether 'finish' event was fired.
OSTREAM.on("[un]pipe", FUNC(ISTREAM))           #Fired by ISTREAM.[un]pipe()
OSTREAM.on("error", FUNC(ERROR))                #

finished(STREAM[, OPTS], FUNC([ERROR]))      10*#Call FUNC([ERROR]) when STREAM (which can also be EVENTEMITTER|REQ|RES) completes:
 ->FUNC2()                                   10*#  (success)
                                             10*#  - all: 'end', 'finish', 'close', destroy()
                                             10*#  - REQ|RES: 'complete', underlying stream 'finish'
                                             10*#  (ERROR)
                                             10*#  - all: 'error', premature 'close', destroy(ERROR)
                                             10*#  - REQ|RES: 'abort'
                                             10*#`this` inside FUNC is STREAM
                                             10*#FUNC2() undoes it.
                                             10*#OPTS:
                                             10*#  - readable|writable BOOL (def: guessed)
                                             10*#  - error BOOL (def: true): use 'error' event
END-OF-STREAM(...)                             ##Ponyfill for finished() (1.4.1)
ON-FINISHED(...)                               ##Similar but slightly different, i.e. not preferred (2.3.0)

pipeline(ISTREAM|OSTREAM[_ARR]...,           10*#Like finished(STREAM.pipe(STREAM2).pipe(...), ...)
 FUNC(ERROR))->PROMISE                       10*#Also if one STREAM errors then other STREAM are closed (with STREAM.close|abort|destroy())
PUMP(...)                                      ##Ponyfill for pipeline() (3.0.0)

IOSTREAM ==>                                    #Implement both ISTREAM and OSTREAM. Actually called either:
                                                #  - STREAM.Duplex
                                                #  - STREAM.Transform:
                                                #     - same but where there is a correlation between input and output (ex: crypto, but not HTTP)
                                                #     - only semantic

INHERITING STREAMS ==>                          #To create STREAM child classes, just inherit them and reimplement functions
                                                #_read(), _write[v](), _transform() or _flush() (see online doc), without calling them directly.

process.stdin|stdout|stderr                     #Standard streams
                                                #Unless other STREAMs which are async, writes are sync|async depending on to what it is piped to:
                                                #  - a file -> sync
                                                #  - a terminal -> sync (Unix), async (Windows)
                                                #  - another process (pipe) or a socket -> async (Unix), sync (Windows)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              TTY              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


STREAM.isTTY
isatty(FD_INT)->BOOL                            #true|undefined if is READSTREAM|WRITESTREAM

ReadStream                                      #ISTREAM of a text terminal. Often for process.stdin
                                                #Child of TCPSOCKET, but without destroy(), connect event nor *address*
                                                #Will keep process alive until destroyed.
READSTREAM.isRaw                                #If false (def):
                                                #  - echoes input to output
                                                #  - buffer input until next newline (i.e. line-wise input instead of character-wise)
                                                #  - buffered input can be removed with Backspace|Delete)
                                                #  - can quit with CTRL-D, CTRL-C, CTRL-Z
                                                #  - emit sounds (bell)
                                                #  - normalize any non-ASCII to ASCII (by removing MSB)
                                                #  - '\r\n' -> '\n'
                                                #In either case:
                                                #  - use replace mode (not insert mode)
                                                #  - no Emacs keybindings (CTRL-A, etc.)
                                                #  - can move cursor (Left|Right|Home|End)
READSTREAM.setRawMode(BOOL)                     #
READSTREAM.bytesRead                            #So far (including newlines)

WriteStream                                     #Same as READSTREAM but for OSTREAM of a text terminal. Often for process.stdout|stderr
WRITESTREAM.columns|rows                        #UINT. Automatically updated.
WRITESTREAM.on("resize", FUNC())                #

WRITESTREAM.getColorDepth([process.env])->NUM 9*#Number of bits per channel: 1|4|8|24
                                              9*#Used by console.*() and REPL
                                              9*#Based on heuristic on process.env and os.release():
                                              9*#  - Linux:
                                              9*#     - ENVVAR TERM 'dumb': 1 bit
                                              9*#     - ENVVAR TMUX, ENVVAR TERM 'eterm|cons25|console|cygwin|dtterm|gnome|
                                              9*#       hurd|jfbterm|konsole|kterm|mlterm|putty|st' or contains
                                              9*#       'ansi|color|linux|con|rxvt|screen|term|vt100', ENVVAR COLORTERM: 4 bits
                                              9*#     - ENVVAR TERM 'xterm-256*': 8 bits
                                              9*#     - ENVVAR TERM 'terminator|rxvt-unicode-24bit',
                                              9*#       ENVVAR COLORTERM 'truecolor|24bit': 24 bits
                                              9*#  - Mac (base on ENVVAR 'TERM_PROGRAM'):
                                              9*#     - 'Apple_Terminal', old 'iTerm.app': 4 bits
                                              9*#     - 'HyperTerm', 'MacTerm', new 'iTerm.app': 24 bits
                                              9*#  - Windows:
                                              9*#     - <10: 4 bits
                                              9*#     - 10 before build 14931: 8 bits
                                              9*#     - after: 24 bits
                                              9*#  - CI:
                                              9*#     - Travis/CircleCI/AppVeyor/GitLab/Codeship: 8 bits
                                              9*#     - others: 1 bit
                                              9*#  - Teamcity:
                                              9*#     - old versions: 1 bit
                                              9*#     - new versions: 4 bits
                                              9*#  - otherwise: 1 bit
ENVVAR FORCE_COLOR=0|1|2|3                   11*#Force getColorDepth() to assume color support for 1|4|8|24 bits per channel
ENVVAR NO_COLOR=1                            11*#Same as FORCE_COLOR=0
ENVVAR NODE_DISABLE_COLORS=1                 11*#Same as FORCE_COLOR=0 but also change REPL (prefer NO_COLOR)
WRITESTREAM.hasColors([NUM][, process.env])  10*#Returns true if 2 ** getColorDepth([process.env]) >= NUM
 ->BOOL                                      10*#I.e. NUM should be 2 (2**1), 16 (2**4) (def), 256 (2**8) or 16 million (2**24)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           READLINE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


INTERFACE                                       #Interactive TTY

createInterface(OPTS)->INTERFACE                #OPTS:
                                                #  - input ISTREAM
                                                #  - output OSTREAM
                                                #  - terminal BOOL (def: OSTREAM.isTTY):
                                                #     - do not use raw mode
                                                #     - handle sequences:
                                                #        - removing chars (Backspace|Delete|CTRL-H|D|U|K|W)
                                                #        - exiting (CTRL-C|D|Z)
                                                #        - moving cursor (Left|Right|Home|End|CTRL-A|E|B|F)
                                                #        - clear screen (CTRL-L)
                                                #     - use tab completion
                                                #     - use history
                                                #        - including history navigation (Up|Down|CTRL-N|P)
                                                #     - use emitKeypressEvents()
                                                #  - completer(STR[, FUNC(ERROR, ARR)])[->ARR]:
                                                #     - used to tab completion
                                                #     - ARR: [STR2_ARR, STR]
                                                #        - STR is original string
                                                #        - STR2_ARR are possible matches.
                                                #           - if have common prefix, autocompletes
                                                #  - historySize NUM (def: 30) (0 for none): in-memory, not persisted
                                                #  - removeHistoryDuplicates BOOL (def: false): new history lines that are duplicate
                                                #    of a previous one removes that older one
                                                #  - prompt STR (def: '> ')
                                                #  - crlfDelay NUM (def: 100, cannot be lower): if input reads \r and \n
                                                #    successively but more than NUMms apart, treat them as two newlines, not one
                                             10*#  - escapeCodeTimeout NUM (def: 500) (in ms): how long to wait when starting an ESC sequence
INTERFACE.close()                               #Called by ISTREAM.end() and CTRL-C|D|Z
INTERFACE.on("close", FUNC())                   #

INTERFACE.on("line", FUNC(STR))                 #Fired each time a line is read from ISTREAM.
INTERFACE[Symbol.asyncIterator]              10*#Defined

INTERFACE.write(STR[, OBJ])                     #Prints STR on OSTREAM
                                                #Use CTRL|META|SHIFT-STR if OBJ: ctrl|meta|shift: true, name: STR
                                                #Be careful as it will be read by ISTREAM, if ISTREAM and OSTREAM point to same thing (e.g. terminal).
                                                #  - like process.stdout.write(), but as opposed to console.*()

INTERFACE.setPrompt(STR)                        #Change OPTS.prompt (see above)
INTERFACE.prompt([BOOL])                        #Write in beginning of current OSTREAM line the OPTS.prompt
                                                #If false (def), move cursor back to beginning of line

INTERFACE.question(STR, FUNC(STR2))             #Replace current prompt by STR on OSTREAM, and fires FUNC(STR2) on line event instead of normal line event.

INTERFACE.pause|resume()                        #Like ISTREAM.pause|resume()
                                                #ISTREAM still accept input but buffers it, and reads it once resumed.
                                                #pause() is called by SIGCONT or SIGTSTP (CTRL-Z)
                                                #resume() is called by write(), prompt() and question()
INTERFACE.on("pause|resume", FUNC())            #
INTERFACE.on("SIGINT|SIGTSTP|SIGCONT", FUNC())  #

clearLine(OSTREAM, NUM[, FUNC()])->BOOL         #Can be 0 (entire line, \e2K) or -1|1 (to the left|right of cursor, \e0K, \e1K)
                                                #FUNC|BOOL are from the underlying OSTREAM.write()
cursorTo|moveCursor(OSTREAM, NUM, NUM2[,FUNC()])
 ->BOOL                                         #Move cursor absolutely|relatively (\eNUMA, \eNUMB, \eNUM2C, \eNUM2D)
clearScreenDown(OSTREAM[, FUNC()])->BOOL        #Clear all following lines (\e0J). To clear screen, combine with cursorTo(OSTREAM, 0, 0)

emitKeypressEvents(OSTREAM[, INTERFACE])        #Enable OSTREAM.on('keypress')
                                                #If OSTREAM is connected to an INTERFACE, can specify it to disable completion on copy-pasted input
OSTREAM.on('keypress', FUNC(STR, OBJ))          #STR is what to print (e.g. 'a', undefined or '') (for a, LeftArrow and CTRL-C)
                                                #OBJ:
                                                #  - sequence STR (e.g. 'a', '\u001b[D' or '\u0003')
                                                #  - name STR (e.g. 'a', 'left' or 'c')
                                                #  - shift|ctrl|meta BOOL
                                                #Can use ESC sequences


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             REPL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REPLSERVER                                      #Child of INTERFACE, meant for read-eval-print loop.

start([OPTS])->REPLSERVER                       #Forwards to INTERFACE:
                                                #  - forwards OPTS.input|output|prompt|historySize|terminal|completer
                                                #  - def OPTS.input|output is process.stdin|stdout
                                                #  - def OPTS.completer is JavaScript autocompletion
                                                #OPTS:
                                                #  - eval(STR, CONTEXT, FILENAME, FUNC(ERROR, VAL)):
                                                #     - input handler:
                                                #        - STR is input (including final newline)
                                                #        - VAL is passed to OPTS.writer()
                                                #        - FILENAME is 'repl' if default REPL
                                                #        - if ERROR is new Recoverable(''), keep prompt ongoing (e.g. for multiline input)
                                                #           - current input is added to next input
                                                #     - def:
                                                #        - VM.createScript(STR, {filename: FILENAME, displayErrors: true})
                                                #        - then SCRIPT.runInContext(REPLSERVER.context, {breakOnSigint: OPTS.breakEvalOnSigint, displayErrors: true})
                                                #  - writer(VAL)->STR:
                                                #     - serialization
                                                #     - def: util.inspect() using util.inspect.defaultOptions except:
                                                #        - showProxy true
                                                #        - colors OPTS.useColors (def: process.stdout.hasColors())
                                                #  - ignoreUndefined BOOL (def: false): if true, doesn't print output when it is undefined
                                                #  - useGlobal BOOL (def: false): see below
                                                #  - replMode either:
                                                #     - REPL_MODE_STRICT: "use strict"
                                                #     - REPL_MODE_SLOPPY (def): inverse
                                                #  - breakEvalOnSigint BOOL: if true (def: false), stops on CTRL-C
REPLSERVER.on("exit", FUNC())                   #
REPLSERVER.on("reset", FUNC())                  #When ".clear" or resetContext() is called.

REPLSERVER.context                              #Global CONTEXT object
                                                #If OPTS.useGlobal false (def):
                                                #  - is a new CONTEXT (using VM.createContext())
                                                #  - contains all core modules, e.g. GLOBAL.child_process
                                                #Also contains the following:
_                                               #Last expression evaluated
_error                                        9*#Last uncaught exception

REPL COMMANDS ==>                               #
.exit
CTRL-D                                          #
.break
CTRL-C                                          #
.editor                                         #Start multiline session
REPLSERVER.resetContext()
.clear                                          #Reinitialize REPLSERVER.context
.help                                           #
REPLSERVER.defineCommand                        #Custom .COMMAND [...ARGS]
 ('COMMAND', OBJ|FUNC(...ARGS))                 #OBJ:
                                                #  - action(...ARGS)
                                                #  - help STR
REPLSERVER.displayPrompt([BOOL])                #Like INTERFACE.prompt(BOOL) except if there is currently some input, use '...' prompt instead
                                                #Meant to be used inside defineCommand() OBJ.action()
REPLSERVER.clearBufferedCommand()             9*#Discard|ignore the line currently entered
                                              9*#Meant to be used inside defineCommand() OBJ.action()

REPLSERVER.setupHistory
 ('PATH', FUNC(ERROR, REPLSERVER))           11*#Must be called to use history.
.save FILE                                      #Save all input so far to FILE
.load FILE                                      #Input FILE

--experimental-repl-await                    10*#Allow using await top-level

DEFAULT REPL ==>                                #Uses REPL except:
                                                #  - calls REPLSERVER.setupHistory('PATH')
                                                #     - using ENVVAR NODE_REPL_HISTORY (def: ~/.node_repl_history)
                                                #  - OPTS.terminal can be set with ENVVAR NODE_NO_READLINE=1
                                                #  - OPTS.replMode can be set with ENVVAR NODE_REPL_MODE 'sloppy|strict'
                                                #  - OPTS.historySize can be set with ENVVAR NODE_REPL_HISTORY_SIZE (def: 1000)
                                                #  - OPTS.breakEvalOnSigint true
                                                #  - can override defaults util.inspect() options (for OPTS.writer()) with util.inspect.replDefaults


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             DGRAM             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


createSocket(STR|OPTS[, FUNC(BUFFER, OPTS)])    #OPTS:
 ->UDPSOCKET                                    #  - type "udp4|6"
                                                #  - reuseAddr BOOL (def: false): make UDPSOCKET.bind() reuse an address already bound
                                                #  - lookup FUNC (def: DNS.lookup)
                                                #  - recvBufferSize|sendBufferSize NUM: in|out buffer size
                                             11*#  - ipv6Only BOOL (def: false)
                                                #STR is OPTS.type
                                                #FUNC is 'message' event handler.
UDPSOCKET.address()                             #{ address, port, family }

UDPSOCKET.bind(OBJ[, FUNC()])                   #Start listening. OBJ:
UDPSOCKET.bind(PORT_NUM[, 'ADDR'][, FUNC()])    #  - port PORT_NUM
                                                #  - address 'ADDR' (def: all available)
                                                #FUNC() is 'listening' event handler
                                                #Program will block until UDPSOCKET.close() is called. Can also use UDPSOCKET.[un]ref()
UDPSOCKET.on("listening", FUNC())               #After bind()
UDPSOCKET.on("message", FUNC(BUFFER, OBJ))      #OBJ is like UDPSOCKET.address()
UDPSOCKET.close([FUNC()])                       #FUNC is close event handler
UDPSOCKET.on("close", FUNC())                   #
UDPSOCKET.on("error", FUNC(ERROR))              #

UDPSOCKET.connect(PORT_NUM[, 'ADDR'][, FUNC()]) #Connects to other port.
                                                #Def 'ADDR': '127.0.0.1' (udp4) or '::1' (udp6)
UDPSOCKET.disconnect()                          #
UDPSOCKET.on("connect", FUNC())                 #After connect()
UDPSOCKET.remoteAddress()->OBJ                  #OBJ: address, family, port (like TCPSERVER.address())

UDPSOCKET.send                                  #Sends to PORT_NUM, address 'ADDR'.
(SUBUFFER[_ARR][, UINT, UINT2],                 #Payload is first arg, from byte UINT, length UINT2
PORT_NUM, 'ADDR'[, FUNC(ERROR, UINT3)])         #If bind() has not been called, UDPSOCKET gets assigned a random port, and an adress "0.0.0.0"
                                                #When done, fires FUNC: UINT3 is the number of bytes sent.
                                                #Max. SUBUFFER size is the MTU, which must be found with PMTUD.
                                                #'ADDR' is optional

UDPSOCKET.setRecv|SendBufferSize(NUM)           #
UDPSOCKET.getRecv|SendBufferSize()->NUM         #

UDPSOCKET.setBroadcast(BOOL)                    #
UDPSOCKET.setMulticastLoopback(BOOL)            #
UDPSOCKET.setMulticastInterface(STR)            #
UDPSOCKET.add|dropMembership(STR[, STR2])       #Routing options
UDPSOCKET.set[Multicast]TTL(UINT)               #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              NET              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


createServer([OBJ, ][FUNC()])->TCPSERVER        #FUNC is 'connection' event handler
                                                #OBJ:
                                                #  - allowHalfOpen BOOL: see below
                                                #  - pauseOnConnect BOOL (def: false): if true, calls TCPSOCKET.pause()
                                                #on 'connection'

TCPSERVER.listen                                #Makes the TCSERVER:
(PORT_NUM|'PORT'[, 'ADDR'][, UINT][, FUNC()])   #  - listen to PORT_NUM|'PORT':
                                                #     - if 0, random port
                                                #     - can fire 'error' event with ERROR.code "EADDRINUSE" if another process
                                                #       already uses this port.
                                                #  - listen to 'ADDR':
                                                #     - def: INADDR_ANY, i.e. any available IP on the machine will work
                                                #  - UINT:
                                                #     - max number of pending connections, i.e. TCP sent SYN packet, but not
                                                #       ACK yet.
                                                #     - refuse connection if above max.
                                                #     - def: 511 (which is pretty ok)
                                                #     - OS limits are determined by sysctl settings like tcp_max_backlog
                                                #       and somaxconn (which is 511 in my system)
                                                #  - FUNC is 'listening' event hander
                                                #Can only be called once.
TCPSERVER.listen('PATH'[, UINT][, FUNC()])      #Same but by explictely creating a socket at 'PATH' (should be in /tmp)
TCPSERVER.listen(OBJ[, UINT][, FUNC()])         #Same but for either:
                                                #  - { fd: UINT }: with file descriptor, not on Windows
                                                #  - TCPSERVER|TCPSOCKET
TCPSERVER.listen(OBJ[, FUNC()])                 #Same with OBJ:
                                                #  - port, host, path, backlog UINT
                                                #  - readableAll|writableAll BOOL (def: false): file permission for the socket
                                             11*#  - ipv6Only BOOL (def: false)
TCPSERVER.on("listening", FUNC())               #Fired when listen() is called.
TCPSERVER.listening                             #BOOL
TCPSERVER.close([FUNC()])                       #Stops the server from accepting new connections:
                                                #  - keeps existing ones
                                                #  - when existing ones have stopped, emits "close" event
                                                #FUNC is 'close' event listener
TCPSERVER.on("close", FUNC())                   #Fired on TCPSERVER.close()
TCPSERVER.address()->OBJ                        #Returns { port: UINT, address STR, family: "IPv4|6" }
                                                #After listen() has been called
TCPSERVER.[un]ref()->TCPSERVER                  #Yield the macrotask (see JavaScript doc)
                                                #listen() call ref(), and stop() or stop event handlers call unref()

TCPSERVER.on("connection", FUNC(TCPSOCKET))     #Fired when a TCP connection is initiated.
TCPSERVER.on("error", FUNC(ERROR))              #Fired when connection problem. Will fire TCPSERVER.close()
TCPSERVER.maxConnections                        #Def: null
                                                #0|null means no limits.
                                                #Above that, will refuse connections.
TCPSERVER.getConnections([FUNC(ERROR, UINT)])   #Number of connections


connect|createConnection(OPTS[, FUNC()])        #Same as new Socket(OPTS) followed by TCPSOCKET.connect(OPTS, FUNC)
  ->TCPSOCKET                                   #OPTS can also have:
                                                #  - timeout NUM: calls TCPSOCKET.setTimeout(NUM)
TCPSOCKET                                       #IOSTREAM but:
                                                #  - no readable event, read() or unshift() (but still data event)
                                                #  - nothing about piping
                                                #  - close event handler: FUNC(BOOL): true if close because of error
                                                #  - error event handler: FUNC(ERROR)
new Socket([OBJ])                               #OBJ:
                                                #  - fd: UINT
                                                #  - readable|writable BOOL (def: false): only when fd was used
                                                #  - allowHalfOpen BOOL (def: false):
                                                #     - if true, when other socket closes connection, doesn't automatically
                                                #       call end()
                                                #     - which means:
                                                #        - can still write to it (but non-readable)
                                                #        - must manually call end()
TCPSOCKET.connect(ARGS[, FUNC()])               #ARGS:
                                                #  - OBJ:
                                                #     - port PORT_NUM|'PORT'
                                                #     - host 'ADDR'
                                                #     - localAddress|localPort
                                                #     - path 'PATH' (only for UNIX sockets, only option then)
                                                #     (see DNS.lookup())
                                                #     - family 4|6|null
                                                #     - hints
                                                #     - lookup (def: DNS.lookup())
                                                #  - HOST[, PORT]
                                                #  - "PATH"
                                                #FUNC() is 'connect' event handler.
TCPSOCKET.pending                               #BOOL: true before connect() or before 'connect' event
TCPSOCKET.connecting                            #BOOL: true after connect() but before 'connect' event
TCPSOCKET.on                                    #Fired after hostname resoution, but before TCP connection.
("lookup", FUNC(ERROR, 'IP', VAL, 'HOST'))      #VAL is family 4|6|null
TCPSOCKET.on("connect", FUNC())                 #
TCPSOCKET.on("ready", FUNC())                   #
TCPSOCKET.destroy([ERROR])                      #No more read|write. Only necessary when error happened.
                                                #If ERROR, 'error' event is fired
TCPSOCKET.destroyed                             #BOOL
TCPSOCKET.[un]ref()->TCPSOCKET                  #Like TCPSERVER

TCPSOCKET.setTimeout(UINT[, FUNC()])->TCPSOCKET #Emits timeout event after UINTms of idleness.
                                                #Not emitted after TCPSOCKET is destroyed.
                                                #0 (def) disables.
                                                #By def, timeout handler does not do anything, but can end|destroy()
                                                #FUNC is 'timeout' event handler
                                                #Uses setTimeout(), i.e. done at macrotask level, i.e. might take longer than
                                                #UINTms if long macrotasks.
TCPSOCKET.on('timeout', FUNC())                 #

TCPSOCKET.setKeepAlive(BOOL, UINT)->TCPSOCKET   #Def: false and 0.
                                                #TCP keepalive
TCPSOCKET.setNoDelay(BOOL)->TCPSOCKET           #If false (def), use buffers:
                                                #  - to reduce amount of requests i.e. send data in chunks
                                                #  - more efficient when using a lot of small requests, but can delay them
                                                #  - even disabled, underlying IOSTREAM still use buffer to keep up with
                                                #    high demand
TCPSOCKET.bufferSize                            #Currently buffered size.
                                                #If ever growing, should use pause|resume()
TCPSOCKET.bytesRead|Written                     #So far

TCPSOCKET.address()->OBJ                        #Like TCPSERVER
TCPSOCKET.local|remotePort|Address              #
TCPSOCKET.remoteFamily                          #'IPv4|6'
isIp('ADDR')->0|4|6                             #
isIpv4|6('ADDR')->BOOL                          #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              TLS              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


getCiphers()->STR_ARR                           #All suite of SSL ciphers are [PREFIX-]ALGO[-HASH]
                                                #ALGO: AES128|256, 3DES, DES, Camellia128|256, IDEA, RC4, SEED
                                                #PREFIX:
                                                #  - ECDH[E]-ECDSA|RSA: for AES, DES, RC4
                                                #  - DH[E]-DSS|RSA: for AES, Camellia, SEED
                                                #  - EDH-DSS|RSA: for DES
                                                #  - PSK: for AES, 3DES, RC4
                                                #  - SRP-[DSS|RSA]: for AES, 3DES
                                                #HASH ([-]#ALGO means ALGO with[out] PREFIX SPK|SRP):
                                                #  - sha: -#AES*, Camellia*, RC4, SEED
                                                #  - gcm-sha256: -#AES128
                                                #  - gcm-sha384: -#AES256
                                                #  - sha256: -#AES*
                                                #  - cbc3-sha: -#DES
                                                #  - cbc-sha: IDEA, #AES
                                                #  - md5: RC4 (unless any PREFIX)
                                                #  - ede-cbc-sha: #DES
                                                #Can be changed with node --tls-cipher-list=LIST
TLSSOCKET.getEphemeralKeyInfo()->OBJ            #Gets information about cipher's (only [EC]DH) use of perfect forward secrecy:
                                                #  - type '[EC]DH'
                                                #  - name STR
                                                #  - size NUM

TLS.createSecureContext(OBJ)->SECURECONTEXT     #OBJ:
                                                #  - key STR[_ARR]|BUFFER|OBJ_ARR:
                                                #     - server private key, in PEM format
                                                #     - OBJ is { pem STR|BUFFER, passphrase STR }
                                                #        - passphrase is optional
                                                #  - cert STR[_ARR]|BUFFER[_ARR]: server certificate, in PEM format
                                                #  - pfx STR[_ARR]|BUFFER[_ARR]|OBJ_ARR:
                                                #     - key+cert+ca in PFX or PKCS12 format
                                                #     - OBJ is { buf STR|BUFFER[, passphrase STR] }
                                                #  - ca STR[_ARR]|BUFFER[_ARR]:
                                                #     - list of root certificates, in PEM format
                                                #     - def: TLS.rootCertificates
                                                #     - otherwise, can be used to authorize self-signed certificates
                                                #  - passphrase STR: passphrase used to decrypt the server private key (when a private key is encrypted)
                                                #  - crl STR[_ARR]: CRLs, in PEM format
                                                #  - secureProtocol STR:
                                                #     - "SSLv2|3|TLSv1_[client|server_]method": forces SSL version for client and|or server
                                                #        - no client|server means both
                                                #     - def: uses the best one accepted by client
                                                #  - honorCipherOrder BOOL:
                                                #     - if true, server will choose cipher preference, not client
                                                #     - list is designated by ciphers STR
                                                #     - def: false, but true recommended
                                                #  - ciphers STR:
                                                #     - defaults to "*AES*:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA"
                                                #     - AES are in order: 128 > 256, SHA384 > SHA256, ECDHE > DHE, RSA > ECDSA
                                                #  - sessionIdContext STR:
                                                #     - STR concatened in front of SSL session ID.
                                                #     - if requestCert is true, it is a MD5 nonce. Otherwise, it is "".
                                                #  - ecdhCurve STR (def: "auto"): for ECDH
                                                #  - dhparam STR|BUFFER: for DH
                                              9*#  - clientCertEngine STR: OpenSSL engine
                                                #  - secureOptions { CRYPTO.SSL_OP_*: VAL }: OpenSSL options
                                             10*#  - min|maxVersion 'TLSv1[.1|2|3]'
                                             10*#     - def: TLS.DEFAULT_MIN|MAX_VERSION (def: 'TLSv1.2|3')
                                             12*#     - can be set with --tls-min|max-v1.0|1|2|3
                                             11*#     - TLSv1.3 only for Node >=11
                                             12*#  - enableTrace BOOL (def: false): print TLS packets to stderr, for debuggin
                                             12*#  - hints NUM: like DNS.lookup()
TLS.rootCertificates                         12*#STR_ARR. Default well-known root CAs
                                             12*#Are known builtin, either:
                                             12*#  - node --use-bundled-ca (def): Mozilla CA store
                                             12*#  - node --use-openssl-ca:
                                             12*#     - OpensSSL CA store, modified by distributions, can be modified by ENVVARs
                                             12*#     - can use ENVVAR SSL_CERT_DIR=DIR and SSL_CERT_FILE=FILE
                                             12*#Can also be augmented with ENVVAR NODE_EXTRA_CA_CERTS=FILE

TLSSERVER                                       #Child of TCPSERVER:
                                                #  - since it inherits from TCPSERVER, can accept TCP connections, not only SSL ones.
                                                #  - all TLSSERVER will fire for both SSL and normal TCP connections.
                                                #Authorization:
                                                #  - if rejectUnauthorized is true:
                                                #     - non-authorized SSL are still accepted (and communication is encrypted)
                                                #     - but can be checked as non-authorized
                                                #  - certificate check will follow CA chain until CA roots:
                                                #  - authorization also checks the domain in certificate === host being connected
createServer(OBJ[, FUNC(TLSSOCKET)])->TLSSERVER #OBJ:
                                                #  - any SECURECONTEXT.* property
                                             12*#  - any NET.createServer() options
                                                #  - requestCert BOOL (def: false): request authentication (with certificate) of other end (i.e. client)
                                                #  - rejectUnauthorized BOOL (def: true): throw error to other end if cannot authentify it
                                                #  - handshakeTimeout (def: 120000, in ms): when timing out, emits tlsClientError
                                                #  - ALPNProtocols SUBUFFER[_ARR]: list of application protocols that can be used, ordered by priority.
                                                #  - SNICallback('HOST', FUNC(ERROR, OBJ)):
                                                #     - when client asks for SNI, calls it with requested server 'HOST'
                                                #        - if success, must call FUNC(null, OBJ2), where OBJ2 is TLSSOCKET.secureContext
                                                #     - can also use TLSSERVER.addContext('HOST', SECURECONTEXT)
                                                #  - sessionTimeout (def: 300, in sec): expiration for TLS identifiers and session tickets
                                                #  - ticketKeys BUFFER: 48 bytes divided in three 16 bytes parts: prefix, HMAC, AES key
                                                #     - can use TLSSERVER.getTicketKeys()->BUFFER and TLSSERVER.setTicketKeys(BUFFER)
                                                #FUNC is 'secureConnection' event handler
TLSSERVER.setSecureContext(OBJ)              11*#OBJ: any SECURECONTEXT.* property
TLSSERVER.on("secureConnection",FUNC(TLSSOCKET))#Like TCPSERVER.on("connection"), but for SSL.
                                                #Only fired by SSL connections, not normal TCP ones.
TLSSERVER.on
("tlsClientError", FUNC(ERROR, TLSSOCKET))      #See handshakeTimeout
TLSSERVER.on("newSession",FUNC(ID,DATA,FUNC2()))#Fired when client creates new session: ID is the session ID, DATA the shared secret.
                                                #Must fire FUNC2 when done
TLSSERVER.on("resumeSession",                   #Fired when client wants to resume a session. Must call FUNC2() to do so:
FUNC(ID, FUNC2(ERROR, DATA)))                   #  - DATA is the one stored with newSession event
                                                #  - if no new session, ERROR|DATA should be null

connect([PORT_NUM[,'HOST']]OBJ[,FUNC(TLSSOCKT)])#Like TCP.connect(), but for TLS (client connection). OBJ members are:
  ->TLSSOCKET                                   #  - secureContext SECURECONTEXT or SECURECONTEXT.* directly
                                                #  - rejectUnauthorized, ALPNProtocols: like createServer()
                                                #     - except rejectUnauthorized is true by def.
                                                #  - session: like new TLSSocket()
                                             10*#  - timeout: like TCP.connect() OPTS.timeout
                                                #  - host 'HOST', port PORT_NUM, path 'PATH'
                                                #  - socket TCPSOCKET|IOSTREAM: use an existing TCPSOCKET (host+port can be ommitted then)
                                                #  - servername: for SNI, hostname to choose
                                                #  - checkServerIdentity('HOST', CERT_BUFFER): if throw error, refuse connection
                                                #  - minDHSize NUM (def: 1024)
                                                #  - lookup FUNC: DNS lookup, def: DNS.lookup()
                                                #FUNC is 'secureConnect' event handler
                                                #Returns a TLSSOCKET.

TLSSOCKET                                       #Child of TCPSOCKET, but for SSL.
                                                #Contains other end's authentication status and certificate, providing requestCert: true has been used.
new TLSSocket(TCPSOCKET, OBJ)                   #OBJ:
                                                #  - secureContext SECURECONTEXT or SECURECONTEXT.* directly
                                                #  - requestCert, rejectUnauthorized, ALPNProtocols, SNICallback: like createServer()
                                                #  - session BUFFER
                                                #  - requestOCSP BOOL (def: false):
                                                #     - OCSP is alternative protocol to use CRL
                                                #        - ask to Certificate authority instead of using CRL list
                                                #     - TLSSERVER.on('OCSPRequest', FUNC(BUFFER, BUFFER2, FUNC(ERROR, BUFFER3))):
                                                #        - BUFFER[2] are primary|issuer DER-encoded certificates
                                                #        - BUFFER3: see just below
                                                #     - TLSSOCKET.on('OCSPResponse', FUNC(BUFFER3))
                                                #  - isServer BOOL
                                                #  - server TCPSERVER
TLSSOCKET.on("secureConnect", FUNC())           #Like TCPSOCKET.on("connect"), but for SSL.
TLSSOCKET.on('session', FUNC(BUFFER))           #On new TLS session|ticket.
                                                #Same BUFFER as connect() and new TLSSocket() OPTS.session
TLSSOCKET.getPeerCertificate([BOOL])->OBJ       #Returns other end's certificate.
                                                #OBJ: subject, issuer, valid_from|to, fingerprint[256], pubkey, etc.
                                                #If true, returns full chain, i.e. OBJ.issuer
TLSSOCKET.getCertificate()->OBJ                 #Same but for current end.
TLSSOCKET.encrypted                             #Always true. To distinguish from TCPSOCKET.
TLSSOCKET.authorized                            #False if certificate was not signed by CA specified in ca: STR_ARR
                                                #If false, reason might be given in TLSSOCKET.authorizationError STR
TLSSOCKET.getCipher()->OBJ                      #Current SSL cipher used as { name STR, version STR }
TLSSOCKET.getProtocol()->STR                    #Among 'SSLv3|TLSv1[.1|2]|unknown'
TLSSOCKET.alpnProtocol                          #Protocol selected among ALPNProtocols (see above)
TLSSOCKET.servername                            #For SNI, chosen 'HOST'
TLSSOCKET.renegotiate(OBJ[, FUNC(ERROR)])       #OBJ: rejectUnauthorized, requestCert
                                                #Automatically done after session expires:
                                                #  - TLS.CLIENT_RENEG_LIMIT (def: 3) times every TLS.CLIENT_RENEG_WINDOW (def: 600, in sec),
                                                #to avoid DDoS as it takes resources
TLSSOCKET.disableRenegotiation()                #
TLSSOCKET.setMaxSendFragment(NUM)->BOOL         #Def|max: 16384. Min: 512.
                                                #True on success.
                                                #Smaller: smaller latency but slower.
TLSSOCKET.getSession()->OBJ                     #OBJ: ASN.1 encoded
TLSSOCKET.getTLSTicket()->BUFFER                #
TLSSOCKET.get[Peer]Finished()->BUFFER           #Returns the "Finished" message, i.e. a hash of the handshake

--trace-tls                                  12*#
TLSSOCKET.enableTrace()                      12*#Same as SECURECONTEXT.enableTrace

TLSSERVER.on
 ('keylog', FUNC(BUFFER, TLSSOCKET))         12*#TLS key in NSS SSLKEYLOGFILE format. Usually used with Wireshark to decrypt SSL traffic.
TLSSOCKER.on('keylog', FUNC(BUFFER))         12*#Can be emitted multiple times: concatenation of BUFFER is the whole file.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             HTTP              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--http-parser=legacy|llhttp                  11*#Low-level HTTP parsing library:
                                             11*#  - legacy
                                             11*#  - llhttp: faster
                                            <12*#Def: legacy
                                             12*#Def: llhttp

STATUS_CODES                                    #{ STATUS_NUM: 'STATUS_NAME', ... }
                                                #Misses 419
METHODS                                         #STR_ARR of HTTP methods, including common ones, WEBDEV and more obscure ones

HTTPSERVER                                      #Child of TCPSERVER
createServer([OPTS, ][FUNC()])->HTTPSERVER      #FUNC is 'request' event handler
                                                #OPTS:
                                                #  - IncomingMessage|ServerResponse FUNC: to replace constructors of REQ|RES
HTTPSERVER.on("request", FUNC(REQ, RES))        #Fired on client request
HTTPSERVER.on("checkContinue", FUNC(REQ, RES))  #Fired on client request with Expect: 100-continue [C]
                                                #If request is ok, should use RES.writeContinue() to sends a 100 status code
                                                #to the client.
HTTPSERVER.on                                   #Fired on client request with CONNECT method
("connect", FUNC(REQ, TCPSOCKET, BUFFER))       #Client's body is in BUFFER.
HTTPSERVER.on                                   #Fired on client request with Upgrade [C]
("upgrade", FUNC(REQ, TCPSOCKET, BUFFER))       #Client's body is in BUFFER.
HTTPSERVER.on("clientError",FUNC(ERR,TCPSOCKET))#Fired on connection problem.
                                                #Def: TCPSOCKET.destroy()
                                                #ERR has members:
                                                #  - bytesParsed NUM
                                                #  - rawPacket BUFFER

HTTPSERVER.maxHeadersCount                      #Maximum number of headers incoming (def: 1000, 0 for unlim)
HTTPSERVER.maxHeaderSize
--max-http-header-size NUM                    8*#Def: 8KB. If above, fires 'clientError'.
                                             12*#If no 'clientError' handler, returns 431.

RES|CLIENTREQ.setTimeout(UINT[, FUNC()])        #Call underlying TCPSOCKET.*
RES|CLIENTREQ.on("timeout", FUNC())             #Unless 'timeout' event handler overriden, calls RES|CLIENTREQ.socket.destroy()
HTTPSERVER.setTimeout(UINT[, FUNC()])           #Calls RES.setTimeout(...) on each new RES
HTTPSERVER.timeout                              #Same
--http-server-default-timeout NUM            12*#Default value (def: 12e4, i.e. 2 mins) of HTTPSERVER.setTimeout|timeout
                                             12*#0 to disable
HTTPSERVER.on("timeout", FUNC(RES))             #Called when any RES 'timeout' event is fired
HTTPSERVER.headersTimeout                    11*#Like HTTPSERVER.timeout but for the time taken to receive HTTP headers.
                                             11*#Def: 4e4, i.e. 40 secs

HTTPSERVER.keepAliveTimeout                     #Keep TCPSOCKET NUMms (def: 5000) after RES.end() was called, so it can be
                                                #reused if a new request from same host arrives.
                                                #0 to disable.
                                                #It is different from REQ|CLIENTREQ|HTTPSERVER.timeout:
                                                #  - HTTPSERVER.timeout is for idleness while request is ongoing
                                                #  - HTTPSERVER.keepAliveTimeout is for idleness between requests
                                                #Is not Keep-Alive: timeout=NUM [S] but behaves like if Keep-Alive: timeout=NUM [C]
                                                #was specified (although that header does not exist).
                                                #As long as TCPSOCKET is opened, TCPSOCKET.unref() won't be called, keeping the
                                                #server open.

CLIENTREQ.NoDelay|SocketKeepAlive(...)          #Call underlying TCPSOCKET.*

REQ                                             #ISTREAM, reading the body
REQ.httpVersion[Major|Minor]                    #
REQ.method                                      #"GET|DELETE|..." (not for CLIENTREQ's REQ)
REQ.url                                         #STR (not for CLIENTREQ's REQ). Does not include origin
REQ.headers                                     #As { VAR: 'VAL'[_ARR] ... }. Normalized:
                                                #  - 'VAR' lowercase
                                                #  - duplicates:
                                                #     - common ones are merged as 'VAL'
                                                #     - Set-Cookie: 'VAL'_ARR
                                                #     - others are joined with ','
REQ.rawHeaders                                  #As [ 'VAR', 'VAL', ... ]. Not normalized
REQ.[raw]trailers                               #Same for trailer headers
REQ.statusCode|Message                          #Only for CLIENTREQ's REQ
REQ.socket                                      #TCPSOCKET
REQ.flush()                                     #Send the headers right away, instead of trying to send in same TCP packet
                                                #as body.
                                                #Useful if headers are given quickly but body retrieval takes time.
REQ.on('aborted', FUNC())                       #Aborted by client
REQ.aborted                                   8*#BOOL

RES                                             #OSTREAM, writing the body:
                                                #  - headers must be set first
                                                #  - write() sends to client
                                                #  - end() finishes
                                                #Automatically create following headers:
                                                #  - Date [S] (if RES.sendDate true (def))
                                                #  - Connection: keep-alive [S]
                                                #  - Transfer-Encoding: chunked [S]
RES.on("close", FUNC())                         #Fired if closed before end() was called
RES.headersSent                                 #True if headers are sent
RES.finished                                    #True if all sent (i.e. after end())
RES.writableFinished                         12*#True if all sent + flushed
RES.statusCode|Message                          #If statusMessage not set, use STATUS_CODES[statusCode]
RES.setHeader('VAR', 'VAL'[_ARR])               #'VAL'_ARR: same as doing setHeader() several times.
RES.getHeader('VAR')->'VAL'[_ARR]               #
RES.getHeaderNames()->'VAR'_ARR                 #
RES.getHeaders()->OBJ                           #
RES.hasHeader('VAR')->BOOL                      #
RES.removeHeader('VAR')                         #
RES.writeHead(STATUS_NUM[, 'STATUS_NAME'][,OBJ])#Sets RES.statusCode|Message|headers (must be done only once)
                                             11*#Returns RES
RES.addTrailers(OBJ)                            #Add trailing header fields, i.e. between write() and end() of the body.
                                                #Do not forget Trailer [C] at beginning of response
RES.writeProcessing()                        10*#Send 102 response

ON-HEADERS(RES, FUNC())                        ##Fires FUNC() (with RES as this) just before RES starts sending headers
                                               ##Node module 'on-headers' (1.0.1)

CLIENTREQ                                       #Outgoing HTTP request (as opposed to incoming)
                                                #OSTREAM (like RES)
                                                #Headers:
                                                #  - Content-length [C]: only compatible with utf8 encoding for write()
                                                #  - Expect: 100-continue [C]:
                                                #     - call end() right away
                                                #     - should set a timeout
                                                #     - and listen to 'continue' event
                                                #  - default:
                                                #     - all:
                                                #         Host: HOST:PORT [C]
                                                #         Connection: keep-alive [C]
                                                #     - not GET|HEAD:
                                                #         Transfer-Encoding: chunked [C]
request(['URI'|URI][, OBJ][, FUNC(REQ)])        #Sends a HTTP request.
 ->CLIENTREQ                                    #Can use URI
                                             10*#Can use both first arguments, instead of OBJ.url
                                                #OBJ:
                                                #  - protocol STR (def: 'http:')
                                                #  - host[name] STR (def: "localhost")
                                                #     - prefer hostname
                                                #     - will fire exception if non existing
                                                #  - family 4|6 (def: both)
                                                #  - port PORT_NUM (def: 80)
                                                #  - socketPath STR: incompatible with host[name] and port
                                                #  - localAddress STR
                                                #  - method STR (def: "GET")
                                                #  - path STR (def: "/"): including hash and query string
                                                #  - headers OBJ
                                                #  - auth STR: e.g. "auth:password"
                                                #  - agent AGENT|false (def: globalAgent)
                                                #  - keepAlive[Msecs]: see AGENT
                                                #  - createConnection(...): see AGENT
                                                #  - timeout NUM
                                                #FUNC is 'response' event handler.
get(['URI'|URI][, OBJ][, FUNC(REQ)])            #Same but use method "GET" and automatically calls OSTREAM.end()
CLIENTREQ.on("socket", FUNC(TCPSOCKET))         #Fired when socket is created to send the request.
CLIENTREQ.on("response", FUNC(REQ))             #Response of the server.
                                                #REQ must be read, no matter what.
CLIENTREQ.on("continue", FUNC())                #Fired when server responds with Expect: 100-continue [S]
CLIENTREQ.on("checkExpectation",FUNC(REQ, RES)) #Fired when server responds with Expect [S], except Expect: 100-continue [S]
CLIENTREQ.on("information", FUNC(OBJ))       10*#Fired when server responds with 1** (excluding 101)
                                             10*#OBJ: statusCode STR
CLIENTREQ.on
("connect", FUNC(REQ, TCPSOCKET, BUFFER))       #Fired when server responds to a CONNECT request
CLIENTREQ.on
("upgrade", FUNC(REQ, TCPSOCKET, BUFFER))       #Fired when server responds with Upgrade [S]
CLIENTREQ.abort()                               #
CLIENTREQ.on('abort', FUNC())                   #Aborted by client, i.e. CLIENTREQ.abort()
CLIENTREQ.on('aborted', FUNC())                 #Aborted by server
CLIENTREQ.flushHeaders()                        #Like REQ.flush()

AGENT                                           #Socket pools manager for CLIENTREQ (not REQ|RES)
new AGENT(OBJ)                                  #OBJ is:
                                                #  - maxSockets NUM (def: Infinity):
                                                #     - max busy + free sockets per host.
                                                #     - increasing just affect pooling, i.e. more memory used but faster
                                                #     - but does not affect max. number of sockets per host (unlim.)
                                                #  - maxFreeSockets NUM (def: 256):
                                                #     - max free sockets.
                                                #     - only relevant if keepAlive true
                                                #  - keepAlive BOOL (def: true): keep free sockets opened for use
                                                #  - keepAliveMsecs NUM (def: 1000)
                                                #  - timeout NUM
AGENT.max[Free]Sockets                          #
AGENT.[free]sockets                             #Current TCPSOCKET_ARR
AGENT.requests                                  #Current REQ_ARR, not assigned to sockets yet.
AGENT.destroy()                                 #To do to destroy free sockets if keepAliveMsecs high, to avoid hanging.
AGENT.keepSocketAlive = FUNC(TCPSOCKET)         #Override function fired on new free socket.
                                                #Def: TCPSOCKET.setKeepAlive(true, keepAliveMsecs); TCPSOCKET.unref(); return true;
AGENT.reuseSocket = FUNC(TCPSOCKET, CLIENTREQ)  #Override function fired when free socket is being picked.
                                                #Def: TCPSOCKET.ref();
AGENT.getName(OBJ)                              #Returns OBJ (host, port, localAddress) as unique ID STR
AGENT.createConnection(...)->IOSTREAM           #Same as TCP createConnection(), but can be customized and use any IOSTREAM


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             HTTPS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


HTTPS ==>                                       #Has exactly same members as HTTP except:
                                                #  - createServer(OBJ[, FUNC]): OBJ is same as TLS|HTTP.createServer()
                                                #  - all members:
                                                #      - inherit from HTTP, e.g. HTTPSSERVER inherits HTTPSERVER
                                                #      - use TLS* objects instead of TCP*, e.g. TLSSERVER <- TCPSERVER, TLSSOCKET <- TCPSOCKET, etc.
                                                #      - as such, can be used as HTTP server too
                                                #  - new AGENT(OBJ) and request(OBJ) can use:
                                                #     - all options from TLS.createSecureContext(OBJ)
                                                #     - 'rejectUnauthorized|servername' options from TLS.connect(OBJ)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              URL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NODE_URI                                        #Prefer URI
                                                #OBJ:
                                                #  - protocol STR|null
                                                #  - slashes BOOL: if AUTHORITY starts with //
                                                #  - auth STR|null
                                                #  - host STR|null
                                                #  - port STR|null
                                                #  - hostname STR|null
                                                #  - pathname 'PATH'|null
                                                #  - path 'PATH?QUERY'|null
                                                #  - search '?QUERY'|QUERY_OBJ
                                              9*#    or null
                                                #  - query 'QUERY'|null
                                                #  - hash '#HASH'|null
                                                #  - href 'URI'
                                             11*#Deprecated
parse('URI'[, BOOL[, BOOL2]])->NODE_URI         #BOOL: if true (def: false), NODE_URI.search is QUERY_OBJ
                                                #BOOL2: if true (def: false), protocol can be omitted
                                             11*#Deprecated
resolve('BASE_URI', 'RELATIVE_URI')->'URI'      #
                                             11*#Deprecated

URI                                             #As opposed to NODE_URI, is isomorphic, i.e. same as in browser (see DOM doc)
                                             10*#Including the fact that URL is a global object
new URL("URI"[, URI2|'URI2'])->URI              #See DOM doc
format(URI[, OPTS])->'URI'                      #OPTS:
                                                #  - auth BOOL: if false (def: true), ignores username|password
                                                #  - fragment BOOL: if false (def: true), ignores hash
                                                #  - search BOOL: if false (def: true), ignores search
                                                #  - unicode BOOL: if false (def), uses Punycode. Otherwise, URI encoding

ORIGIN                                          #OBJ: scheme STR|null, host STR|null, port STR|undefined, domain STR|null
originFor(...)->ORIGIN                          #Like URL constructor, but returning ORIGIN instead

domainToASCII(STR)->STR2
domainToUnicode(STR)->STR2                      #IDN from|to Punycode

fileURLToPath(URI|'URI')->'PATH'             10*#Conversion between file://* and 'PATH' considering:
pathToFileURL('PATH')->URI|'URI'             10*#  - 'PATH' is OS-specific
                                             10*#  - URI requires percent encoding, but not 'PATH'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          QUERYSTRING          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


stringify(QUERY_OBJ[, STR[, STR2[, OPTS]]])     #'QUERY' is escaped
  ->'QUERY'                                     #STR is separator (def: '&'), STR2 delimiter (def: '=')
                                                #ARR is serialized as several VARs
                                                #OPTS:
                                                #  - encodeURIComponent(...) (def: escape(...)): customize escaping
parse('QUERY'[, STR[, STR2]][, OPTS])->QUERY_OBJ#Inverse.
                                                #OPTS:
                                                #  - maxKeys NUM (def: 1000, 0 for unlim)
                                                #  - decodeURIComponent(...) (def: unescape(...)):
                                                #     - customize escaping
                                                #     - transforms + to spaces (instead of escaping)
                                                #Note: QUERY_OBJ does not inherit from OBJ
[un]escape(STR)                                 #Same as en|decodeURIComponent(), but can be overriden to change stringify|parse() behavior

QS ==>                                         ##See QS module for more features


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              DNS              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DIFFERENCE ==>                                  #DNS.resolve*|reverse() and DNS.lookup*() are similar but:
                                                #  - resolve*|reverse(): use C-Ares, a fast library for DNS resolution, which does DNS query directly.
                                                #  - lookup*():
                                                #     - uses getaddrinfo(), which is slower.
                                                #     - it uses underlying OS, i.e. how DNS resolution would behave on that system (e.g. /etc/hosts)
                                                #     - it is used by http.*, tcp.* and udp.* modules.
                                                #Resolving manually the host can give better performance.

lookup('HOST'[, OBJ], FUNC(ERROR, 'HOST', STR4))#DNS forward lookup.
                                                #STR4 is family: 4 (IPv4), 6 (IPv6) or null (both).
                                                #OBJ:
                                                #  - family 4|6|null
                                                #  - hints NUM: or'd flags among:
                                                #     - DNS.ADDRCONFIG
                                                #     - DNS.V4MAPPED: if look for IPv6 but none found, return IPv4 mapped as IPv6
                                                #  - all BOOL: if true (def: false), return all address as STR4_ARR, not only first one
                                                #  - verbatim BOOL: if false (def), reorder IPv4 before IPv6
                                                #The ERROR.name can correspond to several DNS.*, like DNS.NOTFOUND, DNS.NODATA, DNS.NOMEM, etc. (see online doc)
lookupService
(IP, PORT, FUNC(ERROR, 'HOST', 'SCHEME'))       #

new Resolver()                                  #RESOLVER
                                                #In following methods, if RESOLVER is missing, use builtin RESOLVER
[RESOLVER.]resolve
 ('HOST'[, STR2], FUNC(ERROR, VAL_ARR))         #Same as lookup() but STR2 can any PTR record type: "A" (def), "AAAA", "MX", "TXT", "SRV", "PTR", "NS", "CNAME", "SOA", "NAPTR" or "ANY" (guesses)
[RESOLVER.]resolveSTR2                          #Same. STR2 is camelcase, and "A"|"AAAA"->4|6
 ('HOST', [OBJ, ]FUNC(ERROR, VAL_ARR))          #OBJ (only with records "A"|"AAAA"):
                                                #  - ttl BOOL: if true (def: false), VAL is { address STR, ttl NUM }
[RESOLVER.]reverse('IP', FUNC(ERROR,'HOST'_ARR))#DNS reverse lookup.

[RESOLVER.]setServers('IP[:PORT]'_ARR)          #Sets list of servers IP to use for DNS resolution
[RESOLVER.]getServers()->'IP[:PORT]'_ARR        #List of servers

RESOLVER.cancel()                               #Cancel all current resolve*|reverse() calls, with ERROR with code 'ECANCELLED'

promises.*(...)                              10*#Like DNS.*(...) except returns PROMISE and no RESOLVER.cancel()
                                             11*#No more experimental warning


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              OS               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


platform()->STR                                 #"linux", "darwin", "win32", "android" or "sunos", "aix", "freebsd", "openbsd"
type()->STR                                     #Similar to platform() but slightly more precise.
                                                #E.g. "Linux", "Darwin", "Windows_NT", "CYGWIN_NT*", ""SunOS", "AIX", "FreeBSD", "OpenBSD"
                                             *12#or "MinGW"
release()->STR                                  #OS version number, e.g. "3.11.0-14-generic" (Linux), "18.0.0" (Mac), "10.0.17763" (Windows)
arch()->STR                                     #"arm[64]", "ia32", "x32|x64", "mips[el]", "ppc[64]", "s390[x]"
endianness()->STR                               #"BE" or "LE"

uptime()->DOUBLE                                #In seconds
loadavg()->DOUBLE_ARR                           #For last 1, 5 and 15 minutes.
                                                #Returns [0,0,0] on Windows
totalmem|freemem()->NUM                         #RAM

cpus()->OBJ_ARR                                 #OBJ:
                                                #  - model STR
                                                #  - speed UINT (MHz): varies with the load
                                                #  - times OBJ, ms spent by CPU on each member since uptime: user, sys, idle, nice, irq
                                                #     - nice is always 0 on Windows
networkInterfaces()->OBJ_ARR                    #OBJ:
                                                #  - key is interface name ("lo", "wlan0", etc.)
                                                #  - value is OBJ2_ARR, with OBJ2:
                                                #     - address 'IP'
                                                #     - netmask 'MASK'
                                                #     - cidr 'IP/MASK'
                                                #     - family "IPv4|6"
                                                #     - mac STR
                                                #     - internal BOOL (true if boucle local)
                                                #     - scopeid NUM

hostname()->STR                                 #E.g. "ether-laptop"
tmpdir()->STR                                   #E.g.:
                                                #  - Linux: `/tmp`
                                                #  - Mac: `/var/folders/RANDOM/T`
                                                #  - Windows: `C:\Users\USER\AppData\Local\Temp`
                                                #Uses ENVVAR TMPDIR|'/tmp' (Unix), '{SystemRoot|windir}\\temp' (Windows), TMP|TEMP (any OS)
homedir()->STR                                  #E.g.:
                                                #  - Linux: `/home/USER`
                                                #  - Mac: `/Users/USER`
                                                #  - Windows: `C:\Users\USER`
                                                #Based on ENVVAR HOME (Linux) or USERPROFILE (Windows), or defaults to userInfo().homedir
userInfo([OBJ])->OBJ2                           #OBJ2:
                                                #  - uid|gid NUM (-1 on Windows)
                                                #  - username 'USER' (ENVVAR USER on Unix, USERNAME on Windows)
                                                #  - homedir 'PATH' (based on OS syscalls)
                                                #  - shell 'PATH' (null on Windows)
                                                #Throws in Docker when `--user` points to user with no home nor username.
                                                #OBJ: encoding 'utf8' (def) or 'buffer'

EOL                                             #OS-specific newline "\n" or "\r\n"

setPriority([PID, ]NUM)                      10*#Sets OS process scheduling priority ("niceness").
                                             10*#If 0 (def), current process
                                             10*#NUM is between -20 (high priority) and 19 (low priority) or using os.constants:
                                             10*#  - PRIORITY_LOW: 19
                                             10*#  - PRIORITY_BELOW_NORMAL: 10
                                             10*#  - PRIORITY_NORMAL: 0
                                             10*#  - PRIORITY_ABOVE_NORMAL: -7
                                             10*#  - PRIORITY_HIGH: -14
                                             10*#  - PRIORITY_HIGHEST: -20
getPriority([PID])->NUM                      10*#


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             PATH              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PATH ==>                                        #All these functions look at PATH without caring if file exists.

CROSS-OS ==>                                    #Summary:
                                                #  - should usually use Unix path
                                                #  - except when dealing with input|output outside Node (in shell): use PATH.* then
                                                #  - Node methods input:
                                                #     - Unix path allowed on all OS
                                                #        - but Windows path also allowed in Windows (including mixed)
                                                #     - e.g. require(), PATH.*, FS.*, process.chdir()
                                                #  - Node methods output:
                                                #     - OS-specific
                                                #        - but it's ok since input in Node in Windows allows mixing Unix/Windows
                                                #     - e.g. PATH.*, __dirname, process.argv|execPath|cwd(), OS.userInfo().homedir
                                                #     - exceptions:
                                                #        - PATH.posix|win32.*
                                                #        - output based on input, e.g. createReadStream().path, fs.mkdtemp()
                                                #  - input|output outside Node (in shell): OS-specific

normalize('PATH')->'PATH'                       #Remove leading "./", useless ".." and duplicate "/"
join('PATH',...)->'PATH2'                       #Join with PATH.sep, then do normalize()
resolve('PATH',...)->'PATH2'                    #Like doing several cd 'PATH' from current directory:
                                                #  - 'PATH' can be relative or absolute
                                                #  - 'PATH2' is final DIR, normalized()
relative('PATH', 'PATH2')->'PATH3'              #Print relative PATH3 to go from dir PATH to dir PATH2.
                                                #Return '' if same dir

isAbsolute('PATH')->BOOL                        #

dirname('PATH')->'DIR'                          #
basename('PATH'[, 'EXT'])->'FILE'               #
extname('PATH')->'EXT'                          #Including '.'

parse('PATH')->PATH_OBJ                         #PATH_OBJ: root STR, dir STR, base STR, ext STR, name STR
format(PATH_OBJ)->'PATH'                        #Inverse

sep                                             #OS-specific path delimiter "/" or "\"
delimiter                                       #OS-specific ENVVAR PATH delimiter ":" or ";"
posix|win32.*                                   #Like PATH, but always behave like if on those platforms
toNamespacedPath('PATH')->'PATH'              9*#Returns namespaced path '\\?\LETTER:\'.
                                              9*#Noop unless on Windows.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              FS               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--trace-sync-io                                 #console.trace() when sync I/O is used

CROSS-OS PERMISSIONS ==>                        #Windows permissions are not supported
                                                #  - except for `readonly` file attribute on regular files, which maps to `a+w`
                                                #  - all other permissions are always on
                                                #This affects `umask()`, `chmod()`, `access()`, `stat().mode` and `opts.mode`
                                                #for `mkdir()` and `open()`.

FS-EXTRA                                       ##Replacement for FS, with extra methods.
                                               ##Version 0.16.3
                                               ##Works well with BLUEBIRD.promisifyAll(FS-EXTRA)
WRENCH                                         ##Other filesystem module, but not drop-in replacement of FS.
                                               ##Version 1.5.8

PATH|FILENAME|DIR                               #Either:
                                                #  - STR
                                                #  - URI
                                                #  - BUFFER (less interoperable)
f*                                              #Variant using file descriptior FD_INT
l*                                              #Doesn't deference symlinks

PWD ==>                                         #All relative to process.cwd()
...Sync(...)                                    #All functions have a synchronous variant, without FUNC, except
                                                #[un]watch[File]() and createRead|WriteStream()
                                                #Will throw exceptions instead of using ERROR.

copyFile(PATH, PATH2[, NUM][, FUNC(ERROR)])     #NUM is an or'd flag:
                                                #  - COPYFILE_EXCL: fail if PATH2 already exists
FS-EXTRA.copy(FILE|DIR, FILE|DIR2, FUNC(ERROR))##
WRENCH.copyDirSync[Recursive]                  ##OBJ:
(FILE|DIR, FILE|DIR2[, OBJ][,FUNC(ERROR)])     ##  - forceDelete BOOL: overwrite destination
                                               ##  - excludeHiddenUnix BOOL: copy dotfiles
                                               ##  - preserveFiles BOOL: keep copy when overwriting
                                               ##  - preserveTimestamps BOOL
                                               ##  - inflateSymlinks BOOL: follow symlinks
                                               ##  - filter REGEXP|FUNC(STR)->BOOL: exclude files to copy
                                               ##  - whitelist BOOL: if true, filter works
                                               ##  - include|exclude REGEXP|FUNC(STR)->BOOL
rename(PATH, PATH2, FUNC(ERROR))                #
FS-EXTRA.move(FILE|DIR, FILE|DIR2[, OBJ],
FUNC(ERROR))                                   ##Can use OBJ.clobber true to overwrite.
GULP-RENAME(VAL)                               ##Rename filenames. VAL can be:
                                               ##  - FILENAME_STR (single file)
                                               ##  - OBJ: dirname STR, basename STR, prefix STR, suffix STR, extname STR
                                               ##    (e.g. ".js")
                                               ##  - FUNC(OBJ)->OBJ, with same OBJ as above
                                               ##Version 1.2.0

[f]truncate(PATH|FD_INT, UINT, FUNC(ERROR))     #

[f|l]chown(PATH|FD_INT, UID, GID, FUNC(ERROR))  #Noop on Windows
WRENCH.chownSyncRecursive(DIR, UID, GID)       ##
[f|l]chmod(PATH|FD_INT, UINT, FUNC(ERROR))      #See above for Windows behavior
                                                #lchmod() is only on Mac
WRENCH.chmodSyncRecursive(DIR, UINT)           ##

[f]utimes(PATH|FD_INT, ATIME, MTIME, FUNC(ERR)) #Change atime|mtime
access(PATH[, NUM], FUNC(ERROR))                #Checks if has permission, according to NUM or'd flags:
                                                #  - FS.constants.F_OK (def, always implied):
                                                #     - files exists and its directory list it
                                                #     - also fails if directory and is not executable
                                                #  - FS.constants.R|W|X_OK:
                                                #     - can be read|written|executed
                                                #     - on Windows, only W_OK works and only means "no readonly attribute"
[f|l]stat(PATH|FD_INT,[OPTS,]FUNC(ERROR,FSSTAT))#FSSTAT:
                                                #  - isFile|Directory|Block|CharacterDevice|FIFO|Socket(), (only with lstat()) isSymbolicLink()
                                                #     - on Windows: can only be file, directory or symlink
                                                #  - dev UINT
                                                #  - ino UINT
                                                #  - mode UINT (see above for file type and permissions behavior)
                                                #  - nlink UINT
                                                #  - uid|gid UINT (0 on Windows)
                                                #  - rdev UINT
                                                #  - size UINT
                                                #  - blksize UINT, blocks UINT (both undefined on Windows)
                                                #  - a|m|ctime DATE
                                                #  - a|m|ctimeMs NUM
                                                #  - birthtime DATE: creation time (Windows only)
                                                #  - birthtimeMs NUM: creation time (Windows only)
                                             10*#OPTS:
                                             10*#  - bigint BOOL (def: false): make FSSTAT.* BIGINT instead of UINT

symlink(PATH, PATH2[, STR], FUNC(ERROR))        #STR is 'dir', 'file' or 'junction' (Windows only)
                                            <12*#Def: 'file'
                                             12*#Def: 'file|dir' depending on PATH
link(PATH, PATH2, FUNC(ERROR))                  #Hardlink
GULP-SYMLINK.relative|absolute                 ##Creates a symlink in DIR (creates it if not existing, overwrite if OBJ.force
(DIR_ARR|FUNC(VINYL)->VINYL[,OBJ])             ##true) with same filename as current file, poiting to that file (with a
                                               ##relative|absolute path). Version 2.0.1
readlink(PATH[, OBJ], FUNC(ERROR, PATH2))       #Follow symlink (only once)
                                                #PATH must be a symlink
                                                #OBJ: encoding 'ENCODING'
realpath[.native]                               #Like normalize(), but also follow symlinks (several times if needed), and PATH must exist.
 (PATH[, OBJ], FUNC(ERROR, PATH2))              #OBJ: encoding 'ENCODING'
                                              9*#If "native" does not cache and do less normalization

unlink(PATH, FUNC(ERROR))                       #
rmdir(PATH, FUNC(ERROR))                        #
FS-EXTRA.remove(FILE|DIR, FUNC(ERROR))         ##Like rm -rf
WRENCH.rmdirSyncRecursive(FILE|DIR[, BOOL])    ##Same. If true, fails silently.
RIMRAF(DIR|FILE[, FUNC()])                     ##Same
                                               ##Version 2.2.8
                                               ##Also GULP-RIMRAF([OBJ]):
                                               ##  - Only makes sense after GULP-IGNORE() in the middle of the pipeline
                                               ##    (otherwise use RIMRAF() directly).
                                               ##  - gulp.src() should use { read: false } if only GULP-IGNORE() then
                                               ##    GULP-RIMRAF() are used, so it is faster.
                                               ##  - Must use OBJ.force true if not in $PWD
                                               ##  - Version 0.1.0

mkdir(PATH[, MODE_INT|OPTS], FUNC(ERROR))    10*#OPTS:
                                                #  - mode MODE_INT (def: 0777) (see above for Windows behavior)
                                             10*#  - recursive BOOL (def: false)
FS-EXTRA.ensureFile|Dir(FILE|DIR,FUNC(ERROR))  ##Create file|dir, including parent dirs, if not existing.
FS-EXTRA.mkdirs(DIR, FUNC(ERROR))              ##Like ensureDir()
WRENCH.mkdirSyncRecursive(DIR[, MODE_INT])

readdir(DIR, [OPTS, ]                           #ls: 'FILE' excludes . and ..
 FUNC(ERROR, 'FILE'|DIRENT_ARR))                #OPTS:
                                                #  - encoding 'ENCODING'
                                             10*#  - withFileTypes BOOL (def: false): whether to return DIRENT_ARR or 'FILE'_ARR
WRENCH.readdirSync[Recursive]
(DIR[, OPTS][, FUNC(ERROR, STR2_ARR)])          ##Same but recursive
DIRENT.isFile|Directory|Block|CharacterDevice|
 FIFO|Socket|SymbolicLink()->BOOL            10*#
DIRENT.name                                  10*#STR

open(PATH, STR|NUM[, MODE], FUNC(ERROR, FD_INT))#Open a file and return a file descriptor.
                                                #STR are flags: "r|w|a[s|x][+]":
                                                #  - r: O_RDONLY
                                                #  - w: O_TRUNC + O_CREAT + O_WRONLY
                                                #  - a: O_APPEND + O_CREAT + O_WRONLY
                                                #  - +: O_RDONLY|WRONLY -> O_RDWR
                                                #  - x: O_EXCL. Not with 'r'
                                                #  - s: O_SYNC. Not with 'w'. Can be done with 'a'
                                                #NUM are or'd flags:
                                                #  - O_RDONLY|O_WRONLY|O_RDWR: read|write-only or not
                                                #  - O_TRUNC: truncate
                                                #  - O_APPEND: append
                                                #  - O_CREAT: create if not exist
                                                #  - O_CREAT + O_EXCL: fail if exist
                                                #  - O_DIRECTORY: fail if not a directory
                                                #  - O_NOFOLLOW: fail if is a symlink
                                                #  - O_SYMLINK: do not follow symlinks
                                                #  - O_NOATIME: do not update atime (Linux only)
                                                #  - O_DIRECT: try to avoid caching|buffering
                                                #  - O_SYNC: synchronous (wait for data)
                                                #  - O_DSYNC: synchronous (wait for data+metadata)
                                                #  - O_NOCTTY: if file is a terminal device, treat it as a normal file
                                                #  - O_NONBLOCK: use async when opening special files like serial ports
                                                #On Windows, those flags are mapped to file attributes, file permissions and share permissions
                                                #MODE INT is 0666 by def.
close(FD_INT, FUNC(ERROR))                      #
write(FD_INT, TDBUFFER, INT, INT2, [ INT3,]     #Write INT2 bytes from TDBUFFER at its position INT to file FD_INT at its position INT3 (def: current).
FUNC(ERROR, INT4, TDBUFFER))                    #INT4 is the number of bytes written.
                                                #INT|INT2 are optional
write(FD_INT, STR[, INT3,                       #Similar.
['ENCODING', ]] FUNC(ERROR, INT4, STR))         #INT3 is optional
read(FD_INT, TDBUFFER, INT, INT2,
INT3, FUNC(ERROR, INT4, BUFFER))                #
f[data]sync(FD_INT, FUNC(ERROR))                #Flushes to disk
                                                #If 'data', does not flush metadata (e.g. mtime)

readFile                                        #Easier way than using open() and read()
(PATH|FD_INT, [OBJ, ]FUNC(ERROR, BUFFER|STR))   #OBJ:
                                                #  - encoding 'ENCODING' (def: null, i.e. returns BUFFER, otherwise returns STR)
                                                #  - flag STR (def: "r")
                                                #Prefer createReadStream(...).pipe(OSTREAM)
FS-EXTRA.readJson(...)                         ##Same as readFile(), but return as OBJ
write|appendFile(FILENAME|UINT,                 #OBJ has same members but also mode MODE_INT (def: 0666)
[STDBUFFER,] [OBJ, ] FUNC(ERROR))               #Def flag is "w|a"
FS-EXTRA.outputFile(...)                       ##Same as writeFile(), but calls ensureFile() first
FS-EXTRA.writeJson|outputJson(...)             ##Same as writeFile|outputFile(), but with an OBJ (JSON.stringify'd).
createReadStream(PATH[, OBJ])->ISTREAM          #Preferred over readFile().
                                                #Useful with ISTREAM.[.pipe(IOSTREAM)...]pipe(OSTREAM):
                                                #  - transmits to OSTREAM by chunks ("data" events) instead of at once
                                                #    (readFile())
                                                #  - can use IOSTREAM as modular transforms functions (like Unix commands)
                                                #OBJ has members:
                                                #  - flags STR (def: "r")
                                                #  - encoding 'ENCODING' (def: null)
                                                #  - fd FD_INT (def: null)
                                                #  - mode NUM (def: 0666) (see above for Windows behavior)
                                                #  - autoClose BOOL (def: true): close the file descriptor on error|end event
                                                #  - start|end UINT: only use from bytes UINT to UINT2
                                                #ISTREAM has extra:
                                                #  - same members as OBJ
                                                #  - on('open', FUNC(FD_INT))
                                                #  - on('ready', FUNC())
                                             11*#  - pending BOOL: true if 'ready' event not emitted yet
                                                #  - path PATH
                                                #  - pos UINT
createWriteStream(PATH[, OBJ])->OSTREAM         #OBJ has members flags, defaultEncoding, fd, mode, autoClose, start
                                                #OSTREAM has extra:
                                                #  - same members as OBJ
                                                #  - 'open', 'ready', path, pos: like createReadStream()
                                             11*#  - pending: like createReadStream()
                                                #  - bytesWritten UINT
new WRENCH.LineReader(FILE)                    ##Returns LINEREADER
LINEREADER.hasNextLine()                       ##
LINEREADER.getNextLine()                       ##Returns FILE line by line
LINEREADER.close()                             ##

mkdtemp('PATH', FUNC(ERROR, 'PATH2'))           #Create temp file at 'PATHrandom', with random being 6 chars [:alnum:] (36 bits of entropy)
TEMP.open(PREFIX, FUNC(ERROR, OBJ))            ##Creates temp file with permission 0600 under temp directory.
                                               ##OBJ:
                                               ##  - path STR
                                               ##  - fd NUM
                                               ##PREFIX:
                                               ##  - OBJ: prefix STR, suffix STR, dir DIR (def: "", "", OS temp dir)
                                               ##  - STR: only PREFIX_STR
                                               ##  - Path will be TMP_DIR/PREFIX-UUID-AFFIX
                                               ##If TEMP.track() called before, it will erase file on process exit.
                                               ##Version 0.8.1
TEMP.mkdir(PREFIX,FUNC(ERROR,PATH))            ##Same with directory
TEMP.createWriteStream()                       ##Same for file as OSTREAM
TEMP.path(PREFIX)                              ##Same for only the path
TEMP.cleanup(FUNC(ERROR,OBJ))                  ##Remove temp files. TEMP.track() must have been called before.
                                               ##OBJ: files|dirs NUM


watch('FILE|DIR'[, OPTS][, FUNC])->FSWATCHER    #FSWATCHER fires events when file changes name or content.
                                                #OPTS:
                                                #  - persistent BOOL: if true (def), calls ref(), yielding the macrotask
                                                #  - recursive BOOL (def: false) (not on Linux)
                                                #  - encoding 'ENCODING' (def: 'utf8')
                                                #FUNC is the FSWATCHER 'change' event handler.
                                                #Unstable. Prefer Chokidar.
FSWATCHER.on
('change', FUNC('change|rename', SBUFFER))      #SBUFFER is the FILENAME and is not always provided (e.g. never on MacOSX, and not always on other OS)
FSWATCHER.close()                               #
FSWATCHER.on('close', FUNC())                10*#
FSWATCHER.on('error', FUNC(ERROR))              #

[un]watchFile                                   #Uses polling
(FILE[, OPTS], FUNC(PREV_STAT, NEW_STAT))       #OPTS:
                                                #  - persistent BOOL
                                                #  - interval (def: 5000)

constants                                       #Low-level file-system constants, for the current OS


FS.promises                                  10*#Like FS but:
                                             10*#  - return PROMISE instead
                                             10*#     - no FS.unwatch|watch[File]() nor FS.*Stream()
                                             10*#  - FD_INT are FILE_HANDLE instead
                                             10*#     - no FS.close() but FILE_HANDLE.close() is available
                                             10*#  - FS.constants|Stats|*OK remain on FS.*
                                             11*#No more experimental warning
FILE_HANDLE                                  10*#Abstraction of a file descriptor, with automatic closing on FS PROMISE rejection
FILE_HANDLE.fd                               10*#FD_INT
FILE_HANDLE.FUNC(...)                        10*#Same as FSP.[f]FUNC(FILE_HANDLE, ...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ZLIB              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


createGzip|Deflate[Raw]([OBJ])->COMPRESS        #COMPRESS is a IOSTREAM, so should do:
                                                #  ISTREAM.pipe(IOSTREAM).pipe(OSTREAM)
                                                #See HTTP for different formats.
                                                #Raw: same but does not append a zlib header.
                                                #OBJ can be:
                                                #  - [finish]flush, among:
                                                #     - constants.Z_NO_FLUSH (def)
                                                #     - constants.Z_PARTIAL_FLUSH
                                                #     - constants.Z_SYNC_FLUSH
                                                #     - constants.Z_FULL_FLUSH
                                                #     - constants.Z_FINISH
                                                #     - constants.Z_BLOCK
                                                #     - constants.Z_TREES
                                                #  - chunkSize (def: 16*1024): higher means faster but more memory
                                                #  - windowBits (def: 15): from 9 to 15, higher means better compression but
                                                #    more memory.
                                                #  - dictionary TDABUFFER (deflate|inflate only) (def: "")
                                                #OBJ (compression only):
                                                #  - level: higher means better compression but slower, among:
                                                #     - constants.Z_DEFAULT_COMPRESSION (def)
                                                #     - constants.Z_BEST_SPEED
                                                #     - constants.Z_BEST_COMPRESSION
                                                #     - constants.Z_NO_COMPRESSION
                                                #  - memLevel (def: 8): from 1 to 9, higher means better compression but more
                                                #    memory.
                                                #  - strategy, make compression better, according to type of data, among:
                                                #     - constants.Z_DEFAULT_STRATEGY: almost random data, and small values
                                                #     - constants.Z_FILTERED: in-between
                                                #     - constants.Z_HUFFMAN_ONLY: less random, and large repeating chunk
                                                #     - constants.Z_RLE: same, but specially for PNG data
                                                #     - constants.Z_FIXED: only specific application
                                                #Memory required (in bytes) is:
                                                #  - for compression:
                                                #     - 2^(windowBits+2) + 2^(memLevel+9) + chunkSize, i.e. 272K by def
                                                #  - for decompression:
                                                #     - 2^windowBits + chunkSize, i.e. 48K by def
createBrotliCompress([OBJ])->COMPRESS        10*#Same with Brotli. OBJ:
                                             10*#  - flush NUM, finishFlush ENUM, among:
                                             10*#     - constants.BROTLI_OPERATION_PROCESS (def)
                                             10*#     - constants.BROTLI_OPERATION_FINISH (def for last chunk)
                                             10*#     - constants.BROTLI_OPERATION_FLUSH (def for flush())
                                             10*#     - constants.BROTLI_OPERATION_EMIT_METADATA
                                             10*#  - chunkSize NUM (def: 16KB)
                                             10*#  - params OBJ:
                                             10*#     - [constants.BROTLI_PARAM_MODE] ENUM, among:
                                             10*#        - constants.BROTLI_MODE_GENERIC (def)
                                             10*#        - constants.BROTLI_MODE_TEXT: best for UTF-8 text
                                             10*#        - constants.BROTLI_MODE_FONT: best for WOFF 2.0 fonts
                                             10*#     - [constants.BROTLI_PARAM_QUALITY] NUM:
                                             10*#        - between constants.BROTLI_MIN|MAX_QUALITY (0|11)
                                             10*#        - def constants.BROTLI_DEFAULT_QUALITY (11)
                                             10*#        - higher gives better compression but consumes more CPU-time
                                             10*#     - [constants.BROTLI_PARAM_LGWIN] NUM:
                                             10*#        - between constants.BROTLI_MIN|MAX_WINDOW_BITS (10|24)
                                             10*#           - max BROTLI_LARGE_MAX_WINDOW_BITS (30) if BROTLI_PARAM_LARGE_WINDOW true
                                             10*#        - def constants.BROTLI_DEFAULT_WINDOW (22)
                                             10*#        - higher gives better compression, but consumes more memory, i.e. 2**NUM (i.e. def is 4MB)
                                             10*#     - [constants.BROTLI_PARAM_LGBLOCK] NUM:
                                             10*#        - between constants.BROTLI_MIN|MAX_INPUT_BLOCK_BITS (16|24)
                                             10*#        - higher gives better compression, but consumes more memory, i.e. 3 ** NUM
                                             10*#     - [constants.BROTLI_PARAM_SIZE_HINT] NUM:
                                             10*#        - input size hint
                                             10*#        - def 0, i.e. unknown
                                             10*#     - [constants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING] BOOL:
                                             10*#        - if true (def: false), poorer compression but faster decompression
                                             10*#     - [constants.BROTLI_PARAM_LARGE_WINDOW] BOOL:
                                             10*#        - if true (def: false), allow large windows, good for huge files
                                             10*#     - [constants.BROTLI_PARAM_NPOSTFIX|NDIRECT] NUM:
                                             10*#        - def 0
                                             10*#        - hint for number of direct distance codes and postfix bits.
                                             10*#        - those are two internal parameters of the algorithms, to use only when knowing it.
createGunzip|Inflate[Raw]|Unzip([OBJ])->UNCOMPRS#UNCOMPRESS is a IOSTREAM.
                                                #Unzip: autodetect whether Gunzip or Deflate (but not DeflateRaw).
createBrotliDecompress([OBJ])->UNCOMPRESS    10*#Same with Brotli. OBJ:
                                             10*#  - [constants.BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION] BOOL:
                                             10*#     - affects internal memory allocation
                                             10*#  - [constants.BROTLI_DECODER_PARAM_LARGE_WINDOW] BOOL: same as for compression
[UN]COMPRESS.flush([NUM, ]FUNC(ERROR))          #Compression uses an internal cache. Flush it.
                                                #Don't call unless necessary, because it impacts performance.
                                                #NUM def is constants.Z_FULL_FLUSH|BROTLI_OPERATION_FLUSH. See above for other values.
[UN]COMPRESS.reset()                            #Stop compressing any data going through.
                                                #Only for Deflate|Inflate
[UN]COMPRESS.params(LEVEL, STRATEGY,FUNC(ERROR))#
[UN]COMPRESS.bytesWritten                    10*#NUM

gzip|deflate[Raw]|brotliCompress
(STDABUFFER[, OBJ],FUNC(ERROR, BUFFER))         #
gunzip|inflate[Raw]|unzip|brotliDecompress
(STDABUFFER[, OBJ],FUNC(ERROR, BUFFER2))        #Convenience methods
*Sync(...)                                      #Same but sync


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           WARNINGS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WARNINGS ==>                                    #Are similar to console.warn() except:
                                                #  - can be handled similarly to an exception, but does not stop execution
                                                #  - not part of normal JavaScript code flow
                                                #  - used by Node.js internal warnings, e.g. deprecations
                                                #  - should try to emit only once
                                                #By def, printed to console with console.warn()

--no-warnings
NODE_NO_WARNINGS=1 ENVVAR                       #Does not print to console
--trace-warnings                                #Use console.trace() instead of console.warn()
--redirect-warnings=FILE
NODE_REDIRECT_WARNINGS=FILE ENVVAR              #I.e. will not be printed to console

PROCESS.emitWarning(ERROR)
PROCESS.emitWarning('MESSAGE'[, 'TYPE']         #Creates a warning
[, 'ID'][, FUNC(ERROR)->ERROR])                 #Def TYPE: 'Warning'
PROCESS.emitWarning('MESSAGE',                  #Same.
[{ type, code, ctor, detail }])                 #detail is extra message on next line (e.g. stack trace)

process.on('warning', FUNC(ERROR))              #Fired on warnings.
                                                #ERROR: message 'MESSAGE', name 'TYPE', code 'ID', detail STR
                                                #ERROR.code|detail might be undefined


DEPRECATION ==>                                 #Type of warning with TYPE "DeprecationWarning"

UTIL.deprecate(FUNC, 'MESSAGE'[, 'ID'])->FUNC   #Make FUNC fire PROCESS.emitWarning('MESSAGE', 'DeprecationWarning', 'ID')

--no-deprecation
--trace-deprecation                             #Like --no|trace-warnings but for deprecations
--throw-deprecation                             #throw error on deprecation
--pending-deprecation
NODE_PENDING_DEPRECATION=1 ENVVAR               #Includes upcoming deprecations


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PROCESS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXIT EVENTS ==>                                 #  - normal exit: beforeExit, exit
                                                #  - uncaught exception: uncaughtException, exit
                                                #  - process.exit(): exit
                                                #  - process.abort(): none
                                                #  - signals: only signals events
                                                #The only handler that will prevent exit from happening (graceful exit)
                                                #are SIGINT|SIGTERM
on("beforeExit", FUNC(INT))                     #FUNC() can be async. If async, it will be fired again. To avoid infinite loop,
                                                #last iteration must not add any microtask|macrotask.
                                                #INT is the exit code
on("exit", FUNC(INT))                           #FUNC() must be sync
process.exitCode                                #INT set in 'exit' handler providing either process.exit() or uncaught exception.

on("uncaughtException", FUNC(ERROR, STR))       #Any exception thrown and not caught in try/catch
                                                #Can be exception top-level or within a microtask/macrotask
                                                #  - e.g. a callback or request handler
                                                #  - not possible with Express since it catches any error within request handler
                                                #Unless an event handler exists, calls process.exit(1)
                                                #  - should always call process.exit(1) within event handler to keep this behavior
                                             12*#STR is either:
                                             12*#  - 'unhandledRejection': came from --unhandled-rejections=strict
                                             12*#  - 'uncaughtException': otherwise
setUnaughtExceptionCaptureCallback            9*#Same as on("uncaughtException") except:
 (FUNC(ERROR)|null)                           9*#  - unsets "uncaughtException" handler
                                              9*#  - unsets --abort-on-uncaught-exception
hasUnaughtExceptionCaptureCallback()->BOOL    9*#
--abort-on-uncaught-exception                   #Create a dump file when process exited because of uncaught exception

exit([UINT])                                    #Exit with exit code UINT (def: 0)
                                                #Pending microtasks|macrotasks will be aborted. Streams won't be flushed.
abort()                                         #Aborts: exits + produce a core file.

pid                                             #
ppid                                            #Parent's pid

SIGNALS ==>                                     #Node specifics:
                                                #  - signal 0 can be used to test for process existence
                                                #  - "SIGUSR1" will start debugger (not on Windows)
                                                #  - handling SIGINT|SIGTERM will remove default handler
                                                #  - cannot handle SIGKILL|SIGSTOP
                                                #Only on Linux: SIGPOLL, SIGPWR, SIGUNUSED
                                                #Only on Mac: SIGINFO
                                                #On Windows, only following work:
                                                #  - process.kill() only: 0, SIGINT, SIGTERM, SIGKILL
                                                #     - SIGINT can use process.on() but only with CTRL-C
                                                #  - process.on() only:
                                                #     - SIGBREAK: CTRL-BREAK on Windows, similar to CTRL-C
                                                #     - SIGHUP: closing cmd.exe window
                                                #     - SIGWINCH, SIGILL, SIGABRT, SIGFPE, SIGSEGV

kill(PID_INT[, 'SIGNAME'|SIGNUM])               #Sends a signal (def: "SIGTERM").
                                                #If PID_INT doesn't exist, throw exception (can use 0 to just test process existence).
                                                #If PID_INT is negative, targets also descendants (Unix only)
OS.constants.signals.SIGNAME                    #SIGNUM
                                                #SIGNAME is OS-agnostic, SIGNUM is OS-specific
on('SIGNAL', FUNC('SIGNAL'))                    #Fires when signal emitted on current process.

on('unhandledRejection, FUNC(VAL, PROMISE))     #When PROMISE:
                                                #  - is rejected
                                                #  - and has no handler (PROMISE.catch())
--unhandled-rejections=STR                   12*#What to do on 'unhandledRejection':
                                             12*#  - 'strict': (unless 'unhandledRejection' event handler) warning + uncaughtException
                                             12*#  - default: (unless 'unhandledRejection' event handler) warning + (once) deprecation warning
                                             12*#  - 'warn': warning
                                             12*#  - 'none': nothing
on('rejectionHandled, FUNC(PROMISE))            #When adding PROMISE.catch() on a PROMISE that:
                                                #  - was already rejected
                                                #  - and had no handler when it was rejected (i.e. 'unhandledRejection')
                                                #  - and was rejected in a previous macrotask
on('multipleResolves',                       10*#When PROMISE is resolved|rejected more than once
 FUNC(STR, PROMISE, VAL))                    10*#  - including being resolved after being rejected, or vice-versa
                                             10*#STR is 'resolve|reject'. VAL is the resolved|rejected value.
                                             10*#STR|VAL are not the initial resolution|rejection but the extra one.

argv                                            #Command line args as STR_ARR. Doesn't include node options.
                                                #First is "node", second the absolute path of FILE, then the other arguments.
execArgv                                        #Same but only for node options (exclude all STR of argv)
execPath                                        #Absolute path of node executable used.
env                                             #Environment variables, as OBJ. Values are strings.
                                                #Case-insensitive on Windows.
title                                           #Process title displayed in ps. Read/write. Usually short max length.
--title STR                                  10*#Set PROCESS.title

cwd()->'DIR'                                    #Current directory
                                                #Is the one of the main file. Required files do not change it.
chdir('DIR')                                    #

CROSS-OS ==>                                    #All the following throw on Windows
get[e]gid|[e]uid()                              #
set[e]gid|[e]uid(UINT|STR)                      #
getgroups()
setgroups(STR_ARR)                              #Supplementary GIDs.
initgroups(STR, STR2[_ARR])                     #

umask([UINT])                                   #See below for Windows behavior

version                                         #Node.js version 'vSERMVER'
release.name                                    #'node|io.js'
release.sourceUrl|headersUrl                    #'URL'
release.lts                                     #'NAME' when LTS
versions                                        #OBJ with members node v8 uv zlib ares modules nghttp2 napi llhttp http_parser openssl icu unicode cldr tz
config                                          #Config flags and variables used during compilation, as OBJ

arch                                            #Same as OS.arch()
platform                                        #Same as OS.platform()

memoryUsage()->OBJ                              #OBJ
                                                #  - rss, heapTotal, heapUsed
                                                #  - external
cpuUsage([OBJ])->OBJ                            #OBJ: user|system NUM (time usage, in microseconds)
                                                #If OBJ passed, is difference.
uptime()                                        #

resourceUsage()->OBJ                         12*#OBJ:
                                             12*#  - user|systemCPUTime NUM: same as cpuUsage().user|system
                                             12*#  - maxRSS NUM (in KB): max RSS memory
                                             12*#  - minor|majorPageFault NUM: number of page faults
                                             12*#  - fsRead|fsWrite NUM: number of I/O operations
                                             12*#  - [in]voluntaryContextSwitches NUM: CPU time slices switches (not on Windows)
                                             12*#  - sharedMemorySize|unsharedDataSize|unsharedStackSize|swappedOut|ipcSent|ipcReceived|signalsCount NUM: does not work on any OS

hrtime([VAL])->VAL                              #Current time as [UINT, UINT2], where UINT is seconds and UINT2 nanoseconds.
                                                #Not real time, but arbitrary one just to compare with another time check.
                                                #If VAL passed, is difference.
                                                #Better that using new Date(), notably because ns not ms
                                                #Resolution:
                                                #  - 1ms to 1ns, depending on hardware
                                                #  - often 1ns on Linux/Mac machines
hrtime.bigint()->BIGINT                      10*#Same but using BIGINT nanosecs instead of [UINT, UINT2]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        CHILD_PROCESS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


spawn(STR[, STR2_ARR][, OPTS])->CHILDPROCESS    #Creates and runs a CHILDPROCESS from command line "STR ...STR2_ARR"
                                                #  - cwd STR (def: null, i.e. current)
                                                #  - env OBJ (def: process.env)
                                                #  - uid|gid UINT (def: current ones)
                                                #  - encoding 'ENCODING' (def: "buffer")
                                                #  - stdio STR_ARR:
                                                #     - how parent can access child's file descriptors
                                                #     - at least first three ones, stdin|out|err, but can continue with fd 3, etc.
                                                #     - among:
                                                #        - "pipe": enable CHILDPROCESS.stdio[FD_INT]|stdin|out|err
                                                #        - "ipc":
                                                #           - enable CHILDPROCESS.send()
                                                #           - can only do it for one file descriptor.
                                                #           - file descriptor will be available in child's ENVVAR NODE_CHANNEL_NUM
                                                #        - "ignore": with nothing
                                                #        - STREAM: pipe file descriptor to it (like NUM> FILE)
                                                #        - FD_INT: same with parent file descriptor (like NUM&>FD_INT) (not on Windows)
                                                #        - null|undefined (def): "pipe" for stdin|out|err, "ignore" for others.
                                                #     - can use the following shortcuts STR instead:
                                                #        - "ignore": [ "ignore", "ignore", "ignore" ]
                                                #        - "pipe": [ "pipe", "pipe", "pipe" ]
                                                #        - "inherit": [ 0, 1, 2 ]
                                                #  - shell STR3|BOOL (def: false)
                                                #     - false (def): runs 'STR ...STR2_ARR'
                                                #        - on Windows, only works with `*.exe|com|cmd|bat`
                                                #        - no shell escaping done on either Linux/Windows
                                                #     - STR3: runs 'STR3 -c "STR ...STR2_ARR"'
                                                #        - 'STR3 /d /s /c "STR ...STR2_ARR"' instead if cmd.exe
                                                #     - true: same but using '/bin/sh' (Unix) or ENVVAR ComSpec or 'cmd.exe' (Windows)
                                                #  - windowsVerbatimArguments BOOL:
                                                #     - no shell escaping (Windows only)
                                                #     - def: true if OPTS.shell with 'cmd.exe', false otherwise
                                                #  - argv0 STR (def: STR): process.argv[0]
                                                #     - does not work with node.js binary itself
                                                #     - does not modify `process.title` on Windows
                                                #  - detached BOOL (def: false):
                                                #     - child process will outlive parent
                                                #        - regardless on how parent was terminated: normally, runtime error,
                                                #          programmatic signal, CTRL-C, CTRL-\
                                                #        - on Unix, child process always does, even if `detached: false`, except for `CTRL-C` (in terminal)
                                                #     - create a new process group
                                                #  - windowsHide BOOL (def: false):
                                                #     - if detached true, in Windows and in terminal, do not create new terminal window
                                                #Use CHILDPROCESS.ref(), so needs to use unref() if program can exit while CHILDPROCESS is running.
fork(STR[, STR2_ARR][, OPTS])->CHILD_PROCESS    #Same as spawn() but using 'node STR ...STR2_ARR'
                                                #OPTS:
                                                #  - shell: always false
                                                #  - stdio:
                                                #     - def 'inherit'
                                                #     - always add 'ipc' to fourth ARR value
                                                #Extra OPTS:
                                                #  - execPath 'PATH': instead of 'node'
                                                #  - execArgv STR_ARR: arguments passed to execPath (e.g. node CLI flags)
                                                #  - silent BOOL (def: false): same as OPTS.stdio 'pipe'
execFile(STR[, STR2_ARR][, OPTS],               #Same as spawn() but using FUNC() instead of returning CHILDPROCESS.
 FUNC(ERROR, SVAL, SVAL2))->CHILD_PROCESS       #  - SVAL|SVAL2 is stdout|stderr
                                                #Cannot use OPTS: stdio, argv0, detached
                                                #Extra OPTS:
                                                #  - encoding 'ENCODING' (def: 'utf-8')
                                                #  - timeout NUM (def: 0) (in ms)
                                                #  - maxBuffer NUM (def: 200KB): stdout|stderr max size
                                                #  - killSignal 'SIGNAL'|SIGNUM (def: 'SIGTERM'): sent (with CHILD_PROCESS.kill()) on timeout|maxBuffer
exec(STR[, OPTS], FUNC(ERROR, SVAL, SVAL2))
 ->CHILD_PROCESS                                #Same as execFile() but with OPTS.shell def true

spawnSync(...)                                  #Like spawn() except for the following.
                                                #Extra OPTS:
                                                #  - input STDBUFFER: overrides OPTS.stdio[0]
                                                #  - encoding (def: 'buffer')
                                                #  - timeout, killSignal, maxBuffer
                                                #Returns:
                                                #  - pid UINT
                                                #  - stdout|stderr SVAL
                                                #  - output [stdout, stderr]
                                                #  - status NUM: null if killed by signal
                                                #  - signal 'SIGNAL'
                                                #  - error ERROR
exec[File]Sync(...)                             #Like exec[File]() except for the following.
                                                #Extra OPTS: input, stdio, detached, argv0
                                                #Returns SVAL (stdout). Throws on non-0 exit code.

CHILDPROCESS.pid                                #

CHILDPROCESS.stdio[FD_INT]                      #I|OSTREAM for file descriptor FD_INT
CHILDPROCESS.stdin|out|err                      #Same for 0|1|2

PROCESS|CHILDPROCESS.send                       #Communication:
(VAL[, TCPSOCKET|TCPSERVER][, OPTS]             #  - parent use CHILDPROCESS.on("message") and CHILDPROCESS.send(...)
[, FUNC([ERROR])])                              #  - child use PROCESS.on("message") and PROCESS.send(...)
                                                #Child process must have been created using "ipc" (see above)
                                                #When sending a TCPSOCKET|TCPSERVER, it will be shared between parent and child:
                                                #  - packets will arrive randomly at both
                                                #  - only one needs to listen
                                                #  - for TCPSERVER, both can listen to 'connection' event
                                                #FUNC is fired after sending, before target received.
                                                #If FUNC specified, no 'error' event emitted.
                                                #OPTS:
                                                #  - keepOpen BOOL (def: false): see TCPSOCKET
CHILDPROCESS.on("message",
FUNC(OBJ[, TCPSOCKET|TCPSERVER]))               #CHILDPROCESS will not exit until disconnect() is called or parent exits.
CHILDPROCESS.disconnect()                       #Flush all communication, then becomes impossible to do send()
                                                #Do it before exiting.
CHILDPROCESS.connected                          #
CHILDPROCESS.on("disconnect", FUNC())           #
CHILDPROCESS.on("error", FUNC(ERROR))           #When CHILDPROCESS could not send(), be kill() or be spawn()
                                                #The exit event might be fired or not after error event.
CHILDPROCESS.on("exit|close",FUNC(UINT,SIGNAME))#UINT is the exit code, SIGNAME the terminating signal.
                                                #Only one of them is always defined, the other is null.
                                                #exit is when process exits, close is when its file descriptors are closed.
                                                #file descriptors don't close if shared by other processes.
process.signalCode                              #Like process.exitCode but for SIGNAME
CHILDPROCESS.kill(['SIGNAL'|SIGNUM])            #Def: "SIGTERM"
CHILDPROCESS.channel                            #Underlying IOSTREAM for send()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CLUSTER            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GOAL ==>                                        #A single process will only use only one CPU core.
                                                #Using CHILDPROCESS.fork() on the same code to create one child for each CPU
                                                #core.
                                                #Can manage the workers: kill some, manage a pool, etc.
                                                #Work should be done by child processes, master should only manage them.
                                                #Child processes cannot fork() to grandchild processes.
                                                #One common task is to make CHILDPROCESS TCPSERVER.listen(), in which case:
                                                #  - connections will arrive randomly at the child processes listening to
                                                #    the same port.
                                                #    The randomness uses CLUSTER.schedulingPolicy:
                                                #      - CLUSTER.SCHED_RR (def on Unix): improved round-robin
                                                #      - CLUSTER.SCHED_NONE (def on Windows): previous version
                                                #    or use ENVVAR NODE_CLUSTER_SCHED_POLICY "rr|none"
                                                #  - be careful:
                                                #     - listen(TCPSERVER|TCPSOCKET): TCPSERVER|TCPSOCKET must have been sent by master
                                                #       to child, or will create problems
                                                #     - listen({ fd: INT }): looks at parent file descriptor
                                                #  - if UDPSOCKET.bind() or TCPSERVER.listen() OBJ.exclusive true (def: false), socket is not shared
fork([OBJ])                                     #Like CHILD_PROCESS.fork(), but returns a WORKER, which gives extra functions.
                                                #Can fork a separate file for children, but if forking the same file, should
                                                #use if ( CLUSTER.isMaster|Worker ) in beginning of code.
                                                #OBJ is env (def: process.env).
                                                #Options are controlled by CLUSTER.settings, that is available for read once
                                                #CLUSTER.setupMaster(OBJ) has been called to change it (only once):
                                                #  - exec STR: the file the child is forked with (def: process.argv[1])
                                                #  - args STR (def: process.argv.slice(2)): to worker
                                                #  - execArgv STR_ARR (def: process.execArgv): to node
                                                #  - silent BOOL: like CHILDPROCESS.fork() (def: false)
                                                #  - cwd, windowHide
                                                #  - uid|gid UINT, stdio
                                                #setupMaster() fire 'setup'(OBJ) event
on("fork|online", FUNC(WORKER))                 #Fired when a child process is created|ready to respond.
WORKER.on("online", FUNC())                     #
on("listening", FUNC(WORKER, OBJ))              #Fired when a child process use TCPSERVER.listen().
                                                #OBJ has members { address, port, addressType: "[udp]4|6|-1(Unix socket)" }
WORKER.on("listening", FUNC(OBJ))               #

workers                                         #All WORKER in an OBJ, where the key is the WORKER.id
                                                #Only available in parent process.
worker                                          #Current WORKER. Only available in child processes.
WORKER.id                                       #
WORKER.process                                  #The underlying CHILDPROCESS.
                                                #In a WORKER, can use process.* directly

WORKER.send(VAL[,TCPSOCKET|TCPSERVER][, FUNC()])#
WORKER.on
("message", FUNC(OBJ[, TCPSOCKET|TCPSERVER]))   #
on('message', FUNC(WORKER TCPSOCKET|TCPSERVER,
OBJ))                                           #
WORKER.kill(['SIGNAL'])                         #Calls WORKER.disconnect(), then in:
                                                #  - the parent, sends signal (def: "SIGTERM")
                                                #  - the child processes, exit with error code 0

WORKER.disconnect()->WORKER                     #If listen() was called, don't accept new connections and emit TCPSERVER.close()
                                                #when no more connections (only server connections, not CLIENTREQ, that
                                                #are closed directly).
                                                #Might be useful to use a timeout to kill the WORKER if connections keep on
                                                #living.
disconnect(FUNC())                              #Call disconnect() on all child processes (must be done from parent).
on("disconnect", FUNC(WORKER))                  #Fired when a child process use disconnect()
WORKER.on("disconnect", FUNC())                 #
WORKER.isConnected()                            #
WORKER.isDead()                                 #True if exited of thrown exception
WORKER.exitedAfterDisconnect                    #When WORKER exits, will be false if exited because of an exception, and true
                                                #if because of kill() or disconnect()
on("exit", FUNC(WORKER, UINT, 'SIGNAL'|null))   #Fired when a child process exits.
                                                #UINT is the exit code
WORKER.on("exit", FUNC(UINT, 'SIGNAL'|null))    #
WORKER.on("error", FUNC(ERROR))                 #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        WORKER_THREADS         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ISOMORPHISM ==>                              10*#Inspired by DOM workers but with notable differences

--experimental-worker                        10*#Must be used
                                             11*#Must not be used

MULTI-THREADING ==>                          10*#Uses threads not processes, i.e.:
                                             10*#  - uses OS time slicing i.e.:
                                             10*#     - long microtasks are processed in several steps
                                             10*#     - load between threads is balanced by OS
                                             10*#  - for each time slice, uses any available CPU, i.e. scale to all CPUs
                                             10*#I.e. good for CPU-intensive tasks (not I/O intensive)


new Worker('SCRIPT_PATH'[, OPTS])            10*#OPTS:
                                             10*#  - eval BOOL (def: false): use inline 'JAVASCRIPT' instead
                                             10*#  - workerData VAL:
                                             10*#     - assigned to WORKER_THREADS.workerData VAL
                                             10*#     - same possible types as postMessage()
                                             11*#  - execArgv STR_ARR (def: process.execArgv)
                                             11*#  - env OBJ (def: process.env)
                                             11*#     - copied
                                             11*#     - can be require('worker_threads').SHARE_ENV, to pass process.env by reference instead

global.*                                     10*#In worker, like in parent except process.*:
                                             10*#  - exit() affects current thread not current process
                                             10*#  - no abort|chdir|initgroups|set*|umask(VAL)|on('SIGNAL')
                                            <11*#     - no execArgv|umask()
                                             10*#  - env|title are read-only
                                             10*#Worker and parent's global|process.* are distinct.
                                             10*#Unlike DOM, no concept of WORKERGLOBAL nor "self".

process.stdin|stdout|stderr                  10*#Worker has different standard streams than parent, but they are piped:
                                             10*#  - from parent if OPTS.stdin true (def: false)
                                             10*#  - to parent unless OPTS.stdout|stderr true (def: false)
WORKER.stdin|stdout|stderr                   10*#Worker's standard streams, available to parent

WORKER_THREADS.isMainThread                  10*#BOOL. True if is top-level parent.

WORKER_THREADS|WORKER.threadId               10*#NUM
                                             10*#Top-level parent is 0. Then increments for each worker

WORKER.on('online', FUNC())                  10*#When worker is loaded, just before it starts executing

WORKER.terminate()->PROMISE_EXIT_CODE        10*#Worker current microtask will be interrupted
                                             10*#EXIT_CODE will be 1
                                             12*#Async and return a PROMISE

WORKER.on('exit', FUNC(EXIT_CODE))           10*#When worker ends (including because of uncaught exceptions)

WORKER.on('error', FUNC(ERROR))              10*#Uncaught exception within worker.

MESSAGEPORT|WORKER.[un]ref()                 10*#


WORKER|MESSAGEPORT.postMessage               10*#Like DOM except:
 (VAL[, VAL2_ARR])                           10*#  - child can only use MESSAGEPORT, not global "postMessage()"
                                             10*#  - VAL2:
                                             10*#     - can be SHARED_ARRBUFFER
                                             10*#     - when MESSAGEPORT, VAL must be MESSAGEPORT
WORKER|MESSAGEPORT.on('message', FUNC(VAL))  10*#Like DOM except:
                                             10*#  - receive VAL directly, not MESSAGEEVENT
                                             10*#  - MESSAGEPORT will keep process open until MESSAGEPORT.close|unref()
WORKER.receiveMessageOnPort(MESSAGPORT)->VAL 12*#If there is a message VAL in the queue, return it and remove it from queue.
                                             12*#Otherwise return undefined
WORKER.moveMessagePortToContext              11*#Transfer MESSAGEPORT to another global object COBJ (created by VM.createContext())
 (MESSAGEPORT, COBJ)->MESSAGEPORT2           11*#MESSAGEPORT will become unusable
                                             11*#'message' event listeners are kept

new MessageChannel()
MESSAGECHANNEL.port1|2
MESSAGEPORT.start|close()                    10*#Like DOM
MESSAGEPORT.on('close', FUNC())              10*#

WORKER_THREADS.parentPort                    10*#Default MESSAGEPORT available in every worker.
                                             10*#null in parent


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              VM               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ALTERNATIVES ==>                                #When running 'Math.random()'
                                                #Execution time:
                                                #  - as is:  0.000006ms
                                                #  - eval(): 0.0001ms
                                                #  - runIn*Context(): 0.001ms
                                                #     - with SCRIPT: same performance, but can divide between loading (new Script)
                                                #       and executing (SCRIPT.runIn*Context())
                                                #  - spawn(): 1.3ms
                                                #  - Worker(): 6ms
                                                #Security:
                                                #  - as is, eval(): access to current process + context
                                                #  - runIn*Context(): access to current process
                                                #  - Worker(): access to none (providing OPTS.stdin|stdout|stderr true)
                                                #  - spawn(): access to none
                                                #Limits:
                                                #  - as is, eval(): defaults (max call stack, max STR|ARR length)
                                                #  - runIn*Context(): defaults, timeout
                                                #  - Worker(): defaults, seems to crash over 1000 threads
                                                #  - spawn(): defaults, timeout, maxBuffer
                                                #Threads/processes:
                                                #  - as is, eval(), runIn*Context(): same thread|process
                                                #  - Worker(): different thread
                                                #  - spawn(): different process

createContext([CONT_OBJ][, CONT_OPTS])->COBJ    #COBJ is an OBJ with some hidden properties.
                                                #CONT_OBJ is merged in.
                                                #CONT_OPTS:
                                                #  - name STR (def: 'VM Context NUM'): for debugging
                                                #  - origin PROTO://HOST[:PORT] (def: ''): for debugging
                                             10*#  - codeGeneration:
                                             10*#     - strings BOOL (def: true): if false, throws on eval() or derivatives (new Function(...), etc.)
                                             10*#     - wasm BOOL (def: true): if false, throws when trying to compile WASM
isContext(COBJ)->BOOL                           #Returns true if COBJ

runInContext(STR, COBJ[, RUN_OPTS])             #Like eval() but use context COBJ as unique global environment:
                                                #  - passed by reference.
                                                #  - does not have any other access to caller otherwise,
                                                #    including current caller local scope
                                                #Also:
                                                #  - use current process:
                                                #     - same file descriptors
                                                #     - throw exception in current process
                                                #     - should create a new process first if VM used for security reason.
                                                #  - returns synchronous return value from code STR
                                                #     - but can still inspect COBJ passed by reference for async return value,
                                                #       or pass COBJ.FUNC()
                                                #RUN_OPTS:
                                                #  - filename STR, line|columnOffset NUM: for stack trace error message
                                                #  - displayErrors BOOL (def: true): prints to current stderr any stderr
                                                #    from code
                                                #  - timeout NUM: throw error if timeout
runInNewContext(STR[, CONT_OBJ]                 #Same but automatically use createContext(CONT_OBJ, CONT_OPTS)
 [, RUN_OPTS|CONT_OPTS])                        #CONT_OPTS must be prefixed with "context"
runInThisContext(STR[, RUN_OPTS])               #Same as runInNewContext(STR, global)

compileFunction('CODE'[, 'PARAM_NAME'_ARR]   10*#Like new Function() but use OPTS.parsingContext COBJ (def: global)
 [, RUN_OPTS|SCRIPT_OPTS])->FUNC             10*#RUN_OPTS|SCRIPT_OPTS:
                                             10*#  - filename, line|columnOffset, cachedData
                                             10*#  - contextExtensions OBJ_ARR (def: []): objects wrapping COBJ

new Script(STR[, RUN_OPTS|SCRIPT_OPTS])         #Returns a SCRIPT, i.e. a compiled version of STR:
                                                #  - separates compiling from running STR
                                                #  - every run can be bound to different COBJ
                                                #SCRIPT_OPTS:
                                                #  - cachedData BUFFER:
                                             10*#     - can also be TYPED_ARR|DATAVIEW
                                                #     - copy of script, to improve load performance
                                             10*#     - created by SCRIPT.createCachedData()->BUFFER
                                                #     - V8.cachedDataVersionTag()->NUM returns a hash of v8
                                                #       version, CLI flags and CPU features
SCRIPT.runIn[New|This]Context(...)              #Same as run*(STR, ...)
                                                #RUN_OPTS also has:
                                                #  - breakOnSigint BOOL

new SourceTextModule(STR[, MODULE_OPTS])      9*#Same as Script but for ES module
                                              9*#Must use --experimental-vm-modules
                                              9*#MODULE_OPTS:
                                              9*#  - context COBJ: reused by every MODULE.run*(...), i.e. cannot be changed
                                              9*#  - url STR (def: 'vm:module(NUM)'): for debugging
                                              9*#  - filename STR, line|columnOffset NUM: for stack trace error message
VMMODULE.link(FUNC('SPECIFIER',PARENT_MODULE))9*#Specifies the function to resolve SPECIFIERs,
 ->[PROMISE_]VMMODULE                         9*#I.e. same as using import { SPECIFIER } from VMMODULE
                                              9*#Must be called only once.
                                              9*#MODULE and PARENT_MODULE must have same COBJ
VMMODULE.linkingStatus                        9*#Can be:
                                              9*#  - 'unlinked': before VMMODULE.link()
                                              9*#  - 'linking': during VMMODULE.link()
                                              9*#  - 'linked': after VMMODULE.link() success
                                              9*#  - 'errored': after VMMODULE.link() error
VMMODULE.error                                9*#If linkingStatus 'errored', contains link() rejected promise value.
                                              9*#Otherwise, accessing it throws an exception.
VMMODULE.instantiate()                        9*#Might throw if problem importing|exporting
                                              9*#The function is memoized.
                                              9*#Must be called after VMMODULE.link()
VMMODULE.evaluate([RUN_OPTS])->PROMISE(VAL)   9*#Runs the code.
                                              9*#Must be called after VMMODULE.instantiate()
                                              9*#RUN_OPTS: timeout, breakOnSigint
VMMODULE.url                                  9*#
VMMODULE.namespace                            9*#
VMMODULE.dependencySpecifiers                 9*#All 'MODULE'_ARR imported by that module


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CRYPTO             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


setEngine(PATH[, NUM])                          #When using custom OpenSSL or alternative crypto library.
                                                #NUM are or'd flags: ENGINE_METHOD_ALL|RSA|DSA|DH|RAND|ECDH|ECDSA|CIPHERS|
                                                #DIGESTS|STORE|PKEY_[ASN1_]METH|NONE
--openssl-config=FILE
OPENSSL_CONF=FILE ENVVAR                        #

createHash(STR)                                 #Returns a HASH, i.e. a IOSTREAM generator: write|read to it to get hashes.
                                                #STR is the algo.
                                                #CRYPTO.getHashes() gives list of supported hashes algos, as STR_ARR:
                                                #includes [EC]DSA, DSS1, MD4|5, RIPEMD, RMD, SHA1|224|256|384|512, Whirlpool
createHmac(STR, STDBUFFER|KEY)                  #Same but for a HMAC. STR is hash algo. Second argument is the key.
createCipheriv(STR, STDBUFFER|KEY,STDBUFFER|null#Same but for a CIPHER (sym. cipher).
 [, OPTS])                                      #Key must be KEY|TDBUFFER or STR with encoding "binary".
                                                #Third argument is IV.
                                              9*#  - can be null
                                                #CRYPTO.getCiphers() gives list of supported sym. ciphers (including mode of
                                                #operation), as STR_ARR: includes AES, Blowfish, Camellia, CAST, DES, DES3,
                                                #DES-X, IDEA, RC2, RC4, SEED,
                                             11*#ChaCha
                                                #OPTS:
                                                #  - any of STREAM.Transform()
                                              9*#  - authTagLength NUM (def: 16): 4-16 (must be even number)
CIPHER.setAutoPadding(BOOL)                     #If false (def: true), disables padding (PKCS padding).
                                                #Use it for personalized padding, i.e. filling with nulls.
CIPHER.getAuthTag()->BUFFER                     #Returns MAC, for sym. ciphers that produce one ("authenticated
                                                #encryption"), i.e. "GCM" only.
CIPHER.setAAD(BUFFER)->BUFFER2                  #Same but for "additional authenticated data" ("GCM" only)
createDecipheriv(...)
DECIPHER.setAutoPadding(BOOL)                   #Same for decryption.
DECIPHER.setAuthTag(TDBUFFER)                   #
DECIPHER.setAAD(BUFFER)                         #

createDiffieHellman(ARGS)                       #Creates a DIFFIEHELLMAN (used for asym. encryption with HL algo).
                                                #ARGS can be:
                                                #  - NUM[, NUM2]: prime length NUM and generator NUM2 (def: 2).
                                                #  - STDBUFFER[, ENCODING][, NUM|STDBUFFER2[, ENCODING2]]: prime STDBUFFER
                                                #    (def ENCODING: "buffer", can also be "binary|base64") and generator
                                                #    NUM|STDBUFFER2 (def: 2)
DIFFIEHELLMAN.getPrime([ENCODING])->SBUFFER     #
DIFFIEHELLMAN.getGenerator([ENCODING])->SBUFFER #
DIFFIEHELLMAN.generateKeys([ENCODING])->SBUFFER #Creates private and public key, and returns public key.
DIFFIEHELLMAN.getPublic|PrivateKey([ENCODING])
 ->SBUFFER                                      #
DIFFIEHELLMAN.setPublic|PrivateKey
 (STDBUFFER, [ENCODING])                        #
DIFFIEHELLMAN.computeSecret(STDBUFFER           #Creates shared secret by using current private key and other part public key
[, ENCODING][, ENCODING2])->SBUFFER             #STDBUFFER (must have used the same prime and generator)
                                                #ENCODING is other part public key encoding, ENCODING2 shared secret returned.
DIFFIEHELLMAN.verifyError                       #Or'd flags showing warning after initialization among:
                                                #  - CRYPTO.DH_CHECK_P_NOT_SAFE_PRIME
                                                #  - CRYPTO.DH_CHECK_NOT_PRIME
                                                #  - CRYPTO.DH_UNABLE_TO_CHECK_GENERATOR
                                                #  - CRYPTO.DH_NOT_SUITABLE_GENERATOR
getDiffieHellman(STR)                           #Returns a DIFFIEHELLMAN but:
                                                #  - without setPublic|PrivateKey()
                                                #  - according to STR "modp1|2|5|14|15|16|17|18", i.e. prime is constant, but
                                                #    it is faster

createECDH(STR)                              10*#Returns ECDH, elliptic curve version of Diffie-Hellman.
                                             10*#Same as DIFFIEHELLMAN but:
                                             10*#  - last arg FORMAT "[un]compressed|hybrid" (def: "uncompressed") to generateKeys() and getPublicKeys()
                                             10*#  - no getPrime(), getGenerator(), verifyError, setPublicKey()
                                             10*#STR is algo, from CRYPTO.getCurves() as STR_ARR: includes Oakley, brainpool,
                                             10*#c2tnb, prime, secp, sect, wap-wsg-idm-ecid-wtls
ECDH.convertKey(STDBUFFER, 'ALGO'[, ENCODING]
 [, ENCODING2], FORMAT)->SBUFFER             10*#Converts public key STDBUFFER to FORMAT

public|privateEncrypt|Decrypt                   #Encrypts/decrypts asym. (RSA) TDBUFFER, with private|public key STR|KEY|OBJ:
 (STR|KEY|OBJ, TDBUFFER)                        #  - key, format, type, passphrase: like createPrivate|PublicKey()
                                                #  - padding: CRYPTO.constants.RSA_NO|PKCS1[_OAEP]_PADDING

generateKeyPair[Sync]('TYPE', OPTS           10*#Create asym key pair, where SBUFFER is publicKey and SBUFFER privateKey
 [, FUNC(ERROR, SBUFFER, SBUFFER2)])         10*#'TYPE' is 'rsa', 'dsa', 'ec', 'ed25519', 'ed448', 'x25519', 'x448'
 [->{ publicKey|privateKey }]                10*#OPTS:
                                             10*#  - publicKeyEncoding OBJ (def: produces a KEY):
                                             10*#     - type 'pkcs1' (RSA only) or 'spki' (prefered)
                                             10*#     - format 'pem' or 'der'
                                             10*#  - privateKeyEncoding OBJ (def: produces a KEY):
                                             10*#     - type 'pkcs1' (RSA only), 'sec1' (EC only) or 'pkcs8' (prefered)
                                             10*#     - format 'pem' or 'der'
                                             10*#     - cipher 'ALGO', passphrase STR: encrypt using PKCS#5 2.0
                                             10*#  (RSA, DSA)
                                             10*#  - modulusLength NUM: key size (in bits)
                                             10*#  (RSA)
                                             10*#  - publicExponent NUM (def: 0x10001): public exponent
                                             10*#  (DSA)
                                             10*#  - divisorLength NUM: q size (in bits)
                                             10*#  (EC)
                                             10*#  - namedCurve STR: curve name

createPrivate|PublicKey(OPTS|SBUFFER)->KEY   11*#Create asym key pair. OPTS:
                                             11*#  - key SBUFFER or (for 'Public') KEY
                                             11*#  - format 'pem' (def) or 'der': of key
                                             11*#  - type 'pkcs1', 'spki' or (privateKey only) 'sec1': ignored if format 'pem'
                                             11*#  - passphrase SBUFFER (privateKey only)
createSecretKey(BUFFER)->KEY                 11*#Create sym key.

KEY.type                                     11*#'public|private' (if async) or 'secret' (if sync)
KEY.asymmetricKeyType                        11*#'rsa', 'dsa', 'ec', (if sym key) undefined,
                                             12*#'ed25519', 'ed448', 'x25519', 'x448', 'rsa-pss'
KEY.symmetricSize                            11*#Byte length NUM. undefined if async
KEY.export([OPTS])->SBUFFER                  11*#OPTS (if async):
                                             11*#  - type, format, passphrase: like createPrivate|PublicKey()
                                             11*#  - cipher STR

createSign(STR)                                 #Same as createDecipher() but for signing algo STR.
                                                #List can be found with openssl list-public-key-algorithms.
                                                #Includes RSA, DH, DSA, HMAC and CMAC.
                                                #Unless createCipher(), is only a OSTREAM. To read from it, use
                                                #SIGN.sign(SBUFFER|KEY|OPTS[, ENCODING]), where SBUFFER|OPTS|KEY is the private key.
                                                #OPTS:
                                                #  - key, format, type, passphrase: like createPrivateKey()
                                                #  - padding CRYPTO.constants.RSA_PKCS1_[PSS_]PADDING
                                                #  - saltLength NUM, can be:
                                                #     - CRYPTO.constants.RSA_PSS_SALTEN_DIGEST: digest size
                                                #     - CRYPTO.constants.RSA_PSS_SALTEN_MAX_SIGN
createVerify(STR)                               #Same for verifying algo STR.
                                                #Like createSign(), is only a OSTREAM.
VERIFY.verify                                   #Read from createVerify()
 (SBUFFER|KEY|OBJ, STDBUFFER[,ENCODING])        #SBUFFFER is a certificate or a RSA|DSA public key in PEM format
                                             11*#or a private key
                                                #OBJ: padding, saltLength
                                                #STDBUFFER is the signature.
sign(['ALGO, ']STDBUFFER2, SBUFFER|KEY|OPTS)
 ->BUFFER
verify(['ALGO, ']STDBUFFER2, SBUFFER|KEY|OPTS,
 STDBUFFER)->BUFFER                          12*#Shortcut for createSign|Verify()

Certificate()                                   #Returns CERTIFICATE, used for SPKAC, used to send certificates client-side to
                                                #the server with the HTML5 <keygen>.
CERTIFICATE.verifySpkac(TDBUFFER)->BOOL         #
CERTIFICATE.exportChallenge|PublicKey
(STDBUFFER[, ENCODING])->BUFFER                 #

pbkdf2[Sync](STBUFFER, STBUFFER2, NUM, NUM2,    #Generate a random BUFFER using PBKDF2 with HMAC-SHA1, with first arg being
DIGEST[, FUNC(ERROR, BUFFER)])[->BUFFER]        #the input, second the salt (should be min. 64 bits), NUM the number of
                                                #iterations (should be min. 1000) and NUM2 the final string length.

scrypt[Sync](STDBUFFER, STDBUFFER2, NUM      10*#Generate a derived key BUFFER using Scrypt.
 [, OPTS][, FUNC(ERROR, BUFFER)])[->BUFFER]  10*#First arg is the password, second is the salt (should be 16 bytes long), NUM is BUFFER length.
                                             10*#OPTS:
                                             10*#  - cost|N NUM (def: 16384): CPU/memory cost. Must be power of 2
                                             10*#  - blockSize|r NUM (def: 8): block size
                                             10*#  - parallelization|p NUM (def: 1): parallelization
                                             10*#  - maxmem NUM (def: 32MB): memory bound. Must be > 128*N*r

randomBytes(NUM[, FUNC(ERROR, BUFFER)])         #Generates random BUFFER of length NUM
                                                #Is cryptographically secure (e.g. from /dev/random)
                                                #If no FUNC, synchronous (returns BUFFER)
randomFill[Sync](TDBUFFER[, NUM[, NUM2]]        #Like randomBytes() but by filling in a TDBUFFER instead, from offset NUM
[, FUNC(ERROR, TDBUFFER)])[->BUFFER]            #(def: 0) with length NUM2 (def: TDBUFFER.lBUFFER.length).

getFips()->BOOL                              10*#True if Node has been:
                                             10*#   - built to be FIPS-compliant (by def, is not)
                                             10*#   - run with node --enable-fips or (same but cannot modify CRYPTO.fips) --force-fips
setFips(BOOL)                                10*#

timingSafeEqual(TDBUFFER, TDBUFFER2)->BOOL      #Like TDBUFFER.equals(TDBUFFER2), but protected against timing attacks


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ASSERT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ASSERT                                          #Throws ERROR or ASSERTIONERROR with message 'MESSAGE' if fails.
ASSERT.*(..., 'MESSAGE'|ERROR)                  #Can be always passed as last argument (except ifError()). Def:
                                                #  - [not]equal|ok(): 'VAL ==|!= VAL2'
                                                #  - [not]DeepEqual(): 'VAL [not]DeepEqual VAL2'
                                                #  - fail(): 'Failed'
                                                #  - strictEqual(): diff
                                                #  - others: sentence

ASSERTIONERROR.actual|expected                  #VAL
                                                #With *equal|ok|ifError()
                                                #Does a colored diff
                                                #Only actual with *throws|*rejects()
ASSERTIONERROR.operator                         #'==' (equal|ok()) or '!=' (notEqual()), 'fail' (fail()),
                                                #'throw|doesNotThrow|reject|doesNotReject', 'FUNC' (others)

ASSERT.strict.*(...)                          8*#Same as ASSERT.*(...) except:
                                              8*#  - use == instead of ===
                                              8*#  - when arguments are OBJ, prints an OBJ diff instead of showing them in full

ASSERT.fail()                                   #Always fails

ASSERT.[not]equal(VAL, VAL2)                    #VAL == VAL2
ASSERT.[not]strictEqual(VAL, VAL2)              #Object.is(VAL, VAL2)
ASSERT.[not]deepStrictEqual(VAL, VAL2)          #UTIL.isDeepStrictEqual()

ASSERT[.ok](VAL)                                #VAL === true

ASSERT.ifError(VAL)                             #VAL === null

ASSERT.throws|doesNotThrow(FUNC()[, VAL])       #Function throws
                                                #VAL can be:
                                                #  - TYPE|ERROR: instanceof
                                                #  - FUNC(ERROR)->BOOL
                                                #  - REGEXP: against ERROR.message
                                              8*#  - OBJ: deep ==
ASSERT.rejects|doesNotReject                  8*#PROMISE rejection
 (PROMISE[()][, VAL])->PROMISE2               8*#Fails if FUNC()->PROMISE throws before returning the PROMISE
                                              8*#Fails if not using a PROMISE[()]
                                              8*#PROMISE2 is resolved if test passed


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONSOLE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CONSOLE.*                                       #Like DOM utilities except:
                                                #  - uses UTIL.inspect|format()
                                                #     - with OPTS.colors true, unless inside a WORKER
                                                #  - console.dir(VAL, ...) -> console.log(inspect(VAL, ...))
                                                #  - console.assert() can use format strings
                                                #Includes:
                                                #  - console.clear|count[Reset]|debug|group[Collapsed|End]|
                                                #    markTimeline|profile[End]|timeStamp|timeline[End]()
                                              8*#  - console.dirxml()
                                             10*#  - console.table|timeLog()

new Console(OPTS)                               #Returns CONSOLE, same as console but with different stdout|stderr
new Console(OSTREAM[, OSTREAM2][, BOOL])     10*#OPTS:
                                                #  - stdout OSTREAM, stdout OSTREAM2
                                                #  - ignoreErrors BOOL (def: true): ignore errors on OSTREAM[2]
                                             10*#  - colorMode BOOL or 'auto' (def: OSTREAM.isTTY && OSTREAM.hasColors())
                                             11*#  - inspectOptions OPTS: passed to UTIL.inspect()

STDERR ==>                                      #Uses by:
                                                #  - CONSOLE.warn|error() (not other CONSOLE.*)
                                                #  - unhandled exception or promise rejection
                                                #  - process.emitWarning()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          PERF_HOOKS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


performance                                     #Like DOM (see doc), except:
PERFORMANCE                                     #  - different entryTypes:
PERFENTRY.*                                     #     - keep 'mark' and 'measure'
PERFOBSERVER                                    #     - 'timing' PERFORMANCETIMING -> 'nodeTiming' PERFNODETIMING
                                                #     - no 'navigation' PERFORMANCENAVIGATION
                                                #     - also has 'gc' and 'function'
                                                #  - no PERFORMANCE.clearMeasures|getEntries*() (but PERFLIST.getEntries*() are kept)
                                                #  - PERFOBSERVER.observe OPTS.buffered BOOL:
                                                #     - if false (def), fire listener callbacks sync
                                                #     - if true, use setImmediate()
                                                #  - PERFOBSERVER is an ASYNCRESOURCE

PERFORMANCE.timeOrigin                          #DOMGLOBALTIME base of DOMLOCALTIME, i.e. when process started.
                                                #Use same logic as process.hrtime() (i.e. arbitrary number),
                                                #but as a DOMETIMESTAMP

PERFORMANCE.nodeTiming                          #PERFNODETIMING, which is a PERFENTRY with:
                                                #  - entryType 'node'
                                                #  - name 'node'
                                                #  - startTime: same as PERFORMANCE.timeOrigin
                                                #  - duration: same as PERFORMANCE.now() - PERFORMANCE.timeOrigin
                                                #Is similar to PERFORMANCENAVIGATION, but for Node
PERFNODETIMING.*                                #The following use same same logic as process.hrtime(), but in ns
PERFNODETIMING.nodeStart                        #Node process started
PERFNODETIMING.v8Start                          #v8 process initialized
PERFNODETIMING.environment                      #Environment initialized
PERFNODETIMING.bootstrapComplete                #End of all require()
PERFNODETIMING.loopStart                        #Start of event loop
PERFNODETIMING.loopExit                         #End of event loop. Not sure when it is not 0

PERFGCTIMING                                    #PERFENTRY for garbage collector, with:
                                                #  - entryType 'gc'
                                                #  - name 'gc'
                                                #  - startTime
                                                #  - duration DOMTIMESTAMP
                                                #  - kind: constants.NODE_PERFORMANCE_GC_MINOR|MAJOR|INCREMENTAL|WEAKCB (1|2|4|8)

PERFORMANCE.timerify(FUNC)->FUNC                #Make FUNC(...) create a PERFENTRY with:
                                                #  - entryType 'function'
                                                #  - duration: how long FUNC() took
                                                #  - name FUNC.name (without 'timerified ')
                                                #  - startTime DOMLOCALTIME
                                                #Prepend 'timerified ' to FUNC.name
                                                #Does not await return value if it is a PROMISE

monitorEventLoopDelay([OPTS])->HISTOGRAM     11*#Even loop benchmarking, i.e. how long each microtask takes (in ns).
                                             11*#OPTS:
                                             11*#  - resolution NUM (in ms) (def: 10) (min: 1)
HISTOGRAM.enable|disable()->BOOL             11*#Start|stop. Returns false is already started|stopped
HISTOGRAM.reset()                            11*#
HISTOGRAM.min|max
HISTOGRAM.mean|stddev                        11*#Duration NUM (in ns)
HISTOGRAM.percentiles                        11*#Same as a MAP where key is percentile NUM (0-100) and value is duration NUM (in ns)
HISTOGRAM.exceeds                            11*#How many microtasks took more than 1 hour


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             I18N              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ICU DATA                                        #I18n dataset used by:
                                                #  - JavaScript-aware functions: STR.normalize|toLowerCase|toUpperCase(),
                                                #    STR|NUM|DATE.toLocale*(), STR.localeCompare(), Intl, URL,
                                                #    TEXTENCODER|TEXTDECODER
                                                #How many languages are included depends on:
                                                #  - compile-time flag --with-intl=STR:
                                                #     - 'full'
                                                #     - 'small-icu' (def on all OS):
                                                #        - supports: STR.normalize|toLowerCase|toUpperCase(), STR.toLocale*(),
                                                #          STR.localeCompare(), URL, BUFFER.transcode()
                                                #        - not supported: Intl, NUM|DATE.toLocale*(), TEXTENCODER|TEXTDECODER
                                                #     - 'system-icu':
                                                #        - same as 'small-icu', except link to ICU dataset dynamically instead
                                                #          of statically
                                                #        - i.e. depends whether OS includes ICU databaset, which most Linux do
                                                #     - 'none': no i18n, and STR.normalize(), Intl and BUFFER.transcode() fail
                                                #  - ENVVAR NODE_ICU_DATA=FILE
                                                #  - node --icu-data-dir=FILE
                                                #Can use package full-icu to down ICU dataset manually.

process.versions.icu                            #'VERSION'|undefined

ENCODING                                        #Either: ascii, utf8 (def), urf16le|ucs2, base64, hex, binary (actually latin-1)
                                                #For TEXTDECODER|TEXTENCODER, it is different (see DOM doc), and depends on ICU:
                                                #  - always: 'utf-8' (def), 'utf-16le'
                                                #  - if 'small|system-icu': 'utf-16be'
                                                #  - if 'full' ICU: many more (see online doc)

UTIL.TextDecoder|TextEncoder                    #See DOM doc.
TextDecoder|TextEncoder                      11*#


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             UTIL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


inspect(VAL[, OBJ])                             #Print function used by repl. Returns as STR.
                                                #OBJ members are:
                                                #  - showHidden BOOL: if false (def), doesn't show non-enumerable properties,
                                                #    except SYMs
                                                #  - depth NUM (def: 2): max recursion (null|Infinity for infinite)
                                      11.0-11.3*#    Def: 20
                                                #  - maxArrayLength NUM (def: 100) (null for infinite)
                                                #  - breakLength NUM (def: 60) (can be Infinity): maxlength to print OBJ in multiline
                                              9*#  - compact BOOL|NUM:
                                              9*#     - if false:
                                              9*#        - always print OBJ multiline
                                              9*#        - break strings that are more than breakLength long
                                             11*#     - if NUM: allows fitting NUM properties in one line (if within breakLength)
                                            <12*#     - def: true
                                             12*#     - def: 3
                                                #  - colors BOOL (def: false)
                                                #  - customInspect BOOL (def: true):
                                                #     - call VAL[SYM](UINT[, OBJ])->STR if it exists
                                                #     - SYM is util.inspect.custom
                                             10*#       or Symbol.for('nodejs.util.inspect.custom')
                                                #  - showProxy BOOL: if true (def: false), dereference PROXY (to their target)
                                             10*#  - sorted BOOL (def: false) or FUNC('KEY', 'KEY2')->-1|0|1
                                             11*#  - getters BOOL (def: false) or 'get|set' (only getters with|without a set()):
                                             11*#    show getters values
                                                #Can change inspect.defaultOptions
                                                #require("buffer").INSPECT_MAX_BYTES: number of bytes printed for BUFFER
                                                #(def: 50)
                                             11*#Max output 128MB
inspect.colors                                  #OBJ with members defining colors. styles points category (e.g. number) to
inspect.styles                                  #color category, and colors point color category to color codes.

format(STR[, STR2...])                          #Printf-like FUNC, STR can contain:
                                                #  - "%s": STR
                                                #  - "%d", "%i": INT|BIGINT
                                                #  - "%f": FLOAT
                                                #  - "%j": JSON. Prints '[Circular]' on circular references. Handles toJSON()
                                                #  - "%O": OBJ. Uses UTIL.inspect() with default options
                                                #  - "%o": OBJ. Uses UTIL.inspect() with options: showHidden true, depth 4, showProxy true
                                      11.0-11.3*#    depth 20
                                                #  - "%%": escape
formatWithOptions(OBJ, ...)                  10*#Like format(...) except if can specify inspect() options OBJ

debuglog(STR)                                   #Returns FUNC() that works like console.error() except:
                                                #  - appends STR
                                                #  - noop unless envvar NODE_DEBUG "STR2,..." (can include *) includes STR

promisify(FUNC(..., FUNC2(ERROR, VAL)))->FUNC   #Transform FUNC so FUNC(...)->PROMISE(ERROR|VAL)
                                                #If calling FUNC(..., FUNC2), FUNC2 still gets called, and PROMISE do not get
                                                #resolved|rejected
                                                #If FUNC throws, PROMISE gets rejected.
                                                #For this to work:
                                                #  - FUNC2 does not have to be last argument in FUNC declaration
                                                #  - but caller must specify all arguments up to FUNC2
                                                #If FUNC[util.promisify.custom] FUNC3 is defined, returns FUNC3 instead.
                                                #  - this is defined for setTimeout|setImmediate(), i.e. can be used even
                                                #    though callback is first parameter
callbackify(FUNC()->PROMISE)
 ->FUNC(..., FUNC2(ERROR, VAL))                 #Inverse. FUNC will not return PROMISE anymore

isDeepStrictEqual(VAL, VAL2)                  9*#Does a deep Object.is()
                                              9*#Does not compare non-enumerable properties

inherits(TYPE_FUNC, TYPEPARENT_FUNC)            #Makes TYPE inherits from TYPEPARENT, i.e. executes:
                                                #  TYPE.prototype = Object.create(TYPEPARENT.prototype)
                                                #  TYPE.prototype.constructor = TYPE
                                                #Also creates a TYPE.super_ that points to TYPEPARENT
                                                #Since it does not use OBJ in Object.create(), needs to create own static
                                                #members with TYPE.prototype.VAR = VAL


types.isRegExp(VAL)->BOOL                    10*#True if REGEXP
types.isDate(VAL)->BOOL                      10*#True if DATE
types.isPromise(VAL)->BOOL                   10*#True if PROMISE
types.is[Weak]Map|Set(VAL)->BOOL             10*#True if [WEAK]MAP|SET
types.isNativeError(VAL)->BOOL               10*#True if instanceof ERROR
types.isProxy(VAL)->BOOL                     10*#True if PROXY

types.isArgumentsObject(VAL)->BOOL           10*#True if arguments

types.isAsyncFunction(VAL)->BOOL             10*#True if async FUNC

types.isGeneratorFunction(VAL)->BOOL         10*#True if FUNC *
types.isGeneratorObject(VAL)->BOOL           10*#True if return value of FUNC * (not just any ITERABLETOR)
types.isMap|SetIterator(VAL)->BOOL           10*#True if MAP|SET.keys|values|entries|Symbol.iterator()

types.is[Shared|Any]ArrayBuffer|DataView|
 TypedArray|[Big]Int|Uint|Float*Array(VAL)
 ->BOOL                                      10*#True if [SHARED]ARRAYBUFFER|DATAVIEW|TYPED_ARR|UINT|INT|FLOAT*ARRAY

types.isBoolean|Number|StringObject(VAL)
 ->BOOL                                      10*#True if new Boolean|Number|String(VAL) (not Boolean|Number|String(VAL))
types.isSymbolObject(VAL)->BOOL              10*#True if Object(Symbol(VAL)) (not Symbol(VAL))
types.isBoxedPrimitive(VAL)->BOOL            10*#True if new Boolean|Number|String(VAL) or Object(Symbol|BigInt(VAL))

types.isModuleNamespaceObject(VAL)->BOOL     10*#True if OBJ from import * as OBJ
types.isWebAssemblyCompiledModule(VAL)->BOOL 10*#True if compiled WASM
types.isExternal(VAL)->BOOL                  10*#True if external C/C++ value


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            REPORT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--experimental-report                        11*#Must be used

process.report.getReport([ERROR])->'JSON'    11*#Get debugging information.
                                             11*#Def ERROR is new Error()
                                             11*#Returns OBJ:
                                             11*#  - header:
                                             11*#     - trigger:
                                             11*#        - 'GetReport': manual call to getReport()
                                             11*#        - 'OnUncaughtException': --diagnostic-report-uncaught-exception
                                             11*#        - 'OnFatalError': --diagnostic-report-on-fatalerror
                                             11*#        - 'OnUserSignal': --diagnostic-report-on-signal
                                             11*#     - event STR:
                                             11*#        - 'JavaScript API': manual call to getReport()
                                             11*#        - 'exception': --diagnostic-report-uncaught-exception
                                             11*#        - 'ERROR_MESSAGE': --diagnostic-report-on-fatalerror
                                             11*#        - 'SIGNAL': --diagnostic-report-on-signal
                                             11*#     - filename 'FILENAME'|null: where file was dumped
                                             11*#     - dumpEventTime 'DATE'
                                             11*#     - dumpEventTimeStamp DATE_NUM
                                             11*#     - commandLine STR_ARR: process.argv
                                             11*#     - processId NUM
                                             11*#     - nodejsVersion 'vVERSION'
                                             11*#     - glibcVersionRuntime|Compiler 'VERSION'
                                             11*#     - componentVersions: process.versions
                                             11*#     - arch: process.arch
                                             11*#     - platform: process.platform
                                             11*#     - release: process.release
                                             11*#     - host: os.hostname()
                                             11*#     - cpus: os.cpus()
                                             11*#     - cwd process.cwd()
                                             11*#     - osName STR (e.g. 'Linux')
                                             11*#     - osRelease STR (e.g. '4.18.0-16-generic')
                                             11*#     - osVersion 'VERSION' (e.g. '#17-Ubuntu SMP Fri Feb 8 00:06:57 UTC 2019')
                                             11*#     - osMachine STR (e.g. 'x86_64')
                                             11*#     - machine STR: osVersion (not Windows) + hostname
                                             11*#     - wordSize 32|64
                                             11*#  - javascriptStack: message STR, stack STR_ARR
                                             11*#  - nativeStack STR_ARR: same but lower-level
                                             11*#  - javascriptHeap:
                                             11*#     - totalMemory 'NUM'
                                             11*#     - totalCommittedMemory 'NUM'
                                             11*#     - usedMemory 'NUM'
                                             11*#     - availableMemory 'NUM'
                                             11*#     - memoryLimit 'NUM': slightly above availableMemory
                                             11*#     - heapSpaces.read_only|new|old|code|map|[new_]large_object_space:
                                             11*#        - memorySize 'NUM'
                                             11*#        - committedMemory 'NUM'
                                             11*#        - used 'NUM'
                                             11*#        - available 'NUM'
                                             11*#        - capacity 'NUM': used + available
                                             11*#  - libuv OBJ_ARR: pending macrotasks
                                             11*#     - type STR
                                             11*#     - is_active '0|1'
                                             11*#     - is_referenced '0|1'
                                             11*#     - address 'NUM'
                                             11*#     - any type-specific properties
                                             11*#  - environmentVariables OBJ: process.env
                                             11*#  - [uvthreads]resourceUsage:
                                             11*#     - user|kernelCpuSeconds 'NUM'
                                             11*#     - cpuConsumptionPercent 'NUM'
                                             11*#     - fsActivity.reads|writes 'NUM'
                                             11*#     (not uvthreads)
                                             11*#     - maxRss 'INT'
                                             11*#     - pageFaults.IO[Not]Required 'INT'
                                             11*#  - userLimits.TYPE.soft|hard 'NUM|unlimited|'
                                             11*#     - TYPE can be [core_]file_size_blocks|data_seg_size_kbytes|max_locked_memory_bytes|
                                             11*#       max_memory_size_kbytes|open_files|stack_size_bytes|cpu_time_seconds|
                                             11*#       max_user_processes|virtual_memory_kbytes
                                             11*#  - sharedObjects 'PATH'_ARR: shared libraries
process.report.writeReport                   11*#Call process.report.getReport() and dump the file
 (['FILENAME'][, ERROR])->'FILENAME'         11*#Print FILENAME on stderr

--diagnostic-report-*                        12*#Former name of --report-*

process.report.directory
--report-directory DIR                       11*#Def: '', i.e. process.cwd()
process.report.filename                      11*#'FILENAME|stdout|stderr'
--report-filename STR                        11*#Def: '', i.e. 'report.YYYYMMDD.HHMMSS.PID.COUNTER.json'

process.report.reportOnUncaughtException
--report-uncaught-exception                  11*#BOOL (def: false). Call writeReport() on uncaught exception
process.report.reportOnFatalError
--report-on-fatalerror                       11*#BOOL (def: false). Call writeReport() on process crashing (e.g. out of memory)
process.report.reportOnSignal
--report-on-signal                           11*#BOOL (def: false). Call writeReport() on signal.
process.report.signal
--report-signal SIGNAL                       11*#'SIGNAL' (def: 'SIGUSR2') used with process.report.reportOnSignal



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           PROFILING           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FRAME                                        12*#OBJ:
                                             12*#  - url 'STR': FILE URL
                                             12*#  - scriptId 'NUM': FILE ID
                                             12*#  - functionName 'FUNC.name'
                                             12*#  - lineNumber|columnNumber NUM

--cpu-prof                                   12*#Writes a CPU profiling dump on exit.
                                             12*#Can be loaded in Chrome DevTools `Performance` tab.
                                             12*#Use a sampling approach:
                                             12*#  - keep track of all stack frames
                                             12*#  - run periodic samples, checking which stack frames are executing
                                             12*#File is JSON:
                                             12*#  - nodes NODE_ARR (stack frames):
                                             12*#     - id 'NODE_ID'
                                             12*#     - children 'NODE_ID'_ARR
                                             12*#     - callFrame FRAME
                                             12*#     - hitCount NUM: number of samples where this stack frame was on top
                                             12*#     - positionTicks OBJ_ARR (optional):
                                             12*#        - line NUM: line number
                                             12*#        - ticks NUM: number of samples on that line
                                             12*#  - startTime|endTime NUM (in ns): since machine startup
                                             12*#  - samples 'NODE_ID'_ARR: top stack frame for each sample
                                             12*#  - timeDeltas NUM_ARR (in ns):
                                             12*#     - time between each sample
                                             12*#     - should be approximately same as --cpu-prof-interval
--cpu-prof-dir 'DIR'                         12*#Def: PWD
--cpu-prof-name STR                          12*#Def: 'CPU.YYYYMMDD.HHMMSS.PID.TID.COUNTER.cpuprofile'
--cpu-prof-interval NUM                       12*#NUM (in microsecs). Def: 1000

--heap-prof                                  12*#Writes a heap profiling dump on exit.
                                             12*#Can be loaded in Chrome DevTools `Memory` tab.
                                             12*#File is JSON:
                                             12*#  - head NODE:
                                             12*#     - id 'NODE_ID'
                                             12*#     - children NODE_ARR
                                             12*#     - callFrame FRAME
                                             12*#     - selfSize NUM (in bytes)
                                             12*#  - samples OBJ_ARR:
                                             12*#     - nodeId 'NODE_ID'
                                             12*#     - ordinal NUM (index)
                                             12*#     - size NUM (in bytes)
                                             12*#FRAME: functionName STR, scriptId STR
--heap-prof-dir 'DIR'                        12*#Def: PWD
--heap-prof-name STR                         12*#Def: 'Heap.YYYYMMDD.HHMMSS.PID.TID.COUNTER.heapprofile'
--heap-prof-interval NUM                     12*#NUM (in bytes). Def: 512KB


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              V8               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


getHeapStatistics()->OBJ                        #OBJ:
                                                #  - total|used_heap_size[_executable] NUM
                                                #  - total_physical|available_size NUM
                                                #  - heap_size_limit NUM
                                                #  - [peak_]malloced_memory NUM
                                                #  - does_zap_garbage BOOL
                                             12*#  - number_of_native|detached_contexts NUM
getHeapSpaceStatistics()->OBJ                   #OBJ:
                                                #  - space_name STR
                                                #  - space_[used|available_]size NUM
                                                #  - physical_space_size NUM
setFlagsFromString('--OPT ...')                 #Additional v8 CLI options

serialize(VAL)->BUFFER
deserialize(BUFFER)->VAL                        #Serialize|deserialize according to structured clone algorithm (see JavaScript doc)

NODE_V8_COVERAGE=DIR                         10*#See v8 coverage doc

getHeapSnapshot()->ISTREAM                   11*#Create a V8 heap snapshot. This serializes the current process|worker state.
                                             11*#Parent|child workers are not included.
                                             11*#This can be used to:
                                             11*#  - restart the process later, or speed up startup time (not implemented yet)
                                             11*#  - inspect memory/heap in Chrome devTools
writeHeapSnapshot(['FILENAME'])->'FILENAME'  11*#Write getHeapSnapshot() to a file in process.cwd()
                                             11*#'FILENAME' defaults to 'Heap-${yyyymmdd}-${hhmmss}-${pid}-${threadId}.heapsnapshot'
--heapsnaphot-signal=SIGNAL                  12*#Do writeHeapSnapshot() on SIGNAL
