
                  
   PATH-TO-REGEXP  
                  



VERSION ==>                       #6.1.0


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONCEPT            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


'PATH'                            #URI path without template variables

PATH_PATTERN                      #URI path with template variables.
                                  #Can contain:
                                  #  - :VAR, with [:alnum:]_
                                  #  - (REGEXP)
                                  #  - quantifier * ? + after either
                                  #     - * + do not stop at delimiters
                                  #Path tokens are either :VAR or (REGEXP)
                                  #E.g. '/my/path/:var/:varb+/(.*)/try(this)?'
                                  #OPTS:
                                  #  - sensitive BOOL (def: false): case-sensitive
                                  #  - strict BOOL: if false (def), optional trailing slash
                                  #  - start BOOL (def: true): must match from beginning
                                  #  - end BOOL (def: true): must match until end
                                  #  - delimiter STR (def: '/'): path delimiter
                                  #  - whitelist STR[_ARR] (def: any): same but several
                                  #  - endsWith STR[_ARR] (def: none): stops parsing when encountering that character
                                  #    E.g. '?' for query strings
                                  #  - encode(STR)->STR (def: none):
                                  #     - stringify VAR values
                                  #     - should use encodeURIComponent()

PATH_REGEXP                       #REGEXP where each parenthesis group matches a path token
TTOKEN                            #Path groups, either TOKEN or 'STR' (anything between TOKEN)
TOKEN                             #
TOKEN.pattern                     #REGEXP
TOKEN.name                        #'VAR' (if :VAR) or NUM (parenthesis group)
TOKEN.optional                    #BOOL. If * or ?
TOKEN.repeat                      #BOOL. If * or +
TOKEN.delimiter                   #According to OPTS.delimiter|whitelist

PARAMS                            #Template variables as OBJ


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PARSING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


pathToRegexp(PATH_PATTERN[_ARR]   #PATH_PATTERN -> PATH_REGEXP
 [, OBJ_ARR][, OPTS])             #If OBJ_ARR specified, push PATH_REGEXP.keys to OBJ_ARR
 ->PATH_REGEXP                    #If PATH_PATTERN_ARR: alternatives
parse(PATH_PATTERN)->TTOKEN_ARR   #
tokensToRegExp
 (TTOKEN_ARR[, OBJ_ARR][, OPTS])
 ->PATH_REGEXP                    #Same but in two stages: PATH_PATTERN -> TTOKEN_ARR -> PATH_REGEXP

match(PATH_PATTERN[, OPTS])       #PATH_PATTERN + 'PATH' -> PARAMS
 ->FUNC('PATH'[, OPTS])           #OBJ:
 ->OBJ|false                      #  - path PATH_PATTERN
                                  #  - params PARAMS
                                  #  - index NUM
                                  #OPTS:
                                  #  - decode(STR, 'VAR')->STR (def: nothing)
                                  #     - should use decodeURIComponent()
regexpToFunction
 (PATH_REGEXP[, TTOKEN_ARR])
 ->FUNC('PATH'[, OPTS])
 ->OBJ|false                      #PATH_REGEXP + 'PATH' -> PARAMS


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          SERIALIZING          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


compile(PATH_PATTERN)             #PATH_PATTERN + PARAMS -> 'PATH'
 ->FUNC(PARAMS[, OPTS])           #Replaces:
 ->'PATH'                         #  - :VAR by PARAMS.VAR
                                  #  - (...) by PARAMS[NUM]
                                  #Can use VAL_ARR:
                                  #  - if quantifier + or *
                                  #  - is replaced by VAL_ARR.join(delimiter)
                                  #TOPTS:
                                  #  - sensitive BOOL (def: false): case-sensitive
                                  #  - validate BOOL (def: true): throw TypeError if does not match
                                  #OPTS:
                                  #  - encode(STR, TOKEN)->STR (def: encodeURIComponent())
tokensToFunction
 (TTOKEN_ARR[, TOPTS])
 ->FUNC(PARAMS[, OPTS])
 ->'PATH'                         #TTOKEN_ARR + PARAMS -> 'PATH'
