
                       
   NODE_TAP_ASSERTIONS  
                       



ALTERNATIVES ==>                  #See chai doc

VERSION ==>                       #Part of node-tap (see its doc)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            COMMON             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXCEPTIONS ==>                    #Assertions only report: they do not throw (i.e. control flow continues)
                                  #This helps reporting several failed assertions per test
                                  #However this means following assertions might crash: they will be handled but might clutter
                                  #test output (where only first failed assertion might be relevant)

TEST.*()->BOOL                    #All assertions return BOOL (or PROMISE for TEST.resolve*|rejects())
TEST.passing()->BOOL              #False if a previous assertion has failed

TEST.*                            #Can be passed for all assertion functions as last arguments.
 (...[, 'ASSERT_TITLE'][, AOPTS]) #Def 'ASSERT_TITLE':
                                  #  - TEST.pass|fail|skip(): '(unnamed test)'
                                  #  - TEST.threw|error(): ERROR.message
                                  #  - TEST.throws|doesNotThrow|rejects|resolve*(): FUNC.name
                                  #  - custom assertion: none
                                  #  - others: 'should|expect ...'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GENERIC            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TEST.pass()                       #
TEST.fail()                       #

TEST.threw(ERROR)                 #Like TEST.fail() but using information from ERROR:
                                  #  - 'ASSERT_TITLE': ERROR.message
                                  #  - stack|at|source: ERROR.stack
                                  #  - any ERROR.*: as is (stringified with UTIL.inspect())

TEST.equal(VAL, VAL2)             #===
                                  #Aliases: TEST.equals|isEqual|is|strictEqual[s]|strictIs|isStrict[ly]()
TEST.notEqual(VAL, VAL2)          #!==
                                  #Aliases: TEST.notEquals|isNotEqual|doesNotEqual|[is]inequal|isNot|notStrictEqual[s]()
TEST.strictSame(VAL, VAL2)        #Deep ===
                                  #Aliases: TEST.strictDeepEqual[s]|strictEquivalent|sameStrict|deepIs|isDeep[ly]()
TEST.strictNotSame(VAL, VAL2)     #Deep !==
                                  #Aliases: TEST.strictInequivalent|strictDeepInequal[s]|notSameStrict|deepNot|notDeeply|notStrictSame()
TEST.same(VAL, VAL2)              #Deep ==
                                  #Aliases: TEST.deepEqual[s]|looseEqual[s]|equivalent|isLoose|looseIs()
TEST.notSame(VAL, VAL2)           #Deep !=
                                  #Aliases: TEST.notLoose|looseNot|notDeep|inequivalent|looseInequal|deepInequal()

TEST.error(ERROR)                 #instanceof Error
                                  #Aliases: TEST.ifErr[or]()

TEST.match(VAL, VAL2)             #Deep ==
                                  #Aliases: TEST.has[Fields]|matches|similar|[is]like|include[s]|contains()
TEST.match(OBJ, OBJ2)             #Deep TEST.match()
TEST.notMatch(VAL, VAL2)          #Inverse of TEST.match()
                                  #Aliases: TEST.[is]dissimilar|unsimilar|[is]notSimilar|[is]unlike|[is]notLike|doesNotHave()

TEST.match(VAL, TYPE)             #instanceof TYPE (can use String|Boolean|... for simple types)
TEST.type                         #typeof VAL === 'TYPEOF' || instanceof TYPE|'TYPE'
 (VAL, 'TYPEOF'|'TYPE'|TYPE)      #Aliases: TEST.isA()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BOOLEAN            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TEST.ok(VAL)                      #== true
                                  #Aliases: TEST.true|assert()
TEST.notOk(VAL)                   #== false
                                  #Aliases: TEST.false|assertNot()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STRING             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TEST.match(STR, REGEXP)           #REGEXP.test()
TEST.match(STR, STR2)             #STR.includes(STR2)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           FUNCTION            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TEST.throws(FUNC[, VAL])          #FUNC() throws, and TEST.match(ERROR, VAL)
                                  #Aliases: TEST.throw()
TEST.doesNotThrow(FUNC[, VAL])    #Inverse
                                  #Aliases: TEST.notThrow()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PROMISE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TEST.rejects(PROMISE[()][, VAL])  #PROMISE rejected with VAL2, and TEST.match(VAL2, VAL)
TEST.resolveMatch
 (PROMISE[()][, VAL])             #PROMISE resolved with VAL2, and TEST.match(VAL2, VAL)
TEST.resolves(PROMISE[()])        #PROMISE resolved
TEST.rejects|resolve*()           #Actually create a sub-TEST, i.e. behave like TEST.test()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            EVENTS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TEST.emits
 (EVENTEMITTER, 'EVENT'[, VAL])   #Calls EVENTEMITTER.emit('EVENT'[, VAL]) before end of test


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          EXTENSIONS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Test.prototype.addAssert
 ('FUNC', NUM,
 FUNC(ARGS..., 'ASSERT_TITLE',OBJ)#Custom assertion
 ->BOOL)                          #NUM is ARGS length
