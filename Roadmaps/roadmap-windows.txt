
                   
   ROADMAP-WINDOWS  
                   



spawn(FILE, STR_ARR, OPTS):
  - OPTS:
     - cwd
     - env
     - shell 'PATH':
        - Unix:
           - def: '/bin/sh'
           - always: prepends ['-c'] to STR_ARR
        - Windows:
           - def: ENVVAR ComSpec or 'cmd.exe'
           - if 'cmd.exe': prepends ['/d', '/s', '/c'] to STR_ARR and add windowsVerbatimArguments true
           - if not 'cmd.exe', prepends ['-c'] to STR_ARR
     - gid|uid
     - windowsHide BOOL (def: false)
     - windowsVerbatimArguments BOOL (def: false): escape STR_ARR (Windows only)
  - OPTS not passed by exec*():
     - detached BOOL (def: false)
     - stdio (def: 'pipe')
        - can be 'ignore|pipe|inherit' instead of ['ignore|pipe|inherit',...] 3 times
     - argv0 STR: prepended to process.argv instead of 'FILE'

spawnSync(): also has OPTS: killSignal, encoding, timeout, maxBuffer

execFile('FILE'[, STR_ARR][, OPTS], FUNC):
  - does spawn(...)
  - can use FUNC instead of return CHILD
  - only OPTS passed to spawn():
     - cwd: def null
     - env: def null
     - shell: def false
     - gid|uid
     - windowsHide
     - windowsVerbatimArguments
  - OPTS not passed to spawn():
     - killSignal 'SIGNAL'|SIGNUM: def 'SIGTERM': on timeout or maxBuffer, calls CHILD.kill(SIGNAL)
     - encoding: def 'utf-8'
     - timeout NUM: def 0
     - maxBuffer: def 200KB: max size for stdout|stderr

exec(...):
  - like execFile(...) except:
     - OPTS.shell defaults to true
     - no STR_ARR

fork(STR[, OPTS]):
  - like spawn('node', [STR], OPTS)
  - other different OPTS:
     - execPath 'PATH': instead of 'node'
     - shell: always false
     - stdio: def 'inherit'
     - silent BOOL (def: false): same as 'pipe'

Verify:
  all: cwd, env, encoding, uid, gid
  not exec: windowsVerbatimArguments
  not fork: shell, windowsHide
  only exec, execFile: timeout, maxBuffer, killSignal
  not exec, execFile: detached, stdio
  only spawn: argv0
  only fork: execPath, execArgv, silent

Find Windows word in single page Node.js online doc

Lists:
  - https://github.com/bcoe/awesome-cross-platform-nodejs/blob/master/readme.md#libraries
  - https://github.com/Microsoft/nodejs-guidelines/blob/master/README.md

Path:
  - summary:
     - usually use Unix path
     - except when dealing with input|output outside Node (in shell): use PATH.* then
  - differences:
     - delimiter is \ not /
     - root dir is like 'c:'
  - input in Node:
     - Unix path allowed on all OS, but Windows path also allowed in Windows (including mixed)
     - e.g. require(), PATH.*, FS.*, process.chdir()
  - output in Node:
     - OS-specific
        - but it's ok since input in Node in Windows allows mixing Unix/Windows
     - e.g. PATH.*, __dirname, process.argv|execPath|cwd(), OS.userInfo().homedir
     - exceptions:
        - PATH.posix|win32.*
        - output based on input, e.g. createReadStream().path, fs.mkdtemp()
  - input|output outside Node (in shell): OS-specific

UID/GID:
  - process.get|set[e]uid|gid() are not defined
  - os.userInfo().uid|gid is -1

ENVVARs:
  - PATH delimiter is ; not :
  - names and how to use them in shell

Commands spawning:
  - different
  - `spawn()` `opts.detached`:
     - on Windows, child process cannot outlive parent without `opts.detached: true`
     - on Windows, `opts.detached: true` opens a new window unless `opts.windowHide: true`
  - `exec()` `opts.shell`:
     - default `/bin/sh` on Unix, `process.env.ComSpec` (`cmd.exe`) on Windows
  - executable files `.bat|.cmd` must be run with `cmd.exe` binary
  - `spawn|exec|fork()` escape arguments unless `opts.windowsVerbatimArguments: true`

Native extensions

Shabang:
  - does not work on Windows
     - must use node FILE

Shell:
  - Windows has no ; but it has &&
  - OS.userInfo().shell is null

Errors:
  - most error types are OS-agnostic and start with `E*`
     - Windows has some specific ones starting with `W*`
  - different NERROR.errno (should use OS.constants.errno to translate)

Signals:
  - available:
     - OS-agnostic:
        - 0 (test process existence)
        - SIGINT (CTRL-C)
        - SIGTERM, SIGKILL
     - OS-agnostic but cannot be process.kill() on Windows:
        - SIGBREAK (CTRL-BREAK on Windows, similar to CTRL-C)
        - SIGHUP (closing cmd.exe window)
        - SIGWINCH, SIGILL, SIGABRT, SIGFPE, SIGSEGV
     - only on Linux: SIGPOLL, SIGPWR, SIGUNUSED
     - only on Mac: SIGINFO
     - missing on Windows:
        - SIGSTOP|SIGTSTP|SIGCONT|SIGCHLD (background, CTRL-Z)
        - SIGQUIT (coredump, CTRL-\),
        - SIGUSR1 (start debugger), SIGTRAP (debugger)
        - SIGIOT, SIGBUS, SIGUSR2, SIGPIPE, SIGALRM, SIGSTKFLT, SIGTTIN, SIGTTOU,
          SIGURG, SIGXCPU, SIGXFSZ, SIGVTALARM, SIGPROF, SIGIO, SIGSYS
  - signals integers are different (should use OS.constants.signals to translate)
  - Windows does not allow terminating a process group

Newline:
  - OS-independent: '\n' is LF, '\r' is CR
  - OS-dependent (CR+LF on Windows, LF others): terminal|file I/O
  - OS.EOL

Directory locations:
  - os.tmpdir(): `/tmp` on Unix, `C:\Users\USER\AppData\Local\Temp` on Windows
  - os.homedir(): `/home/USER` on Unix, `C:\Users\USER` on Windows

Identification:
  - process.platform: main way to test
  - os.platform|type|release(): more precise

Load:
  - os.loadavg() returns [0, 0, 0] on Windows

IPC:
  - process.*

Windows shell font has poor support for unicode chars
  - see npm package figures

nvm:
  - must use nvm-windows on Windows
