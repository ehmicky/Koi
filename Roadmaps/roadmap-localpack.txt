
                     
   ROADMAP-LOCALPACK  
                     



Load source map (inline or external)
require('source-map').SourceMapConsumer(sourceMapObj)->SM
  - SM.sources -> VAL_ARR
  - SM.sourceContentFor(VAL)


Test-coverage issues:
  - what nyc does:
     - instrumentation does not care about source maps
     - just before writing .nyc_output/*.json, use source maps (istanbul-lib-source-maps) to:
        - convert file names
           - i.e. node_modules/unix-permissions/dist/* -> node_modules/unix-permissions/src/*
        - convert positions
     - nyc reporters and other consumers (like codecov) use file path to get content, instead of source map's `sourcesContent`
  - need to choose between:
     - replacing all paths in .nyc_output/*.json to remove `node_modules/PACKAGE/`
        - find best way to do so??? nyc --require??? localpack command???
        - delimiter will be backslash on Windows, slash on Unix
     - adding|modifying source maps in node_modules/PACKAGE/** to indicate source is too levels up
        - `sourceRoot: '../..'` might work
  - need to choose:
     - between recommending:
        - nyc --cwd node_modules/PACKAGE --temp-dir ../../.nyc_output --report-dir ../../coverage
           - this one has more risks of typo -> overwriting package root
        - nyc --include node_modules/PACKAGE --exclude '!node_modules/PACKAGE'
     - check if same output
     - check source code of nyc
     - check is some allows doing integration + unit testing (i.e. testing source files as well if user chooses to)
     - use --no-cache???
  - make sure source maps still work for debugging



New solution:
  npm pack --silent --no-update-notifier
    - use stdout
    - inherit stderr
    - do in tmpDir
  npm install --loglevel=error --force --no-audit --no-save --no-package-lock TARBALL
    - ignore stdout
    - inherit stderr
    - if exit code not 0, fail
  clean tmpDir

Changes:
  - opts.cwd -> opts.source
  - no opts.output
  - no verbosity/console output
  - no need for .gitignore
  - no more devChecks

Document:
  Ensure "npm/yarn publish" does not break your package

  Even if your package works locally, it might still be broken once published to npm if you misconfigured:
    - the entry point (`package.json`'s `main` and `browser` fields)
    - the binary filename (`package.json`'s `bin` and `directories.bin` fields)
    - which files to exclude (`.npmignore` or `package.json`'s `files` field)

  `localpack` prevents this by installing your package as a dependency of itself.
  Your tests can then simply require it:

  ```
  const yourPackage = require('your-package')
  ```

  Binary files can also be tested:

  ```
  const execa = require('execa')
  const binaryPath = require.resolve('.bin/your-package-binary')
  const { stdout, stderr, code } = await execa.shell(`${binaryPath} args`)
  ```

  ## Alternatives

  To achieve a similar result one might consider instead:
    - requiring the package root, e.g. `require('../../..')`
    - using `npm link`
    - symlinking `node_modules/your-package` to the package root

  However none of these allow you to test whether you misconfigured `.npmignore` or the `package.json`'s `files` field.

  `localpack` runs the same steps as publishing to npm would, ensuring the package you are testing is identical to how it
  will be installed by your users.

  ## Usage (CLI)

  ```
  $ localpack
  ```

  Must be done after `npm install`/`yarn` and before tests running.
  Exit code will be `0` on success.

  ## Usage (Node.js)

  ```
  const localpack = require('localpack')
  await localpack(options)
  ```

  `options` is optional and is identical to the CLI flags.
  The returned promise will be rejected on failure.

  ## ESLint

  To prevent requiring `devDependencies` in code published to npm, please use the `import/no-extraneous-dependencies` ESLint rule.

  ```
  rules:
    import/no-extraneous-dependencies:
      - 2
      - devDependencies: [test/**]
  ```

  If you're using `eslint-plugin-import`, you can avoid linting errors by specifying in `.eslintrc.yml`:

  ```
  settings:
    import/core-modules: [your-package]
  ```

  Same goes with `eslint-plugin-node`:

  ```
  rules:
    node/no-extraneous-require:
      - 2
      - allowModules: [your-package]
  ```

npm vs yarn vs pnpm:
  - need to create commands for each
  - need to fire global binary, so that it matches what user would type to publish

localpack should not use/require itself (instead of inside gulp folder) because it creates hard to debug bugs (add comment). instead of requiring "localpack" it should require packageRoot

Check moization of promises with `moize`
  - make sure all current projects use it correctly

Replace by t.snapshot() for all tests
  - make sure tests work on Windows and Mac

Add travis, etc.

Add documentation

Use in other projects:
  - fix gulp FILES.json for get-versions and validate-path

Add logo
  - use stencil font

Promote

Use validate-path on opts.source
