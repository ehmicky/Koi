
                    
   ROADMAP DIFFTEST  
                    



Catchphrase: "Snapshot-driven testing" and/or "Forget test assertions"
  - do not set it until promotion, to avoid idea stealing

Logo:
  - "difftest" and include green + and red - inside letters
  - nice sans-serif non-monospace font

test("TITLE", [...ARR], FUNC(t, ...ARG) [, ...OPTS])->PROMISE
  - named export `test` (not default export)

"TITLE":
  - not optional
  - must be unique within file
  - test iterations are identified with a combination of:
     - "shortest filepath"
     - TITLE + ARGs (using info.title from test-each)

"shortest filepath":
   - if unique: filename without .EXT
   - if differ only by .EXT: filename with .EXT
   - otherwise, prepend first parent dir (and so on) until different (and do not use .EXT)

...ARR + FUNC:
  - use test-each

FUNC:
  - should be fired on next tick

t OBJ:
  - index, indexes: like test-each
  - name STR
  - title STR: name + stringified data used for reporting
  - log(VAL,...)
  - snapshot(VAL[, STR])

Returned PROMISE:
  - resolved value:
      - OBJ:
         - title STR, args: ARR_ARR, options OPTS
         - tests OBJ_ARR: args ARR, error ERROR
         - others???
      - meant for plugins.
  - always resolved, even on test failure

Re-using:
   - TITLE (like describe()): test = (title, ...args) => test(`TITLE > ${title}`, ...args)
   - ...ARR: test = (title, ...args) => test(title, ...ARR, ...args)
   - OPTS: test = (...args) => test(...args, OPTS)
       - which is why OPTS is variadic

Hooks not needed:
   - beforeAll():
      - just execute code in top-level scope
      - for async, top-level code can return PROMISE then each test can use await PROMISE
   - afterAll(): use await Promise.all(...PROMISE) using returned PROMISEs
   - before|afterEach(): just repeat code at beginning|end of FUNC

CLI runner:
  - called "dt" to make it fast to type

Files selection:
  - use CLI argument "GLOB"... (whitelisting)
     - can be "!GLOB" (blacklisting)
     - can target DIRs
  - def: test[s]|spec|__tests__/**/*.EXT, **/*.[sS]pec|test.EXT, **/[*-]test[-*].EXT, !helpers|fixtures, !_*
     - EXT is .js[x]|ts[x]
  - always exclude:
     - snapshot files
     - node_modules, bower_components, jspm_packages

Tests selection:
  - CONF.skip REGEXP_ARR (-s|--skip):
     - partial matching
     - on the CLI, is 'REGEXP' case-insensitive
     - matched against test titles
     - def: /[skip]/i
     - do not run
     - do not report, except in summary
     - --tap should use SKIP directive
  - CONF.only REGEXP_ARR (-o|--only):
     - like adding CONF.skip true to all other tests
     - def: /[only]/i
     - priority over CONF.skip
     - file-wise, i.e. user might need to use files selection too

Test declaration:
  - test() must be called synchronously during file load
  - once all tests of a worker have finished, do not terminate it
     - let worker end on its own (i.e. no more macrotasks) or on global timeout
     - reason: allow afterAll() hooks
  - if a worker does not define any tests during the initial synchronous load, make whole tests run fail
     - reason: avoiding spawning lots of useless workers because of misconfiguration
  - if a test is declared twice:
     - by same worker, error
     - by different workers, do not error, but only run test once

Use worker threads / workers for each test file

Any Node flags should be allowed as CLI flags:
  - it should be passed as `execArgv` to workers
  - should whitelist them, so that wrong CLI flags still trigger a validation error
     - do not include flags that do not make sense like --interactive
  - including --require
     - make sure it works with "ts-node/register"
     - document it
  - including --inspect[-brk]:
     - make sure it works
     - document it
  - --experimental-repl-await should always be passed

CONF.timeout NUM (in secs):
  - def: 10 minutes
  - global timeout, because per-test timeout does not work with parallel tests
  - when hit, report which tests are still running

User interrupt:
  - on SIGINT|SIGTERM|SIGQUIT|etc.
  - if no tests finished in last 5 secs
  - then report which tests are still running
  - goal: allow debugging hanging code

CONF.bail BOOL (-b|--bail)
  - stops on first failure
     - still run|report other data of same test
  - "stops":
     - terminate workers
     - do not run|report any additional tests

Assertion testing:
  - any assertion library works:
     - just need to throw error
     - core 'assert', power-assert, chai, should.js
  - failure reporting:
     - ERROR.name + ERROR.message
        - no name if ERROR.printName false
     - stack trace (in order):
        - unless ERROR.printStack false
        - remove node_modules/** and Node internals
        - apply source maps
        - strip common root from path
        - need to work with different browsers
        - see if libraries exist that do this (probably stacktrace.js)
     - preview the source code context:
        - like ava does
        - unless ERROR.printContext false
        - after source maps applied
        - only of the deepest stack call
        - do not do it if lines are very long, which probably indicates a concatenated build

Process errors:
  - use log-process-errors
     - does not make process exit
  - reported as failed tests:
     - at end of test run
     - filepath ""
     - title: first line of ERROR.message "uncaughtException|unhandledRejection|..." + explanation
     - use log-process-errors ERROR (except first line) as if it had been thrown
  - CONF.processErrors STR_ARR
     - which types creates failures (others are ignored)
     - def: ["uncaughtException", "unhandledRejection"]
        - default is conservative to avoid annoying users

t.snapshot(VAL[, STR])
  - comparison result:
     - "same": success
     - "different|new": depends on CONF.update
  - on failure, throws ERROR with ERROR.message containing:
     - snapshot name (if defined)
     - description message, e.g. "New snapshot:", "Snapshot changed:", etc.
     - snapshot content
  - on success, returns true
     - reason: allowing shortcut notation assert.throws(FUNC, t.snapshot)
  - VAL is not awaited even if PROMISE: user must explicity use t.snapshot(await VAL)
  - no way to catch FUNC exceptions: user must explictly use assert.throws(FUNC, t.snapshot)
  - STR is snapshot name
     - required if two snapshots in same test
        - so we know which one to diff

Snapshot key:
  - use "shortest filepath" + test title + data + STR (snapshot name)
     - for input functions: use `${FUNC.name}()` (or "function()" if anonymous) instead of generated value
  - can use same key several times:
     - used when NUM as data dimension, since test title repeats
     - with CONF.update true, only first one is persisted
     - if two t.snapshot() with same key differ, it should just work:
        - with CONF.update true, different snapshots will be ignored
        - with CONF.update false, one of the snapshots will fail, stopping test iteration

CI:
  - if CI, cannot use CONF.update|remove|input true

CONF.update BOOL (-u|--update):
  - what t.snapshot() should do on "new|different" snapshots
  - if false (def):
     - do not add|prune|modify inside snapshot files
     - throw ERROR
  - if true:
     - add|prune|modify inside snapshot files
     - do not throw ERROR

CONF.remove BOOL (-r|--remove):
  - make t.snapshot():
     - remove snapshot in snapshot file
     - not throw ERROR
  - not compatible with CONF.update|input true

Pruning snapshots:
  - for removed files|tests|t.snapshot()
  - never run, i.e. not reported
  - removed in snapshot files (with no reporting) during CONF.update true
  - only prune files selected by file selection:
     - including removing snapshot files of test files that have been removed but match the file selection

Snapshots in renamed files|tests:
  - no special treatment, they are just removed + new snapshots

CONF.input BOOL (-i|--input):
  - goal: test-first development for snapshots
  - not compatible with CONF.update|remove true
  - make t.snapshot():
     - if there already is a snapshot, print it
     - prompt for snapshot:
        - if submit something:
           - updates snapshot in snapshot file with it
        - if submit without entering anything:
           - keep current snapshot (including none)
           - must distinguish from explicitely entering undefined
     - not throw any ERROR
  - prompt:
     - use Node REPL ("readline" or "repl" core module)
     - can multiple statements (use the last one)
     - can use history (arrow up) to re-use previous inputs
     - retry if invalid input
     - not erased after submit

Color highlighting in snapshots:
  - use a syntax highlighting library
     - so that YAML/HTML/etc. snapshots are highlighted too
     - should work well with prettyFormat()
  - first column:
     - "new" snapshots: green pluses for all lines
     - "different" snapshots: red minuses or green minuses for relevant lines

"different" snapshot reporting:
  - report snapshot diff
     - no syntax highlighting on the added|removed lines
     - instead backgroundGreen|Red and auto (or darker green|red) in foreground
  - only report different lines, with 2 lines of context
     - use ellipsis in-between parts

Normalization:
   - to normalize snapshots, user needs to transform the value passed to t.snapshot()
   - create a separate package with some common normalization methods:
      - separate some of those methods to own package if makes sense, including deep(), compose(), error(), duration()
      - deep(FUNC(VAL)->VAL)->FUNC(OBJ)->OBJ:
         - make a mapping FUNC recursive
         - avoid infinite recursions
         - only enumerated own properties
         - applied to all methods in the package
      - compose(FUNC,...)->FUNC: functional compose
      - trim(STR)->STR
      - error(STR)->STR: replace stack traces (lines starting with \s+at ...) by single "at STACK TRACE"
         - should work on ERROR since error() is deep and should be applied to error.stack
         - should work on CLI error output (i.e. there is no available ERROR instance)
         - should work for any browser
      - colors(STR)->STR: remove colors
      - duration(STR[, STR2])->STR: replace anything that looks like durations by STR2 (def: "100ms")
      - timestamp(STR[, STR2])->STR: replace anything that looks like timestamps by STR2 (with a default of epoch)
      - newline(STR)->STR: CRLF or LF
      - removePath(STR)->STR: remove anything that looks like a path (including Windows PATH)
      - normalizePath(STR)->STR: normalize Windows paths to Unix paths
      - replace(REGEXP, STR)

Reporting:
  - should take as input UI information: titles, filepaths, data, error, etc.
  - should not need to handle most logic including: color highlighting, truncating
  - counter (like test-openapi): for all reporters except tap
  - end summary: for all reporters

CONF.reporters STR_ARR (-R|--reporter):
  - types:
     - pretty (default)
     - tap
     - json
     - notify
  - only "notify" can be used with others

Reporting ordering:
  - the following applies to all reporters
  - run in parallel but buffer and report in order (like test-openapi)
     - should stream it
  - order should be (by priority):
     - process errors at end
     - lexicographical ordering of "shortest filepath" (see below)
     - when test() was called
     - argument order in parameters

CONF.level STR:
  - among 'silent', 'error', 'warn', 'info'
  - do not report passed tests:
     - for 'error|warn' but not 'info'
  - do not report content (but still report header) of tests, except first failed one of each test
     - for 'error' but not 'warn|info'
  - 'silent': do not report anything
  - for any reporters
  - default value:
     - pretty|tap|notify: 'error'
     - json: 'info'

CONF.color BOOL (--[no-]color):
  - def: chalk default

CONF.compact BOOL (--[no-]compact)
  - def: true
  - goals:
     - make each test fit a single screen
     - avoiding slowing down machine when test content is big
  - truncate ERROR.message to max lines NUM:
     - truncate in middle
     - newline should be either CRLF or LF
     - NUM is terminal height
        - minus test headers height
        - if cannot guess, use a typical terminal height
     - each series of 80 chars without any newlines should be considered a line:
        - increments the number of "lines"
        - might be truncated in the middle of the line
  - should try not to truncate first:
     - if over max lines, then truncate it
     - if not over max lines, keep it not truncated

t.log(VAL,...)
  - workers should not redirect stdout|stderr to parent
  - if a test is passing and CONF.level 'error|warn' (but not 'silent'), still report it if it contains t.log()
  - --pretty reporting:
     - all lines prefixed with =>
     - in gray
     - multiline formatting, same as snapshot reporting
  - --tap reporting:
     - TAP comment
     - single line
  - if several VAL: reported on separate lines

Default reporter:
  - newlines:
     - test iteration with no content
        - no newline before|after
        - reason: more compact and make assertion testing look similar to other test runners
        - e.g. for:
           - "pass" tests
           - non-first errors with CONF.level "warn"
     - test iteration with content:
        - no newline before, but newline after
  - tests with no data iteration:
     - single line:
        - "PASS|FAIL" (backgroundGreen|Red)
        - "shortest filepath" + test title: no background color, normal foreground color
     - ERROR (if any)
  - tests with data iteration:
     - header:
        - once per test
        - 3 lines: bottom-filled color, full-filled color, up-filled color (like test-openapi)
        - color is inverted auto
        - "shortest filepath" + test title
     - subheader:
        - once per test iteration
        - "PASS|FAIL" (backgroundGreen|Red)
        - data:
           - use info.title from test-each
           - no background color, normal foreground color
     - ERROR (if any)

Use itself for unit testing, but its latest release (not direct require())

Fuzz testing:
  - use test-each: NUM, input functions
  - NUM as data dimension:
     - NUM is absent from test titles
     - only report once, either all "pass" or the first one that "fail"
  - CONF.repeat NUM (--repeat):
     - def: 1
     - >= 0
     - append NUM to each set of data, i.e. repeat each test NUM times

Fuzz data generation:
  - similar to faker but specific to fuzz testing
  - data meant to test different types (and potential issues) of inputs
     - e.g. for numbers: Infinity, -Infinity, NaN, +0, -0, EPSILON, MAX|MIN_SAFE_INTEGER, MAX|MIN_VALUE, 1/3, 1, 10
     - e.g. for strings: get some ideas from big-list-of-naughty-strings but ensure those are printable, and smaller set
  - export:
     - each set of data
     - methods that retrieve random value among each set of data
  - random function should allow a seed as argument
  - try to search for similar packages
  - separate package
  - link to it from documentation of both test-each and difftest

Executing commands:
  - should create a separate repo which is a thin wrapper around execa()
  - returning { code, stdout, stderr[, error] }
  - always use opts.reject false
  - with correct normalization
  - allow using current package CLI name (finds it in `package.json`)
      - see https://github.com/sindresorhus/execa/issues/281

Watch mode:
  - CONF.watch BOOL (-w|--watch)
      - def true??? except if all tests passed???
  - re-run files on file change
      - test file change -> only that test file
      - source file or test helper change??? Possible ideas:
         - check filesystem atime to see if file accessed during synchronous load
             - problem: filesystem is global, and worker threads use tine slicing
             - problem: atime does not always work on some OS, or with some filesystem types/options (noatime)
         - checking require.cache or using require hooks:
             - problem: does not work in browsers
             - problem: does not work with ESM
         - static analysis of ESM:
             - problem: does not work with CommonJS
             - problem: does not work with dynamic import()
             - problem: might be harder with transpiled languages like TypeScript (although that might be supported by parsers)
      - cancel current prompt
  - add r/restart action to re-run all tests
  - when run done, keep prompt but remove all actions except quit and restart
     - show end summary first
  - initial run???

Config:
  - test OPTS can also be set as global defaults on CONF

Snapshots???
  - should ideally:
     - use a single file per snapshot
     - be a simple human-friendly flat text file
     - be resistant to linter/IDE/text editors modifications
     - be diff friendly
  - have both Markdown and binary files like ava???
     - use v8.serialize() on binary files???
     - use brotli on binary files???
     - maybe should be normal text file instead of Markdown, because users will look at it in IDE, not browser
  - use sourcemaps to figure out where to put snapshots
     - or only allow overidding snapshot dir instead???
  - should try to keep existing sorting, so that git diff do not show changes due to sorting
  - key should be combination of:
      - "shortest filepath"
      - test title
      - ARR of data serialized with same logic as snapshot

Try to separate snapshot testing into own project that can be used with other test runners???

Should run in browsers too
  - add multi platform capability???

Getting inspirations???
  - re-document snap-shot-it
  - from current testing docs
  - should also finish testing docs
