
                    
   ROADMAP DIFFTEST  
                    



Catchphrase: "Snapshot-driven testing" and/or "Forget test assertions"
  - do not set it until promotion, to avoid idea stealing

Logo:
  - "difftest" and include green + and red - inside letters
  - nice sans-serif non-monospace font

test("TITLE", [...ARR], FUNC(...ARG)->[PROMISE_]VAL [, ...OPTS])->PROMISE
  - must be called synchronously during file load
  - named export `test` (not default export)

"TITLE":
   - not optional
   - must be unique within file

...ARR + FUNC:
   - use test-each
   - `info` not passed to FUNC

FUNC:
   - should return VAL to snapshot
   - should be fired on next tick
   - if return PROMISE, await it

PROMISE:
  - resolved value:
      - OBJ:
         - title STR, args: ARR_ARR, options OPTS
         - tests OBJ_ARR: success BOOL, type 'new|removed|same|different|inconstant', action 'next|update|remove|move|input', value VAL, snapshot STR, args ARR, async BOOL, errored BOOL
         - others???
      - not documented. Meant for plugins.
  - always resolved, even on test failure

Re-using:
   - TITLE (like describe()): test = (title, ...args) => test(`TITLE > ${title}`, ...args)
   - ...ARR: test = (title, ...args) => test(title, ...ARR, ...args)
   - OPTS: test = (...args) => test(...args, OPTS)
       - which is why OPTS is variadic

Hooks not needed:
  - beforeAll():
      - just execute code in top-level scope
      - for async, top-level code can return PROMISE then each test can use await PROMISE
   - afterAll(): use Promise.all(...PROMISE).then() using returned PROMISEs
   - before|afterEach(): just repeat code at beginning|end of FUNC

Exceptions or rejected PROMISEs:
  - snapshot the ERROR
  - serializer should always snapshot ERRORs with String() (i.e. no stack trace)
  - snapshot (including reporting) should include the fact that it's been either thrown or rejected (async BOOL, errored BOOL)

CLI runner:
  - called "dt" to make it fast to type

Files selection:
  - use CLI argument "GLOB"... (whitelisting)
     - can be "!GLOB" (blacklisting)
     - can target DIRs
  - def: test[s]|spec|__tests__/**/*.EXT, **/*.[sS]pec|test.EXT, **/[*-]test[-*].EXT, !helpers|fixtures, !_*
     - EXT is .js[x]|ts[x]
  - always exclude:
     - snapshot files
     - node_modules, bower_components, jspm_packages

Tests selection:
  - OPTS.skip BOOL (def: false):
     - do not run
     - do not report, except in summary
     - do not make snapshots "removed"
  - OPTS.only BOOL (def: false):
     - like adding OPTS.skip true to all other tests
     - priority over OPTS.skip
     - file-wise, i.e. user might need to use files selection too

Test declaration:
  - once all tests of a worker have finished, do not terminate it
     - let worker end on its own (i.e. no more macrotasks) or on global timeout
     - reason: allow afterAll() hooks
  - if a worker does not define any tests during the initial synchronous load, make whole tests run fail
     - reason: avoiding spawning lots of useless workers because of misconfiguration
  - if a test is declared twice by different workers, do not error, but only run test once

Snapshot types:
   - "new" snapshots
   - "removed" snapshots
   - "same" snapshots (i.e. unchanged)
   - "different" snapshots (same snapshot key but different snapshot)
   - "inconstant" snapshots (current test code created different snapshots when run several times)
   - "process" snapshots (process errors)

Interactive mode:
   - CONF.interactive BOOL (--[no-]interactive in CLI)
   - false:
        - always false (cannot override) if !stdin.isTTY || isCi
        - always false with other reporters than 'pretty'
        - no prompting
   - true (def):
        - interactively ask on each snapshot which action to do
        - similar to add -p
        - prompt is:
              n/next, u/update, r/remove, m/M/move, i/input, u/undo, q/quit
              1/single, t/test, f/file, */all, v/[no-]verbose, c/[no-]compact, ?/help

"next" action:
   - go to next snapshots
   - tests will fail if "new"|"removed"|"different" snapshots

"update" action:
   - if "new" snapshots, create it
   - if "different" snapshots, update it
   - not shown if "removed"|"same"|"inconstant"|"process" snapshots

"remove" action:
   - remove current snapshots
   - tests will fail if "same"|"different" (not if "removed")
   - not shown for "new"|"inconstant"|"process" snapshots

"move" action:
  - goal: tests that were renamed or moved to another file (but not removed):
     - should not be reported as 2 different snapshots ("removed" + "new")
        - if snapshot content changed, it should also be reported as a diff
     - should not reorder snapshots layout (so there is no git diff)
  - challenges (document those in code comments):
     - renaming files: tests might also have been renamed|added|removed
     - renaming tests: to identify, cannot reliably use:
        - FUNC.name: arrow function name is ""
        - FUNC.name|toString(): tests might be wrapped, i.e. identical wrapper will show for several tests
           - including FUNC.bind()
        - FUNC.data: it is common for the same set of data to be re-used across tests
        - index in the file: adding one test at beginning change whole order
     - streaming issues:
        - if comparing snapshots content: must wait for all tests of a given file to complete, before reporting the first one
        - if comparing files: must wait for all files to synchronously load, before reporting the first one
  - m/M/move action:
     - only shown for "removed" snapshots
     - either:
        - whole file was removed:
           - M action: renamed whole file
        - otherwise:
           - m action: renamed test
           - M action: moved to different file
     - renames the snapshot path or the test name in the snapshot
        - the snapshot will be reported again later:
           - with different path|title
           - with new corresponding snapshot, i.e. different snapshot type
           - the snapshot follows normal ordering rules
              - exception: when moving test to another file and that file is ordered before current one, process current file snapshots first
        - should keep the snapshot file as is, i.e. not re-order tests (so there is no git diff)
     - in snapshot files, persist hashes (only 8 hex chars) of:
        - each test file's raw content
        - each snapshot data + FUNC.name + FUNC.toString()
     - highlight action when very likely that file|test was renamed
        - highlighted the same way as the previous action after "undo" action
     - ask user for new name among list of possible ones
        - use CLI combo box (dropdown + search with autocomplete)
           - current file's test titles should be known because tests are executed on next tick, i.e. first test cannot be reported before tests were defined synchronously top-level
           - should show possible test files as path relative to current one
              - omit "./" in output (autocomplete, dropdown) but allow it in input
              - including extension
        - sorted by most likely:
           - renamed whole file:
              - another file has same content hash (highlight action)
              - siblings
              - children, depth level by level
              - parent, depth level by level
              - lexicographic order
           - moved to different file:
              - no highlight action / content hash
              - otherwise same as "renamed whole file"
           - renamed test:
              - same snapshot hash (highlight action)
              - same index in file
              - index 0 to last

"input" action:
   - modify current snapshots by prompting for input
   - for "new"|"same"|"different" snapshots
   - not shown for "removed"|"inconstant"|"process" snapshots
   - prompt:
        - use Node REPL ("readline" core module)
        - can use history to see previous inputs
        - current snapshot is copied in clipboard
        - retry if invalid input
   - tests will fail, unless input snapshot is the same as current snapshot
   - only shown when group "single"
   - goal: test-first development

"undo" action:
   - for the last "next|update|remove|move|input" action
        - including grouped action
   - restore previous group|verbose modes if different
   - should highlight previously done action
   - not shown if no action to undo

"verbose" mode:
   - toggle between CONF.level 'verbose' and 'warn'
   - CONF.level 'error' never possible in interactive mode
   - prompt should not show current mode

Group mode:
   - several snapshots at once:
        - print each before prompt
        - action applies to each
   - grouped by "GROUP": single, test, file, all
   - def is CONF.group (def: 'single')
   - prompt should not show current group mode
   - for a given group, each snapshot type is shown and prompted separately:
        - in order: "same" > "different" > "removed" > "new"
        - reason: being able to do separate actions for each snapshot type, since they share common actions
   - only if CONF.interactive true

Switching between modes:
 - group|[no-]verbose mode: do not switch to snapshots where an action (including "next") was already taken
 - switch first snapshot to:
     - "verbose" mode: first "same" snapshot of current group (or of current test if group "single"). If none, current snapshot.
     - "no-verbose" mode: first "different"|"removed"|"new" snapshot of current group (or of current test if group "single"). If none, of next group.
     - group mode: current snapshot

CONF.level STR:
  - among 'error', 'warn', 'verbose'
  - do not report passing snapshots:
     - for 'error|warn' but not 'verbose'
  - do not report content (but still report header) of snapshots, except first one of each test + snapshot type
     - for 'error' but not 'warn|verbose'
  - for any reporters
  - default value:
     - pretty: 'warn' if interactive, 'error' otherwise
     - tap|notify: 'error'
     - json: 'verbose'

Default reporter:
  - the following applies regardless of group mode
  - each test: purple header with:
      - "shortest filepath" (see below)
      - test title:
          - ellipsis in middle if needed
  - each data:
      - smaller header (do not repeat test header)
      - color of header: "new" (backgroundGreen), "removed" (backgroundRed), "different" (backgroundYellow), "same" (backgroundGrey), "inconstant" (backgroundMagenta), "process" (backgroundCyan)
      - start with snapshot type: "New", "Removed", "Different", "Same", "Inconstant", "uncaughtException|unhandledRejection|..."
      - then data:
          - space-separated ARGs
          - ARG stringified with prettyFormat()
          - ellipsis in middle of each ARG if needed
             - each ARG gets same amount of max chars
          - for "process", this is an explanatory text (like in log-process-errors)
  - content first column:
      - "removed" snapshots: red minuses for all lines
      - "new" snapshots: green pluses for all lines
      - "different" snapshots: red minuses or green minuses for relevant lines
      - "same" snapshots: nothing
      - "inconstant" snapshots: like "different" if snapshot exists, "new" otherwise
      - "process" snapshots: nothing
  - content: full snapshot
  - for "inconstant": data header + content is reported twice, because two snapshots are shown
  - prompt question:
      - remove it after user has confirmed input
  - prompt input:
      - prompt characters (on the left) should be very noticeable so that it is easy to scroll up and distinguish groups
      - input should be left so user can see previous answers

Color highlighting in snapshots:
  - use a syntax highlighting library
      - so that YAML/HTML/etc. snapshots arre highlighted too
      - should work well with prettyFormat()
  - all snapshots types:
      - but for "different" snapshots: not on the added|removed lines. They should instead be backgroundGreen|Red and auto in foreground
  - CONF.color BOOL (--[no-]color) (def: chalk default)

Compact mode:
  - goals:
      - make each headers + snapshot + prompt fit a single screen
      - avoiding slowing down machine when snapshot is big
  - [no-]compact mode:
      - only show one of them at a time
      - def is CONF.compact BOOL (def: true) (or --[no-]compact)
  - truncates:
      - OBJ max depth 2
      - ARR max length 4
          - truncate in middle
      - max lines NUM:
          - truncate in middle
          - newline should be either CRLF or LF
          - NUM should be whatever fits a typical terminal screen
          - each series of 80 chars without any newlines should be considered a line:
              - increments the number of "lines"
              - might be truncated in the middle of the line
  - should try not to truncate first:
      - if over max lines, then truncate it
      - if not over max lines, keep it not truncated
          - do not show "[no-]compact" modes

Reporting:
  - should take as input UI information: snapshots, titles, filepaths, data, whether an error was thrown|rejected, available actions, etc.
  - interactivity:
      - should declare whether it can be interactive
      - if OPTS.interactive true, should return action as output (and argument for "input" action)
  - should not need to handle most logic including:
      - action handling
      - color highlighting
      - showing last action with undo
      - truncating
      - grouping and modes (just get current snapshots as input)
  - counter (like test-openapi)
      - for all reporters except tap
  - end summary:
      - for all reporters
  - designed to allow a potential GUI interactive reporter in the future

CONF.reporters STR_ARR (-R|--reporter):
  - types:
      - pretty (default)
      - tap
      - json
      - notify
  - only "notify" can be used with others

Reporting ordering:
  - the following applies to all reporters
  - run in parallel but buffer and report in order (like test-openapi)
     - should stream it, including in interactive mode
  - order should be:
     - for any group mode (including single)
     - according to (by priority):
        - removed files > new files > other files > process errors
        - lexicographical ordering of "shortest filepath" (see below)
        - when test() was called
        - snapshot type: "same" > "different" > "removed" > "new"
        - argument order in parameters

Removed snapshots:
  - those are not automatically pruned:
     - user must be explicit because they might have removed snapshots by accident during test refactoring
     - also this makes design simpler and more orthogonal, at the expense of more actions from user
  - reported when file selection targets either:
     - the removed file (even though it does not exist anymore)
     - all files (files that exist and have snapshots)

Use itself for unit testing, but its latest release (not direct require())

Use worker threads / workers for each test file

Timeout:
  - CONF.timeout NUM (in secs):
     - global timeout, because per-test timeout does not work with parallel tests
     - def 10 minutes
     - when hit, report which tests are still running
  - on SIGINT/SIGTERM/SIGQUIT/etc.
     - if no tests finished in last 5 secs
     - then report which tests are still running
     - goal: allow debugging hanging code

Normalization:
   - to normalize snapshots, user needs to modify the return value of tests before returning it
   - create a separate package with some common normalization methods:
       - separate some of those methods to own package if makes sense, including deep(), compose(), error(), duration()
       - deep(FUNC(VAL)->VAL)->FUNC(OBJ)->OBJ:
           - make a mapping FUNC recursive
           - avoid infinite recursions
           - only enumerated own properties
           - applied to all methods in the package
      - compose(FUNC,...)->FUNC: functional compose
      - trim(STR)->STR
      - error(STR)->STR: replace stack traces (lines starting with \s+at ...) by single "at STACK TRACE"
          - should work on ERROR since error() is deep and should be applied to error.stack
      - colors(STR)->STR: remove colors
      - duration(STR[, STR2])->STR: replace anything that looks like durations by STR2 (def: "100ms")
      - timestamp(STR[, STR2])->STR: replace anything that looks like timestamps by STR2 (with a default of epoch)
      - newline(STR)->STR: CRLF or LF
      - removePath(STR)->STR: remove anything that looks like a path (including Windows PATH)
      - normalizePath(STR)->STR: normalize Windows paths to Unix paths
      - replace(REGEXP, STR)

Fuzz testing:
  - use test-each: NUM, input functions
      - rely on opts.indexes from test-each to know whether they were originally used
  - CONF.repeat NUM:
      - append NUM to each set of data, i.e. repeat each test NUM times
      - >= 0
      - def: 2 if new|different snapshot, 1 otherwise
          - goal: checking for inconstant results, due to randomness in either input function or test function itself
  - NUM as data dimension:
      - NUM is absent from snapshot key
      - only a single snapshot is created for all iterations:
          - if all the same, use any
          - if any differs: snapshot type "inconstant":
              - no prompt
              - test always fails
              - first two different snapshots are reported
                  - if any snapshot is same as current one, should use it as the first one
  - input function:
      - `${FUNC.name}()` (or "function()" if anonymous) should be used as snapshot key
      - but generated value should be used in reporting
      - although test takes randomness as input, the test output should be consistent across runs, otherwise each new run will fail

Fuzz data generation:
  - similar to faker but specific to fuzz testing
  - data meant to test different types (and potential issues) of inputs
     - e.g. for numbers: Infinity, -Infinity, NaN, +0, -0, EPSILON, MAX|MIN_SAFE_INTEGER, MAX|MIN_VALUE, 1/3, 1, 10
     - e.g. for strings: get some ideas from big-list-of-naughty-strings but ensure those are printable, and smaller set
  - export:
     - each set of data
     - methods that retrieve random value among each set of data
  - random function should allow a seed as argument
  - try to search for similar packages
  - separate package
  - link to it from documentation of both test-each and snapshot testing tool

CONF.require STR_ARR (-r|--require)
  - passed as `execArgv` to workers
  - make sure it works with "ts-node/register"
     - document it

Make sure NODE_OPTIONS ENVVAR works
  - including --inspect[-brk]

CONF.bail BOOL (-b|--bail)
  - stops on first failure
     - still run|report other data of same test
  - "stops":
     - terminate workers
     - do not run|report any additional tests
  - always false with CONF.interactive true

Process errors:
  - use log-process-errors
      - does not make process exit
  - snapshot type "process":
      - reported at end of test run
      - filepath "", title "Process errors"
      - snapshot content is the main error value
      - no prompt
      - no snapshot
      - test always fail
  - CONF.processErrors STR_ARR
      - which types creates failures (others are ignored)
      - def: ["uncaughtException", "unhandledRejection"]
          - default is conservative to avoid annoying users

Watch mode:
  - CONF.watch BOOL (-w|--watch)
      - def true??? except if all tests passed???
  - re-run files on file change
      - test file change -> only that test file
      - source file or test helper change??? Possible ideas:
         - check filesystem atime to see if file accessed during synchronous load
             - problem: filesystem is global, and worker threads use tine slicing
             - problem: atime does not always work on some OS, or with some filesystem types/options (noatime)
         - checking require.cache or using require hooks:
             - problem: does not work in browsers
             - problem: does not work with ESM
         - static analysis of ESM:
             - problem: does not work with CommonJS
             - problem: does not work with dynamic import()
             - problem: might be harder with transpiled languages like TypeScript (although that might be supported by parsers)
      - cancel current prompt
  - only in interactive mode
  - add r/restart action to re-run all tests
  - when run done, keep prompt but remove all actions except quit and restart
     - show end summary first
  - initial run???

Config:
  - test OPTS can also be set as global defaults on CONF

Executing commands:
  - should create a separate repo which is a thin wrapper around execa()
  - returning { code, stdout, stderr[, error] }
  - always use opts.reject false
  - with correct normalization
  - allow using current package CLI name (finds it in `package.json`)
      - see https://github.com/sindresorhus/execa/issues/281

Snapshots???
  - should ideally:
     - use a single file per snapshot
     - be a simple human-friendly flat text file
     - be resistant to linter/IDE/text editors modifications
     - be diff friendly
  - have both Markdown and binary files like ava???
     - use v8.serialize() on binary files???
     - use brotli on binary files???
     - maybe should be normal text file instead of Markdown, because users will look at it in IDE, not browser
  - use sourcemaps to figure out where to put snapshots
     - or only allow overidding snapshot dir instead???
  - should try to keep existing sorting, so that git diff do not show changes due to sorting
  - key should be combination of:
      - "shortest filepath":
          - if unique: filename without .EXT
          - if differ only by .EXT: filename with .EXT
          - otherwise, prepend first parent dir (and so on) until different (and do not use .EXT)
      - test title
      - ARR of data serialized with same logic as snapshot

Should run in browsers too
  - add multi platform capability???

Getting inspirations???
  - from current testing docs
  - should also finish testing docs
