
                    
   ROADMAP DIFFTEST  
                    



Catchphrase: "Snapshot-driven testing" and/or "Forget test assertions"
  - do not set it until promotion, to avoid idea stealing

Logo:
  - "difftest" and include green + and red - inside letters
  - nice sans-serif non-monospace font

test("TITLE", [...ARR], FUNC(t, ...ARG) [, ...OPTS])->PROMISE
  - named export `test` (not default export)

"TITLE":
  - not optional
  - must be unique within all test files
  - test iterations are identified with TITLE + ARGs (using info.title from test-each)

...ARR + FUNC:
  - use test-each

t OBJ:
  - index, indexes: like test-each
  - name STR
  - title STR: name + stringified data used for reporting
  - log(VAL,...)
  - snapshot(VAL[, STR])

Returned PROMISE:
  - resolved value:
      - OBJ:
         - title STR, args: ARR_ARR, options OPTS
         - tests OBJ_ARR: args ARR, error ERROR
         - others???
      - meant for plugins.
  - always resolved, even on test failure

Re-using:
   - TITLE (like describe()): test = (title, ...args) => test(`TITLE > ${title}`, ...args)
   - ...ARR: test = (title, ...args) => test(title, ...ARR, ...args)
   - OPTS: test = (...args) => test(...args, OPTS)
       - which is why OPTS is variadic

CLI runner:
  - called "dt" to make it fast to type

Files selection:
  - use CLI argument "GLOB"... (whitelisting)
     - can be "!GLOB" (blacklisting)
     - can target DIRs
  - def: test[s]|spec|__tests__/**/*.EXT, **/*.[sS]pec|test.EXT, **/[*-]test[s][-*].EXT, !helpers|fixtures, !_*
     - EXT is .js[x]|ts[x]
  - always exclude:
     - snapshots/
     - node_modules/, bower_components/, jspm_packages/

Tests selection:
  - OPTS.skip BOOL:
     - do not run
     - do not report, except in summary
     - --tap should use SKIP directive
     - document the following pattern: OPTS.skip process.platform === STR (as opposed to put test() inside an if block)
  - OPTS.only BOOL:
     - like adding OPTS.skip true to all other tests
     - in current file only, i.e. user might need to use files selection too
     - priority over CONF.skip
  - CONF.skip|only REGEXP_ARR (-s|-o|--skip|--only):
     - add OPTS.skip|only true to matched tests
     - partial matching
     - on the CLI, is 'REGEXP' case-insensitive
     - matched against test titles

Worker errors:
  - errors not related to tests logic
  - reported after process errors
  - types:
     - WORKER 'error' event: should only happen if bug in library, because we catch uncaught exceptions otherwise
     - test files loaded twice
     - empty test file
     - test() run too late

Test files loaded twice:
  - should prevent two workers from loading the same test file. Reasons:
     - slow: runs tests twice
     - slow: spawns unnecessary workers, e.g. when one worker is a subset of another
     - verbose: reports tests twice
     - duplicates same snapshots across different snapshot files
  - enforced by making 'TITLE' (excluding data) unique across workers (instead of worker-wise):
     - throw a "worker error"
     - error message should indicate that either:
        - two tests are using the same 'TITLE'
        - a file was loaded twice from different top-level test files
     - reason: hard to know which parent loaded a file without using hacks like ERROR.stack

Empty test file:
  - if a worker exits normally but no tests were defined, throw a "worker error"
     - reason: spawning unnecessary workers is slow
  - should still allow workers which define tests but do not run them (e.g. because of OPTS.skip)

Test declaration:
  - on next tick after first test():
     - no more test() allowed (throw "worker error")
     - run tests
  - i.e. all test() must be defined at once. Reasons:
     - separating test definition step from test running step can help with other features
  - but test() do not need to be defined during file load
     - reason: allows beforeAll() without each test awaiting a top-level promise
  - once all tests of a worker have finished, do not terminate it
     - let worker end on its own (i.e. no more macrotasks) or on global timeout
     - reason: allow afterAll() hooks

Hooks not needed:
   - beforeAll(): execute code in top-level scope, including PROMISE
   - afterAll(): use await Promise.all(...PROMISE) using returned PROMISEs
   - before|afterEach(): repeat code at beginning|end of FUNC

Use worker threads / workers for each test file

Parallelism:
  - CONF.maxConcurrency NUM
     - number of parallel workers at once
     - i.e. 1 for serial
     - def: number of CPUs
  - OPTS.serial BOOL
     - def: false
     - runs test serially inside its worker
     - serial tests run before parallel ones

Any Node flags should be allowed as CLI flags:
  - it should be passed as `execArgv` to workers
  - should whitelist them, so that wrong CLI flags still trigger a validation error
     - do not include flags that do not make sense like --interactive
  - including --require
     - make sure it works with "ts-node/register"
     - document it
  - including --inspect[-brk]:
     - make sure it works
     - document it
  - --experimental-repl-await should always be passed (unless Node<10.0.0)

CONF.timeout NUM (in secs):
  - def: 10 minutes
  - global timeout, because per-test timeout does not work with parallel tests
  - when hit, report which tests are still running

User interrupt:
  - on SIGINT|SIGTERM|SIGQUIT|etc.
  - if no tests finished in last 5 secs
  - then report which tests are still running
  - goal: allow debugging hanging code

CONF.bail BOOL (-b|--bail)
  - stops on first failure
     - still run|report other data of same test
  - "stops":
     - terminate workers
     - do not run|report any additional tests

Assertion testing:
  - any assertion library works:
     - just need to throw error
     - core 'assert', power-assert, chai, should.js
  - failure reporting:
     - ERROR.name + ERROR.message
        - no name if ERROR.printName false
     - stack trace (in order):
        - unless ERROR.printStack false
        - remove node_modules/** and Node internals
        - apply source maps
        - strip common root from path
        - need to work with different browsers
        - see if libraries exist that do this (probably stacktrace.js)
     - preview the source code context:
        - like ava does
        - unless ERROR.printContext false
        - after source maps applied
        - only of the deepest stack call
        - do not do it if lines are very long, which probably indicates a concatenated build

Process errors:
  - use log-process-errors
     - does not make process exit
  - reported as failed tests:
     - at end of test run, but before "worker errors"
     - filepath ""
     - title: first line of ERROR.message "uncaughtException|unhandledRejection|..." + explanation
     - use log-process-errors ERROR (except first line) as if it had been thrown
  - CONF.processErrors STR_ARR
     - which types creates failures (others are ignored)
     - def: ["uncaughtException", "unhandledRejection"]
        - default is conservative to avoid annoying users

Underlying snapshot repository:
  - test runner adapters (including difftest itself) should abstract:
     - retrieving __filename and 'TITLE'_ARR:
        - ideally by using global variables
        - but can also monkey patch it|test() (including .only|skip())
     - running init() and done()
     - passing SNAPSHOTS and "TITLE" to snapshot()
  - difftest:
     - __filename and 'TITLE'_ARR: known by core
     - init(): done before worker starts and passed to it via IPC
     - done(): done after worker end and passed from it via IPC
     - snapshot(SNAPSHOTS, "TITLE", VAL) -> t.snapshot(VAL)
     - ENVVAR SNAPSHOT_MODE=test|update|remove|input -> CONF.update|remove|input BOOL (-u|--update|-r|--remove|-i|--input)
        - not compatible with each other
  - "TITLE" should include data if data-driven testing
     - including for snapshot() and done()

Snapshots file:
  - persisted at `./snapshots/TEST_FILENAME.EXT.snap`
  - use the top-level test file, not the current one

Snapshot key:
  - use filepath + test title + data + STR (snapshot name)
     - for input functions: use `${FUNC.name}()` (or "function()" if anonymous) instead of generated value
     - filepath does not need to be persisted in snapshot file, since it is used for the snapshot filepath itself
     - should be persisted in a way to allow retrieving only one of the parts (e.g. only test title)
     - data should be serialized with the same logic as the content
  - can use same key several times:
     - used when NUM as data dimension, since test title repeats
     - with SNAPSHOT_MODE=update, only first one is persisted
     - if two snapshot() with same key differ, it should just work:
        - with SNAPSHOT_MODE=update, different snapshots will be ignored
        - otherwise, one of the snapshots will fail, stopping test iteration

init(__filename)->PROMISE_SNAPSHOTS:
  - SNAPSHOTS contains state:
     - __filename
     - content of corresponding snapshot (of any)
  - for most test runners, done during beforeAll() hook
  - serializable so it can be passed to workers using structured clone algorithm
     - ideally should be JSON serializable

snapshot(SNAPSHOTS, "TITLE", VAL[, STR]):
  - comparison result:
     - "same": success
     - "different|new": depends on SNAPSHOT_MODE=update
  - on failure, throws ERROR with ERROR.message containing:
     - snapshot name (if defined)
     - description message, e.g. "New snapshot:", "Snapshot changed:", etc.
     - snapshot content
  - on success, returns true
     - reason: allowing shortcut notation assert.throws(FUNC, snapshot)
  - record result (including "TITLE") in SNAPSHOTS
  - synchronous
  - VAL is not awaited even if PROMISE: user must explicity use snapshot(await VAL)
  - no way to catch FUNC exceptions: user must explictly use assert.throws(FUNC, snapshot)
  - STR is snapshot name
     - required if two snapshots in same test
        - so we know which one to diff

done(SNAPSHOTS, "TITLE"_ARR)->PROMISE
  - if SNAPSHOT_MODE=update:
     - persists snapshots
        - create snapshot file if it does not exist yet
     - prune snapshot files and snapshots
  - done only once per file instead of incrementally as tests go, in order to limit I/O and risks of concurrency
  - should not be called if test() definitions (not test runs) might have failed
  - if any snapshot() recorded in SNAPSHOTS is not among "TITLE" throw error
     - this means user forgot to specify it
     - however not the other way around since tests might have used skip()
  - for most test runners, done during afterAll() hook

ENVVAR SNAPSHOT_MODE=test:
  - default value
  - in CI, can only be 'test'

ENVVAR SNAPSHOT_MODE=update:
  - what snapshot() should do on "new|different" snapshots
  - also whether to prune
  - if false (def):
     - do not add|prune|modify inside snapshot files
     - throw ERROR
  - if true:
     - add|prune|modify inside snapshot files
     - do not throw ERROR

ENVVAR SNAPSHOT_MODE=remove:
  - make snapshot():
     - remove snapshots in snapshot file
     - throw ERROR "Removed snapshot"
        - do not show snapshot content

ENVVAR SNAPSHOT_MODE=input:
  - goal: test-first development for snapshots
  - done after test run:
     - does not modify test run itself:
        - including snapshot()
        - including exit code
     - reasons:
        - easier to understand for end-user
        - easier to combine with test runners, because does not mix with their reporting or run
        - separation of concerns: no issues mixing with reporting
        - prompt would be slow if CPU is fully used by running tests
  - prompt for every snapshot() executed during test run:
     - passing or not
        - i.e. can update existing snapshots, not only new ones
     - unreachable snapshot() are not prompted:
        - e.g. when assertion fails before them
           - including when having several snapshot() in same test and one throws
        - workaround: move the snapshot() temporarily, then move it back
  - prompt for snapshot:
     - if submit something:
        - updates snapshot in snapshot file with it
     - if submit without entering anything:
        - keep current snapshot (including none)
        - must distinguish from explicitely entering undefined
        - same as n/next
  - if there is an existing snapshot, print it before each prompt
  - prompt:
     - use Node REPL ("readline" or "repl" core module)
     - can multiple statements (use the last one)
     - can use history (arrow up) to re-use previous inputs
     - retry if invalid input
     - not erased after submit
  - n/next, u/undo, q/quit, ?/help actions
     - if REPL does not allow raw input without quotes, can define those actions as variables with SYM as values instead
  - how should reporting look like??? Similar to pretty reporter???
     - clearly separate from test run with a big header???
  - end()->PROMISE in underlying snapshot utlity
     - how to do this with test runners without that concept like ava???
        - however possible with all other test runners
        - maybe???
           - endEach() that persists state in temporary files, to do in after() for each worker
           - then CLI utility that uses it

Snapshots in renamed files|tests:
  - no special treatment, they are just removed + new snapshots

Pruning:
  - only if SNAPSHOT_MODE=update
  - done() performs the three kinds of pruning specified below
  - removing orphan snapshot files:
     - for each test file that is run:
        - `readdir('parent/')` -> sibling test files
        - `readdir('parent/snapshots/')` (if exists) -> sibling snapshot files
        - remove any orphan snapshot file
     - if remove fails, ignore silently. Reasons:
        - each sibling test file will try removing the same file in parallel, which leads to race condition
        - pruning is not priority, it's ok if it fails
     - when removing last test file in a directory, won't prune its snapshot file:
        - i.e. users should do it themselves, but most users will probably do it naturally
     - reasons:
        - it works even when specific test files are being selected
           - in which case, it restricts pruning to the siblings (as opposed to pruning completely unrelated files)
        - it does not require any global index file
        - it does not require knowing what the root directory is, or recursing over many files
        - it does not require knowing what the current test selection is
  - removing orphan snapshots for whole tests in a given file:
     - remove any snapshot if no test defined (not run) with the same "TITLE"
     - if it|test() is inside an if block, will always be pruned. Possible workarounds:
        - add else block with it|test.skip()
        - use OPTS.skip BOOL instead
        - move if block inside the test function
     - when removing the last it|test() from a test file, but not removing the file itself, snapshots won't be pruned
        - because file would stop being considered a test file, i.e. cannot be selected as top-level test file anymore
        - i.e. users should do it themselves, but this is an edge case
     - reasons:
        - it allows not pruning snapshots when:
           - an error thrown before reaching snapshot()
           - snapshot() is done conditionally, e.g. only on older Node versions
           - test was skipped with it.only|skip() or global --only|skip
        - it allows pruning snapshots when:
           - removing last snapshot test from test file
        - it does not require monkey-patching it|test()
  - pruning after snapshot() was removed in a test but test itself was not removed
     - whether this was the only snapshot() or not in the test
     - by default, snapshots inside tests are never pruned
        - unless the whole test or file was pruned, in which case the following is not needed
     - user must manually change snapshot(SNAPSHOTS, "TITLE", VAL) to snapshot(SNAPSHOTS, "TITLE") (with no VAL):
        - different from snapshot(SNAPSHOTS, "TITLE", undefined). Can distinguish by using variadic ...args.length
        - this removes all snapshots for current "TITLE" except for any other snapshot() performed in current run (before or after)
        - doing it twice in same test is noop
        - pruning is only persisted once done() is called
        - once pruning is persisted, user can then remove that line of code
     - reasons:
        - it allows not pruning snapshots when:
           - an error thrown before reaching snapshot()
           - snapshot() is done conditionally, e.g. only on older Node versions
        - it works with multiple snapshot() in same test
        - it favors possibly leaving orphan snapshots (if user forgets the extra step) over removing used snapshots (by adding an explicit extra step)
        - it does not require wrapping test|it()
        - it does not require user manually doing SNAPSHOT_MODE=remove
        - it does not require figuring out if a test function has thrown, rejected or not called callback

Snapshots directory creation|deletion:
  - when creating a new snapshot file:
      1) check if snapshot directory exists. If it does, skip 2)
      2) create snapshot directory
          - can error if another worker did 2) at same time. In that case, ignore error and move on.
      3) create snapshot file
          - can error if another worker removed snapshot directory (6)) between 2) and 3). In that case, ignore and error and go back to 2)
  - when deleting a snapshot file:
      4) remove snapshot file
      5) check if snapshot directory is empty. If not, skip 6)
      6) delete snapshot directory
          - should error if not empty, which could happen if another worker created a snapshot file (3)) between 5) and 6). In that case, ignore error and move on.
          - can error if another worker did 6) at same time. In that case, ignore error and move on.

Color highlighting in snapshots:
  - use a syntax highlighting library
     - so that YAML/HTML/etc. snapshots are highlighted too
     - should work well with prettyFormat()
  - first column:
     - "new" snapshots: green pluses for all lines
     - "different" snapshots: red minuses or green minuses for relevant lines

"different" snapshot reporting:
  - report snapshot diff
     - no syntax highlighting on the added|removed lines
     - instead backgroundGreen|Red and auto (or darker green|red) in foreground
  - only report different lines, with 2 lines of context
     - use ellipsis in-between parts

Normalization:
  - to normalize snapshots, user needs to transform the value passed to snapshot()
  - create a separate package with some common normalization methods:
     - separate some of those methods to own package if makes sense, including deep(), compose(), error(), duration()
     - deep(FUNC(VAL)->VAL)->FUNC(OBJ)->OBJ:
        - make a mapping FUNC recursive
        - avoid infinite recursions
        - only enumerated own properties
        - applied to all methods in the package
     - compose(FUNC,...)->FUNC: functional compose
     - trim(STR)->STR
     - error(STR)->STR: replace stack traces (lines starting with \s+at ...) by single "at STACK TRACE"
        - should work on ERROR since error() is deep and should be applied to error.stack
        - should work on CLI error output (i.e. there is no available ERROR instance)
        - should work for any browser
     - colors(STR)->STR: remove colors
     - duration(STR[, STR2])->STR: replace anything that looks like durations by STR2 (def: "100ms")
     - timestamp(STR[, STR2])->STR: replace anything that looks like timestamps by STR2 (with a default of epoch)
     - newline(STR)->STR: CRLF or LF
     - removePath(STR)->STR: remove anything that looks like a path (including Windows PATH)
     - normalizePath(STR)->STR: normalize Windows paths to Unix paths
     - replace(REGEXP, STR)

Reporting:
  - should take as input UI information: titles, filepaths, data, error, etc.
  - should not need to handle most logic including: color highlighting, truncating
  - counter (like test-openapi): for all reporters except tap
  - end summary: for all reporters

CONF.reporters STR_ARR (-R|--reporter):
  - types:
     - pretty (default)
     - tap
     - json
     - notify
  - only "notify" can be used with others

Reporting ordering:
  - the following applies to all reporters
  - run in parallel but buffer and report in order (like test-openapi)
     - should stream it
  - order should be (by priority):
     - most errors > process errors > worker errors
     - lexicographical ordering of "shortest filepath"
     - when test() was called
     - argument order in parameters

"Shortest filepath":
  - used in reporting and reporting order
  - strip root common to all currently selected test files
     - i.e. might change across runs
  - reasons:
     - seeing parent directories help users know about test file's context
        - but shared directories are not as useful
     - consistent when used for reporting order, even when selected test files changes
     - does not require finding package root
  - include file extension

CONF.level STR:
  - among 'silent', 'error', 'warn', 'info'
  - do not report passed tests:
     - for 'error|warn' but not 'info'
  - do not report content (but still report header) of tests, except first failed one of each test
     - for 'error' but not 'warn|info'
  - 'silent': do not report anything
  - for any reporters
  - default value:
     - pretty|tap|notify: 'error'
     - json: 'info'

CONF.color BOOL (--[no-]color):
  - def: chalk default

CONF.compact BOOL (--[no-]compact)
  - def: true
  - goals:
     - make each test fit a single screen
     - avoiding slowing down machine when test content is big
  - truncate ERROR.message to max lines NUM:
     - truncate in middle
     - newline should be either CRLF or LF
     - NUM is terminal height
        - minus test headers height
        - if cannot guess, use a typical terminal height
     - each series of 80 chars without any newlines should be considered a line:
        - increments the number of "lines"
        - might be truncated in the middle of the line
  - should try not to truncate first:
     - if over max lines, then truncate it
     - if not over max lines, keep it not truncated

t.log(VAL,...)
  - workers should not redirect stdout|stderr to parent
  - if a test is passing and CONF.level 'error|warn' (but not 'silent'), still report it if it contains t.log()
  - --pretty reporting:
     - all lines prefixed with =>
     - in gray
     - multiline formatting, same as snapshot reporting
  - --tap reporting:
     - TAP comment
     - single line
  - if several VAL: reported on separate lines

Default reporter:
  - newlines:
     - test iteration with no content
        - no newline before|after
        - reason: more compact and make assertion testing look similar to other test runners
        - e.g. for:
           - "pass" tests
           - non-first errors with CONF.level "warn"
     - test iteration with content:
        - no newline before, but newline after
  - each test:
     - first line:
        - "PASS|FAIL": backgroundGreen|Red
        - "shortest filepath" + test title: no background color, normal foreground color
        - we repeat the first line for each data so that users don't need to scroll up
     - second line (if data)
        - use info.title from test-each
        - no background color, normal foreground color
     - ERROR (if any)

Use itself for unit testing, but its latest release (not direct require())

Fuzz testing:
  - use test-each: NUM, input functions
  - NUM as data dimension:
     - NUM is absent from test titles
     - only report once, either all "pass" or the first one that "fail"
  - CONF.repeat NUM (--repeat):
     - def: 1
     - >= 0
     - append NUM to each set of data, i.e. repeat each test NUM times

Fuzz data generation:
  - similar to faker but specific to fuzz testing
  - data meant to test different types (and potential issues) of inputs
     - e.g. for numbers: Infinity, -Infinity, NaN, +0, -0, EPSILON, MAX|MIN_SAFE_INTEGER, MAX|MIN_VALUE, 1/3, 1, 10
     - e.g. for strings: get some ideas from big-list-of-naughty-strings but ensure those are printable, and smaller set
  - export:
     - each set of data
     - methods that retrieve random value among each set of data
  - random function should allow a seed as argument
  - try to search for similar packages
  - separate package
  - link to it from documentation of both test-each and difftest

Executing commands:
  - should create a separate repo which is a thin wrapper around execa()
  - returning { code, stdout, stderr[, error] }
  - always use opts.reject false
  - with correct normalization
  - allow using current package CLI name (finds it in `package.json`)
     - see https://github.com/sindresorhus/execa/issues/281

Snapshots???
  - should ideally:
     - use a single file per snapshot
     - be a simple human-friendly flat text file
     - be resistant to linter/IDE/text editors modifications
     - be diff friendly
  - have both Markdown and binary files like ava???
     - use v8.serialize() on binary files???
     - use brotli on binary files???
     - maybe should be normal text file instead of Markdown, because users will look at it in IDE, not browser
  - use sourcemaps to figure out where to put snapshots
     - or only allow overidding snapshot dir instead???
  - should try to keep existing sorting, so that git diff do not show changes due to sorting

Watch mode:
  - CONF.watch BOOL (-w|--watch)
      - def true??? except if all tests passed???
  - re-run files on file change
      - test file change -> only that test file
      - source file or test helper change??? Possible ideas:
         - check filesystem atime to see if file accessed during synchronous load
             - problem: filesystem is global, and worker threads use tine slicing
             - problem: atime does not always work on some OS, or with some filesystem types/options (noatime)
         - checking require.cache or using require hooks:
             - problem: does not work in browsers
             - problem: does not work with ESM
         - static analysis of ESM:
             - problem: does not work with CommonJS
             - problem: does not work with dynamic import()
             - problem: might be harder with transpiled languages like TypeScript (although that might be supported by parsers)
      - cancel current prompt
  - add r/restart action to re-run all tests
  - when run done, keep prompt but remove all actions except quit and restart
     - show end summary first
  - initial run???

Config:
  - test OPTS can also be set as global defaults on CONF

Should run in browsers too

Multi-platform capability???
  - run using different browsers
  - run using different Node versions
  - try to abstract whole thing
  - see previous work on nvrun

Getting inspirations???
  - re-document snap-shot-it
  - from current testing docs
  - should also finish testing docs
